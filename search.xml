<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端包管理工具</title>
      <link href="/2025/03/27/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/03/27/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>目前前端开发的库都是以node包的形式进行管理的，而通过包管理工具我们就可以在项目中下载引入某个库进行使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 工程化 </tag>
            
            <tag> 包管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESModule解析流程</title>
      <link href="/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于ESModule是如何被浏览器解析并且让模块之间可以相互引用的详细内容可以看这篇文章:<br><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</a></p><p>我们回顾一下模块化的出现解决了什么问题？</p><ul class="lvl-0"><li class="lvl-2"><p>解决了文件之间的依赖管理问题，不必过于纠结模块的依赖关系引发的顺序问题和删除文件导致的依赖错误。</p></li><li class="lvl-2"><p>避免了污染全局变量，如恶意更改代码和不小心覆盖了变量。</p></li></ul><h2 id="ESModule解析流程">ESModule解析流程</h2><p>对于ES模块，可以分三个步骤进行：</p><ol><li class="lvl-3"><p>Construction（构造）：查找、下载和解析所有文件到模块记录中。</p></li><li class="lvl-3"><p>Instantiation（实例化）：在内存中的查找区域（区域内有一块一块的结构）内放置所有导出的值（但不要用值填充他们）。然后是exports和imports都指向内存中的查找区域块，这称为链接。</p></li><li class="lvl-3"><p>Evaluation（求值）：运行代码以使用变量的实际值填充内存中的查找区域块。</p></li></ol><h2 id="Construction（构造）">Construction（构造）</h2><p>当使用模块化开发时，我们需要给JS运行时环境（如浏览器、NodeJS）指定一个入口文件，通过该入口文件，JS运行时环境将沿着入口文件的import语句向内查找可形成一个依赖关系图，不同的依赖项由各个模块的import语句连接。</p><img data-src="/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class="" title="依赖关系图"><p>而对于每个依赖项的寻找是通过模块说明符（module specifier）来寻找的。</p><img data-src="/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/%E6%A8%A1%E5%9D%97%E8%AF%B4%E6%98%8E%E7%AC%A6.png" class="" title="模块说明符"><p>如果模块说明符是一个相对路径的话，如<code>./utils.js</code>，会将其转换为绝对路径的URL。</p><ul class="lvl-0"><li class="lvl-2"><p>绝对路径的URL是基于HTTP协议的资源定位符。</p></li><li class="lvl-2"><p>由当前服务器的IP和项目运行设定的端口，路径指向服务器定义的根目录。</p></li></ul><p>如果模块说明符直接是一个模块名的话，会通过<code>Import Maps</code>映射为实际的URL，在浏览器端通过在script标签的<code>type=importmap</code>中编写json格式的数据实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;importmap&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;imports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;react&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/react@17.0.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但由于一个个模块其实就是一个个文件，文件并不是浏览器可以使用的东西，浏览器如果想解析这些文件，就需要将其解析为一个个模块记录。</p><p>模块记录其实就是一个对象，包含导入导出声明，以及其依赖关系。</p><p><strong>注意</strong>：模块记录并不包含完整代码的AST，在构造这一阶段，会将代码解析为AST，但仅保留AST中的关键信息，就是上述的导入导出声明以及依赖关系。当构造阶段结束，AST就会被销毁，但运行时环境（浏览器/NodeJS）通常会保留原始代码或编译后的可执行代码（如字节码），用于求值阶段的执行。</p><img data-src="/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95.png" class="" title="模块记录"><p>每个模块记录中的依赖关系不仅可以形成一个模块的依赖关系图，同时也决定了模块的执行顺序。</p><p>当模块解析完后，就会对其进行模块缓存，其缓存会存储在全局<code>Moudle Map</code>中，以模块解析后的URL为键，以模块记录为值。</p><ul class="lvl-0"><li class="lvl-2"><p>目的就是为了避免重复下载：如果模块已加载或正在加载，直接复用缓存。</p></li><li class="lvl-2"><p>模块的状态：</p><ul class="lvl-2"><li class="lvl-4">Fetching（加载中）</li><li class="lvl-4">Fetched（已加载）</li><li class="lvl-4">Instantiation（实例化）</li><li class="lvl-4">Evaluated（已求值）</li></ul></li></ul><h2 id="Instantiation（实例化）">Instantiation（实例化）</h2><p>在构造阶段，我们已经获得了一个个模块记录，每一个模块记录中都包含其相应的导入导出声明和依赖关系，这一阶段的目的就是将每一个模块记录中的依赖关系转换为内存的查找区域块，并完成导入和导出的指向。</p><p>在实例化开始阶段，JS引擎会创建一个模块环境记录（module environment record），模块环境记录管理着模块记录中的导入导出变量，并由JS引擎在内存中为它们分配空间，由模块环境记录对这些变量进行关联，但此时的变量并没有实际值，如果是普通变量的话，值为undefined，如果是函数的话，会对函数进行创建，这有利于求值阶段的执行。</p><img data-src="/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/%E6%A8%A1%E5%9D%97%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95.png" class="" title="模块环境记录"><p>对于模块环境记录中的导入导出变量，可以称之为状态，对于这些状态，JS引擎会通过类似于哈希表的结构进行存储，键为变量名，值为内存地址。</p><p>如果模块记录转换为模块环境记录成功后，就会将这个模块环境记录追加到<code>Module Map</code>中对应的模块记录的后面。</p><p>总而言之，实例化这一阶段，就是将构造阶段的模块记录中的导入导出声明在内存中开辟一块区域进行存储，并与构造阶段的模块记录中的代码解析遗留下来的可执行代码（如字节码）进行结合形成模块环境记录，用于管理变量的内存地址，并为求值阶段的填充值做准备。</p><h2 id="Evaluation（求值）">Evaluation（求值）</h2><p>上文提到，在构造阶段，虽然解析代码后的AST销毁了，但保留了可执行代码（如字节码），在此阶段其实就是进行可执行代码的执行，并为实例化阶段的模块环境记录中跟踪的状态的值填充。</p><p>在代码执行完毕，并对值进行填充完毕后，同样会在对应模块环境记录对应的<code>Module Map</code>的后面追加此模块求值的状态。</p><p>在此阶段，会进行顶层代码的执行，顶层代码指的就是直接就在最外层的代码，即不在任何函数，代码块或异步上下文内的代码，只有从顶层代码开始执行，才能执行其他代码嘛。</p><p>在此阶段，模块的顶层代码只会执行一次，就是在第一次被导入的时候执行，后续再导入就会直接复用结果了，因为对其进行缓存了嘛。</p><p>同时，会开启严格模式对代码进行执行，并不需要显式的指定<code>&quot;use strict&quot;</code>，默认就会开启。所以，通过ESModule的模块化都是在严格模式下进行的。</p><p>同时我们在构造阶段可以得到一个依赖关系图，在求值阶段就会根据该依赖关系进行后序深度优先遍历的顺序执行模块的顶层代码。这样可以确保父模块执行时，使用子模块时已经执行完毕了。</p><p>但模块之间的关系可能会存在循环依赖的问题，对于循环依赖，在构造和实例化阶段是不会有影响的，因为它们并不牵扯到代码的执行，仅仅是依赖关系的解析和变量的实时绑定，但在求值阶段可能会导致变量未初始化（TDZ错误）或副作用顺序异常。</p><p>对于这个循环依赖问题，js引擎对它有一定的处理步骤</p><p>假如a.js和b.ja相互依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;a.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> b = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;b.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p>执行a.js顶层代码，遇到了b.js导入。</p></li><li class="lvl-3"><p>执行b.js代码，但发现a.js导入，但a.js处于正在处理状态。</p></li><li class="lvl-3"><p>强制执行b.js代码，需要处理a.js导出的变量，如果a.js导出的变量是let,const声明的，而a.js中对于b.js的导出在a.js中导出的前面，就会按照浏览器抛出暂时性死区TDZ错误，如果是var声明的，则是undefined。</p></li><li class="lvl-3"><p>返回继续执行a.js代码。</p></li></ol><p>解决循环依赖的方案：</p><ul class="lvl-0"><li class="lvl-2"><p>重构代码，提取公共部分到带三方模块。</p></li><li class="lvl-2"><p>延迟访问。</p></li><li class="lvl-2"><p>使用动态导入。</p></li></ul><p>注意：ESModule在求值阶段可能会产生副作用，如TDZ和执行顺序问题，因为顶层代码指的是最外层的代码，即不在代码块内部的代码，所有如果存在打印语句，也是会执行，因为它们并不是导出和导入相关的，在求值阶段的执行可行性代码就可能会产生上述问题，但也就只会执行一次，因为会对模块的状态和导入导出变量进行缓存，再次引入模块只会获得导入导出的变量在内存中的值罢了。</p><h2 id="关于ESModule和CommonJS">关于ESModule和CommonJS</h2><h3 id="缓存方面">缓存方面</h3><p>CommonJS和ESModule的缓存都是一次执行期间缓存，在内存进行缓存，但它们之间缓存方式还是有所区别的，CommonJS缓存的是导出的对象，并且可以通过api进行缓存删除，而ESModule缓存的是模块记录，实例化环境和求值结果，且没有api能对缓存结果删除。</p><h3 id="执行方面">执行方面</h3><p>而由于ESModule可以在浏览器环境下使用，为了防止线程阻塞，构造、实例化和求值三个阶段可以是异步的并且是并行的，如一个模块引入了多个模块，多个模块之间可以并行解析，但每个阶段内部可以是同步执行的。</p><p>而CommonJS是在用于Node服务端的，并不需要考虑渲染等层面的问题，而且读取文件也是本地读取的方式，所以采用同步执行不是影响整个流程的。</p><h3 id="导入和导出方面">导入和导出方面</h3><p>CommonJS导出的变量是一个拷贝，如果是基本数据类型的话，导入和导出一方改变，另一方是看不到的。</p><p>ESModule导出和导入的变量指向的是同一块内存地址，由模块环境记录阶段处理，所以它们的修改是同步的可见的，而且对于导入的变量是不能进行修改的，如果是对象的话，还是能能修改内部属性值的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> ESModule </tag>
            
            <tag> 工程化 </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软链接和硬链接</title>
      <link href="/2025/03/18/%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
      <url>/2025/03/18/%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>硬链接和软链接是文件系统中链接文件的两种方式。</p><p>笼统来说，硬链接就是多个文件名对磁盘数据的共同引用，软链接就是存储一个文件路径，通过该路径可以获取磁盘数据，可以理解为快捷方式。</p><p>如果只是想简单了解，上述描述已经够用了，下面的就可以不用看了。</p><p>一下只是较为详细的说明下硬链接的引用和删除有关的内容，至于其他的跨文件系统/卷啥的，这里不会提及。</p><p>硬链接和软链接最初是出现在Unix中的。后来又Linux对其进行继承和完善，Windows系统中最初是不存在任何形式的链接方式的，后来NTFS文件系统的出现，Windows系统出现了硬链接和符号链接（软链接），但Windows和Linux在硬链接和软链接的实现上还是有所区别的。</p><h2 id="硬链接">硬链接</h2><p>硬链接只能链接文件，为了防止循环引用。</p><h3 id="Linux中的硬链接">Linux中的硬链接</h3><p>在Linux中的硬链接是多个文件共享一个inode（文件元数据标识符），指向相同的数据块，既通过该inode可以获取到磁盘数据。</p><p>（文件名是用户可见的标识符，而inode是文件系统内部的数据结构，我们是看不到的，用于存储文件元数据和数据块位置。每一个inode都是独一无二的。文件元数据既文件的描述信息，包括文件权限、类型、大小等，数据块位置既文件内容在磁盘上的物理存储位置。）</p><p>对于共享同一个inode的所以硬链接，它们的地位是平等的，删除任何一个，都不会影响到磁盘数据的消失，对于磁盘数据的删除，Linux的文件系统采用了链接计数的方式，既当有一个硬链接指向了磁盘数据对应的inode，其对应的链接计数就会+1，如果删除了一个硬链接，就删除了一个文件名对inode的引用，链接计数就会-1，当链接计数位0是，磁盘数据才会真正被删除。</p><p>由于硬链接是多个文件共享同一个inode，而inode存储着数据块位置，所以通过任意一个硬链接的文件名修改磁盘数据，通过其他硬链接访问到的数据都是被修改过的。</p><blockquote><p>语法<br>ln &lt;源文件&gt; &lt;硬链接名称&gt;</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file.txt hardlink.txt</span><br></pre></td></tr></table></figure><h3 id="Windows中的硬链接">Windows中的硬链接</h3><p>Windows中的硬链接是根据NTFS的特性，允许多个文件名可以指向同一个文件数据。和Linux的硬链接类似，只不过Windows中采用的MFT条目，而不是inode。</p><p>所以一个硬链接的删除是不会导致文件数据的删除的，因为还存在其他硬链接的指向，同时通过一个硬链接的修改其他获取到的也是修改过的数据。</p><blockquote><p>语法<br>mklink /H &lt;硬链接名称&gt; &lt;源文件&gt;</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /H hardlink.txt file.txt</span><br></pre></td></tr></table></figure><h2 id="软链接">软链接</h2><p>软链接允许链接目录，但仍会造成循环引用，需要手动处理。</p><p>Linux和Windows中的软链接是一个独立的文件存储着目标文件的路径字符串。当存储的目标文件被删除，此软链接失效，成为悬空链接，再次通过软链接访问系统会报错。</p><p>但Windows中的软链接需要管理员权限，而Linux中不需要。</p><blockquote><p>Linux创建软链接命令<br>ln -s &lt;源文件或目录&gt; &lt;软链接名称&gt;</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /path/to/file.txt symlink.txt</span><br></pre></td></tr></table></figure><blockquote><p>Windows创建软链接命令<br>mklink &lt;软链接名称&gt; &lt;源文件&gt;</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink symlink.txt file.txt</span><br></pre></td></tr></table></figure><h2 id="软链接和硬链接的区别">软链接和硬链接的区别</h2><p>Linux中，软链接不直接共享硬链接的inode，而是通过存储的目标文件路径间接访问，是路径的别名。而硬链接直接共享inode，是文件实体的多个别名。</p><p>Windows中，把上述的inode概念改为MFT条目就行了。中存储着目标文件的路径，类似于快捷方式，当访问软链接时，会从磁盘数据中找到目标路径，再通过目标路径获得源文件，再访问真实数据，当目标路径的源文件被删除，软链接的指向不存在，系统就会报错。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 文件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软链接 </tag>
            
            <tag> 硬链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化</title>
      <link href="/2025/03/17/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2025/03/17/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="模块化">模块化</h2><p>我们需要先知道为什么会出现模块化这个概念。</p><p>模块化是软件开发中<strong>复杂度的指数级增长</strong>和<strong>工程化的必然需求</strong>，其核心目的就是为了实现代码的复用、解耦、提高可维护性，通过模块化，可以实现不同人员同时开发不同的模块，最后将其进行整合，从而提高开发效率。</p><p>在最初的时候，JS是运行在浏览器中的，我们通过script标签引入外部js文件，或直接在script标签内部直接编写js代码，虽然它们在物理上是独立的，但它们在浏览器上运行时还是共享同一个全局作用域，这就导致了如果我们直接在外部js文件编写全局代码，再通过script引入，很可能会导致变量名覆盖，如果是let、const声明的变量，虽然不会覆盖，但通过报错来调整还是太过耗时和麻烦，对于外部JS文件，更多的还是引用别人编写好的工具文件，在没有文档的情况下，我们需要查看源码才知道暴露给我们的到底有哪些变量是我们可以使用的，同时，如果一个JS文件引用了其他的JS文件的变量，那么先把哪个JS文件引入也成为了一个问题，总结起来主要就是：</p><ul class="lvl-0"><li class="lvl-2"><p>可能会污染全局变量，或者变量名冲突。</p></li><li class="lvl-2"><p>使用起来麻烦，阅读性较差。</p></li><li class="lvl-2"><p>依赖管理容易失控。</p></li><li class="lvl-2"><p>引申起来还会有协同开发冲突等问题。</p></li></ul><p>虽然可以通过在外部js文件中使用立即执行函数的作用域来解决变量名冲突的问题，但如果我们想获取IIFE的返回值呢？仍然会存在上述问题。</p><p>随着Node.js这个JS运行时环境的出现，实现了通过JS开发服务端的应用，而服务端通常需要处理文件操作、数据库交互、网络通信的等复杂任务，这时候必须要分模块管理，而在这之前，ECMA并没有对JS的模块化有过明确的规定，Node.js引入了社区的CommonJS规范，并基于此规范实现了自己的模块系统。（CommonJS是一套由开发者社区提出的旨在解决JS在非浏览器环境（如服务端）中的模块化问题，强调同步加载模块，由于在服务端，资源一般都是本地文件，对于本地文件的读取速度还是很快的，所以同步就合适了）。</p><h2 id="CommonJS">CommonJS</h2><p>CommonJS中关于导入和导出的规范为<code>require</code>和<code>exports</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./test&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">name</span>) <span class="comment">// test</span></span><br></pre></td></tr></table></figure><p>由于通过<code>exports.属性名</code>一个一个导出太过麻烦，CommonJS又提供了<code>module.exports</code>统一导出的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node.js关于导出的内部原理其实就是导出一个对象，exports和通过require引入的自定义名称指向的就是一个对象，Node.js实现导出的时候，内部实现了一个操作<code>module.exports = exports</code>，所以在模块初始化的时候，module.exports和exports其实是等价的，但其实通过require引入的其实是moudle.exports指向的对象，所以如果使用<code>module.exports=&#123;&#125;</code>的方式导出，exports和module.exports指向的就不是同一个对象了，这是再对exports操作就没有意义了，因为导入和导出的是同一个对象，所以通过对对导入的变量操作和在导出处进行操作，数据修改是双向的。</p><p>经过上文描述，也就可以解释CommonJS的导出规范为<code>exports</code>，并不包括<code>module.exports</code>，但可以使用moudle.exports操作，因为它们在初始化时指向的是同一个对象，也简介是符合CommonJS规范的。</p><h2 id="AMD、CMD、UMD">AMD、CMD、UMD</h2><p>AMD、CMD、UMD都是在ESModule标准化之前使用的社区模块化规范，现在已经很少有人用了，但UMD目前还是一种兼容性的流行方案，这里对它们就不过多了解了，只介绍一下它们的特点吧。</p><p>关于AMD和CMD，它们都是应用于浏览器环境下的模块化方案，由于CommonJS强调同步加载模块，这对于浏览器来说是非常致命的，因为浏览器JS解析单线程会因为JS代码而发生阻塞，所以出现了AMD和CMD方案，它们可以实现异步加载模块，代表的库分别为<code>RequireJS</code>和<code>SeaJS</code>。</p><p>而UMD可以根据条件判断适配多种环境（AMD，CommonJS，全局变量），实现了跨环境支持，既同一套代码可运行在浏览器、Node.js和AMD中，适合开发兼容多种环境的JS库，也是保证兼容旧环境的最佳方案。代表库有<code>JQuery</code>和<code>Lodash早期版本</code>。</p><h2 id="ESModule">ESModule</h2><p>ESModule是ECMA发布的标准模块化规范，使用<code>import</code>和<code>export</code>关键字实现模块化。</p><p>ESModule实现导出：</p><p>方式一：具名导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或是进行统一导出</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">params</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这种方式可以在导出时其别名</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    name <span class="keyword">as</span> name1,</span><br><span class="line">    foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：默认导出，一个模块文件只能有一个默认导出<code>export default</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">params</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br></pre></td></tr></table></figure><p>ESModule实现导入：</p><p>如果只是在普通浏览器环境下，对于导入的文件名路径是要写全的，否则找不到，我们可能在工程化开始时见过不用写后缀名什么的，那是由于webpack或vite等打包工具进行了一些处理。</p><p>方式一：具名导入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名导入的可以为导入的变量起别名</span></span><br><span class="line"><span class="keyword">import</span> &#123;name <span class="keyword">as</span> name1&#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>方式二：默认导入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>方式三：导入整个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> test <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>特殊情况</p><p>情况一：默认导入可以和具名导入一起使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> name, &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>情况二：导入和导出结合使用。</p><p>场景：将各个模块的内容交由一个文件统一处理，仅适用于具名导入导出，如Pinia的模块化处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><p>注意一：关于ESModule的具名导入和导出，操作的<code>&#123;&#125;</code>并不是个对象，里面的变量并不是对象增强和结构，只是一种静态语法，并不能在里面写对象的字面量那种写法。</p><p>注意二：ESMdoule中的变量不能进行赋值操作的，不能进行双向更改，是一种单项数据流的模式。</p><p>上述的ESModule通过import的导入方式都是静态导入，是不可以放到逻辑代码中的，这与ESModule的解析流程有关，后面再说，如果想实现动态导入，可以使用<code>import()</code>函数，该函数返回的是一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>在工程化开发中，尤其是Vite中，我们还经常用到<code>import meta</code>，import.meta是一个给JS模块保禄特定上下文的对象。它包含了这个模块的信息，比如说这个模块的URL。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>) <span class="comment">// &#123;url: &#x27;http://127.0.0.1:5500/1.js&#x27;, resolve: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h3 id="ESModule的解析流程">ESModule的解析流程</h3><p><a href="/2025/03/20/ESModule%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/">ESModule解析流程</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 工程化 </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP相关知识点</title>
      <link href="/2025/03/14/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2025/03/14/HTTP%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是HTTP？">什么是HTTP？</h2><ul class="lvl-0"><li class="lvl-2"><p>HTTP（超文本传输协议：HyperText Transfer Protocol），是一种用于分布式、协作式和超媒体信息系统的应用层协议。</p></li><li class="lvl-2"><p>HTTP是万维网的数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收<strong>HTML</strong>页面的方法。</p></li><li class="lvl-2"><p>通过HTTP或HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p></li></ul><p>一次HTTP请求主要包括请求和响应，即由用户代理程序和源服务器之间的信息交流。</p><ul class="lvl-0"><li class="lvl-2"><p>用户代理程序（user agent）：我们通过某种方式（如浏览器）发送一个HTTP请求到服务器的指定端口上，我们称帮助我们发送请求的应用程序（客户端）成为用户代理程序。</p></li><li class="lvl-2"><p>源服务器：我们请求资源的服务器就是源服务器，源服务器一般存储我们所需要的资源（如HTML文件和图片）。</p></li></ul><p>由用户代理程序向源服务器发送请求携带的信息称为请求报文（request message）。由源服务器对用户代理程序的响应携带的信息称为响应报文（response message）。</p><h2 id="HTTP的版本">HTTP的版本</h2><p>HTTP的版本有0.9、1.0、1.1、2.0、3.0</p><p>它们之间的区别：</p><ul class="lvl-0"><li class="lvl-2"><p>HTTP/0.9</p><ul class="lvl-2"><li class="lvl-4">只支持GET请求获取文本数据， 主要仅仅是为了获取HTML文件。</li></ul></li><li class="lvl-2"><p>HTTP/1.0</p><ul class="lvl-2"><li class="lvl-4">支持GET、POST、HEAD等请求，支持请求头、响应头等，支持更多的种信息传递的数据类型，不再仅仅局限于文本数据。</li><li class="lvl-4">在1.0版本中每次请求都需要与服务器建立一个TCP链接，请求处理完后断开TCP链接，每次建立连接的开销较大。如果想进行持久连接，需要在请求头和响应头中都添加Connection: keep-alive。</li></ul></li><li class="lvl-2"><p>HTTP/1.1</p><ul class="lvl-2"><li class="lvl-4">此版本是使用最广泛的。</li><li class="lvl-4">增加了PUT、DELETE等请求方法</li><li class="lvl-4">默认采用持久连接（Connection: keep-alive），即一次TCP连接中请求处理完后可以选择保持一定事件的状态，放便下一次请求也可以使用，即多个请求可以共用一个TCP连接，但不同的WEB服务器的保持时间是不同的。</li></ul></li><li class="lvl-2"><p>HTTP/2.0</p><ul class="lvl-2"><li class="lvl-4">提升网络性能，依赖TCP优化，显著提升加载速度。</li></ul></li><li class="lvl-2"><p>HTTP/3.0</p><ul class="lvl-2"><li class="lvl-4">提升安全性，传输协议变为依赖基于UDP的QUIC协议，较少丢包率。</li><li class="lvl-4">但需要服务器和客户端同时支持。</li></ul></li></ul><h2 id="HTTP的请求方式">HTTP的请求方式</h2><p>在RFC（Request For Comments）中定义了一组请求方式：</p><ul class="lvl-0"><li class="lvl-2"><p>GET： GET方法请求一个指定资源的表现形式，一般用于获取数据。</p></li><li class="lvl-2"><p>HEAD：HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体。</p><ul class="lvl-2"><li class="lvl-4">比如在准备下载一个文件前，通过HEAD方法可以先获取文件的大小，再决定是否进行下载，在一定程度上可以优化下载。</li></ul></li><li class="lvl-2"><p>POST：POST方法用请求有效载荷（payload）替换目标资源的所有当前表示。</p><ul class="lvl-2"><li class="lvl-4">一般用于添加数据。</li></ul></li><li class="lvl-2"><p>PUT：PUT方法用请求有效载荷替换目标资源的所有当前表示。</p><ul class="lvl-2"><li class="lvl-4">一般用于修改数据整体。</li></ul></li><li class="lvl-2"><p>DELETE：DELETE方法一般用于删除指定的资源。</p></li><li class="lvl-2"><p>PATCH： PATCH方法一般用于与资源部分修改。</p></li><li class="lvl-2"><p>CONNECT：CONNECT方法建立一个到目标资源标识的服务器的隧道，通常用在代理服务器，网页开发很少用到。</p></li><li class="lvl-2"><p>TRACE：TRACE方法沿着到目标资源的路径执行一个消息的环回测试。</p></li></ul><h2 id="HTTP常见的请求头">HTTP常见的请求头</h2><ul class="lvl-0"><li class="lvl-2"><p>Content-type： type是这次请求携带的数据的类型，服务器可以根据其判断怎样解析数据。</p><ul class="lvl-2"><li class="lvl-4">application/x-www-form-urlencoded：表示数据被编码成以’&amp;‘分割的键值队，同时以’='分割键和值。即通过form表单提交的数据。</li><li class="lvl-4">application/json：表示传输的数据是一个JSON类型。</li><li class="lvl-4">application/xml：表示传输的数据是一个XML类型。</li><li class="lvl-4">text/plain：表示传输的数据是文本类型。</li><li class="lvl-4">multipart/form-data：表示是上传文件。</li></ul></li><li class="lvl-2"><p>Content-length：文件的大小长度。</p><ul class="lvl-2"><li class="lvl-4">前面提到过HEAD请求是没有响应体的，他的一个使用场景就是可以先获取文件大小Content-length，再决定是否进行下载，从而优化下载。</li></ul></li><li class="lvl-2"><p>Connection: keep-alive</p><ul class="lvl-2"><li class="lvl-4">http是基于TCP协议的，但是在1.1之前每一次请求都需要经历TCP的连接和断开，这样频繁的连接和断开时非常耗性能的。</li><li class="lvl-4">在1.0时期，可以手动进行持久连接，需要在请求头和响应头中都添加Connection: keep-live，当客户端再次发送请求时，就会使用同一个连接，直到一方断开连接。</li><li class="lvl-4">在1.1版本中，所有连接默认是Connection: keep-alive的，不同的Web服务器的保持时间是不同的。但可以通过<code>Keep-Alive: timeout=xxx</code>进行单独设置。</li></ul></li><li class="lvl-2"><p>accept-encoding: 告知服务器，客户端支持的压缩格式。</p></li><li class="lvl-2"><p>accept: 告知服务器，客户端可接受文件的格式类型。</p></li><li class="lvl-2"><p>user-agent: 客户端相关的信息。</p></li></ul><p>关于accept和accept-encoding，是客户端传递给服务器可以接收的文件格式和压缩格式，服务器会先根据Accept选择内容格式，再根据Accept-Encoding决定是否压缩，最终返回格式正确且经过压缩（若支持）的响应。</p><h2 id="HTTP的常见的响应状态码">HTTP的常见的响应状态码</h2><p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status</a></p><ul class="lvl-0"><li class="lvl-2"><p>200（OK）：客户端请求成功。</p></li><li class="lvl-2"><p>201（Created）：POST请求，创建新的资源成功。</p></li><li class="lvl-2"><p>301（Moved Permanently）：请求资源的URL已经修改，响应中会给出新的URL，浏览器会根据给出的URL重定向到新的URL。</p></li><li class="lvl-2"><p>400（Bad Request）：客户端的错误，服务器无法处理或者不进行处理。</p></li><li class="lvl-2"><p>401（Unauthorized）：未授权的错误，必须携带请求的身份信息。</p></li><li class="lvl-2"><p>403（Forbidden）：客户端没有访问权限，被拒绝。</p></li><li class="lvl-2"><p>404（Not Found）：服务器找不到请求的资源。</p></li><li class="lvl-2"><p>500（Internal Server Error）：服务器遇到了不知道如何处理的问题。</p></li><li class="lvl-2"><p>503（Serive Unavailable）：服务器不可用，可能出于维护或重载状态，暂时无法访问。</p></li></ul><p>在开发中，一般都会采用返回200状态码，但会自定义响应信息，统一客户端处理逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写实现事件总线</title>
      <link href="/2025/03/13/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
      <url>/2025/03/13/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>事件总线是发布-订阅模式的实现，本质上来说就是对同一个对象的引入操作，保证全局通信中介的唯一性，核心目的是解耦组件，由事件总线内部维护事件与函数的映射关系，从而达到执行一致性。</p><h2 id="基本实现">基本实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">eventMap</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">eventName, eventFn</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> eventFns = <span class="variable language_">this</span>.<span class="property">eventMap</span>[eventName]</span><br><span class="line">        <span class="keyword">if</span> (!eventFns) &#123;</span><br><span class="line">            eventFns = []</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">eventMap</span>[eventName] = eventFns</span><br><span class="line">        &#125;</span><br><span class="line">        eventFns.<span class="title function_">push</span>(eventFn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">eventName, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> eventFns = <span class="variable language_">this</span>.<span class="property">eventMap</span>[eventName]</span><br><span class="line">        <span class="keyword">if</span> (!eventFns) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> eventFn <span class="keyword">of</span> eventFns) &#123;</span><br><span class="line">            <span class="title function_">eventFn</span>(...args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">off</span>(<span class="params">eventName, eventFn</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> eventFns = <span class="variable language_">this</span>.<span class="property">eventMap</span>[eventName]</span><br><span class="line">        <span class="keyword">if</span> (!eventFns) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; eventFns.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventFns[i] === eventFn) &#123;</span><br><span class="line">                eventFns.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">eventMap</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶：实现批量订阅和通配符情况">进阶：实现批量订阅和通配符情况</h2><p>思路：</p><ul class="lvl-0"><li class="lvl-2"><p>创建三个对象</p><ul class="lvl-2"><li class="lvl-4">一个对象负责精确事件与函数的联系，因为一个事件可能关联多个函数，所以采用Map结构，将事件名作为键，为了方便对关联的函数进行操作，所以用Set结构存储事件函数作为值。</li><li class="lvl-4">一个负责存储通配符情况下对应的规则与处理函数，方便结构操作，采用Set存储对象。</li><li class="lvl-4">一个负责进行对批量订阅的处理，为了解决多个订阅与单个订阅绑定相同函数的冲突，用Map数据结构处理，且此容器仅仅是为了中间存储关系，实际存储还是在精确事件中，为了方便内存管理，采用WeakMap结构。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">listeners</span> = <span class="keyword">new</span> <span class="title class_">Map</span>() <span class="comment">// 精确事件</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">wildcards</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 通配符事件</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">batchHandlers</span> = <span class="keyword">new</span> <span class="title class_">WeakMap</span>() <span class="comment">// 批量订阅的映射</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅事件（支持字符串、数组、通配符）</span></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">events, handler</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断传入的是否是事件是否数组，如果只是一个字符串，则将其转为数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> events === <span class="string">&#x27;string&#x27;</span>) events = [events]</span><br><span class="line">        <span class="comment">// 遍历事件数组</span></span><br><span class="line">        events.<span class="title function_">forEach</span>(<span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_registerEvent</span>(event, handler))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ons</span>(<span class="params">events, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">wrapper</span> = (<span class="params">...args</span>) =&gt; <span class="title function_">handler</span>(...args)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">batchHandlers</span>.<span class="title function_">set</span>(handler, wrapper)</span><br><span class="line">        events.<span class="title function_">forEach</span>(<span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_registerEvent</span>(event, wrapper))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">        <span class="comment">// 精确匹配</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">has</span>(event)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">get</span>(event).<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> <span class="title function_">handler</span>(...args))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通配符匹配</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">wildcards</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; pattern, handler &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.<span class="title function_">test</span>(event)) <span class="title function_">handler</span>(...args)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">off</span>(<span class="params">event, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> handlers = <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">get</span>(event)</span><br><span class="line">        <span class="keyword">if</span> (handlers) handlers.<span class="title function_">delete</span>(handler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">offs</span>(<span class="params">events, handler</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> wrapper = <span class="variable language_">this</span>.<span class="property">batchHandlers</span>.<span class="title function_">get</span>(handler)</span><br><span class="line">        <span class="keyword">if</span> (!wrapper) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        events.<span class="title function_">forEach</span>(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> handlers = <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">get</span>(event)</span><br><span class="line">            <span class="keyword">if</span> (handlers) handlers.<span class="title function_">delete</span>(wrapper)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">batchHandlers</span>.<span class="title function_">delete</span>(handler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">_registerEvent</span>(<span class="params">event, handler</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否为通配符匹配</span></span><br><span class="line">        <span class="keyword">if</span> (event.<span class="title function_">includes</span>(<span class="string">&#x27;*&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">wildcards</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">                <span class="comment">// 制定通配符匹配规则</span></span><br><span class="line">                <span class="comment">// 如 event = &#x27;test.*&#x27; 将其转换为正则模式 =&gt; /^test..*$/</span></span><br><span class="line">                <span class="comment">// 但这样会存在问题，如果是test1，也符合/^test..*$/，所以我们可以对其进行优化变为 =&gt; /^test\..*$/</span></span><br><span class="line">                <span class="comment">// pattern: new RegExp(`^$&#123;event.replace(/\*/g, &#x27;.*&#x27;)&#125;$`)</span></span><br><span class="line">                <span class="attr">pattern</span>: event.<span class="title function_">includes</span>(<span class="string">&#x27;.&#x27;</span>) ? <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^<span class="subst">$&#123;event.replace(/\.\*/g, <span class="string">&#x27;\\..*&#x27;</span>)&#125;</span>$`</span>) : <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`^<span class="subst">$&#123;event.replace(/\*/g, <span class="string">&#x27;.*&#x27;</span>)&#125;</span>$`</span>),</span><br><span class="line">                handler</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不包含通配符，将其以Set形式加入到精确事件集合中</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">has</span>(event)) <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">set</span>(event, <span class="keyword">new</span> <span class="title class_">Set</span>())</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">get</span>(event).<span class="title function_">add</span>(handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 事件总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写防抖、节流函数</title>
      <link href="/2025/03/11/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/11/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>防抖和节流的提出是为了解决由于某些频繁事情的发生导致对系统性能的损耗。</p><h2 id="手写防抖函数">手写防抖函数</h2><details open>    <summary>        <span>查看</span>    </summary><p>对于防抖的实现过程为：</p><ul class="lvl-0"><li class="lvl-2"><p>当触发一个事件时，相应的函数并不会立刻执行，而是会等待一定时间再执行。</p></li><li class="lvl-2"><p>当频繁触发一个事件的，相应的函数将会被频繁的推迟。</p></li><li class="lvl-2"><p>当停止触发该事件，且在等待时间内，不再触发该事件，其相应的函数才会<strong>执行一次</strong>。</p></li></ul><p>在JS中防抖的应用场景包括：</p><ul class="lvl-0"><li class="lvl-2"><p>对输入框的的输入监听。</p></li><li class="lvl-2"><p>对DOM（按钮等）的频繁操作。</p></li><li class="lvl-2"><p>对浏览器滚动条的事件监听。</p></li><li class="lvl-2"><p>对浏览器缩放resize的监听。</p></li><li class="lvl-2"><p>…</p></li></ul><h3 id="防抖函数的基础代码实现">防抖函数的基础代码实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 核心代码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">_debounce</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">fn</span>()</span></span><br><span class="line"><span class="language-javascript">            &#125;, delay)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> _debounce</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> inputEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    inputEl.<span class="property">oninput</span> = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(inputEl.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来对其进行优化加入更多要求：</p><h3 id="优化参数和this指向">优化参数和this指向</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于实现防抖的是_debounce函数，所以传递的参数都在_debounce上</span></span><br><span class="line"><span class="comment">// 且根据箭头函数不存在this，根据作用链查找的特性，将定时器的回调函数改为箭头函数就能实现传递参数和this指向正确绑定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_debounce</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化取消操作（增加取消功能）">优化取消操作（增加取消功能）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将定时器挂载在返回的防抖函数对象上，用户可以通过调用该函数的cancel方法来清除定时器停止调用防抖对应的函数</span></span><br><span class="line"> _debounce.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="comment">// 保持状态一致性，避免冗余的无意义操作，因为虽然通过clearTimeout清除了定时器，但timer仍保留对应的定时器ID，设置为null既可以保证避免下一次进行冗余的判断操作，也有益于垃圾回收的回收。</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化立即执行效果（第一次立即执行）">优化立即执行效果（第一次立即执行）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为工具函数添加了一个参数，用该参数判断是否要进行第一次立即执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay, immediate = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 这里多定义一个变量而不直接操作immediate是为了保持封装性，避免了直接修改外部的状态，也避免了可能的错误</span></span><br><span class="line">    <span class="keyword">let</span> isInvoke = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_debounce</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isInvoke &amp;&amp; immediate) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            isInvoke = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            isInvoke = <span class="literal">false</span></span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">    _debounce.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _debounce</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.input&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> debounceFn = <span class="title function_">debounce</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">inputEl.<span class="property">oninput</span> = debounceFn</span><br><span class="line">btnEl.<span class="property">onclick</span> = debounceFn.<span class="property">cancel</span></span><br></pre></td></tr></table></figure><h3 id="优化防抖返回值">优化防抖返回值</h3><p>对于获取其返回值有两种方法，第一种为传入一个回调函数，通过回调函数获取返回值，第二种方式则是通过使用Promise来获取返回值。这里展示第二种方案。</p><p>如果有其他定制化操作，也可自行添加，但核心也就是下面这样了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay, immediate = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> isInvoke = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_debounce</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isInvoke &amp;&amp; immediate) &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">resolve</span>(result)</span><br><span class="line">                    isInvoke = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">resolve</span>(result)</span><br><span class="line">                    isInvoke = <span class="literal">false</span></span><br><span class="line">                    timer = <span class="literal">null</span></span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    _debounce.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _debounce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="手写节流函数">手写节流函数</h2><details open>    <summary>        <span>查看</span>    </summary><p>对于节流的实现过程为：</p><ul class="lvl-0"><li class="lvl-2"><p>当事件触发时，会执行这个事件的响应函数。</p></li><li class="lvl-2"><p>如果这个事件被频繁出发，那么节流函数会按照一定的频率来执行函数。</p></li><li class="lvl-2"><p>不论在这个期间触发了多少次这个事件，执行函数的频率总是固定的。</p></li></ul><p>对于节流的引用场景包括：</p><ul class="lvl-0"><li class="lvl-2"><p>监听页面滚动事件。</p></li><li class="lvl-2"><p>鼠标移动事件。</p></li><li class="lvl-2"><p>用户频繁点击按钮操作。</p></li><li class="lvl-2"><p>游戏中的一些设计（如飞机的子弹发射）。</p></li><li class="lvl-2"><p>…</p></li></ul><h3 id="节流函数的基础代码实现">节流函数的基础代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> satrtTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_throttle</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">let</span> waitTime = delay - (nowTime - satrtTime)</span><br><span class="line">        <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">fn</span>()</span><br><span class="line">            satrtTime = nowTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _throttle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.input&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btnEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> throttleFn = <span class="title function_">throttle</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(inputEl.<span class="property">value</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">inputEl.<span class="property">oninput</span> = throttleFn</span><br></pre></td></tr></table></figure><h3 id="优化参数、this指向、节流第一次是否可以执行和最后一次可以执行">优化参数、this指向、节流第一次是否可以执行和最后一次可以执行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval, &#123; leading = <span class="literal">true</span>, trailing = <span class="literal">false</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_throttle</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (!leading &amp;&amp; startTime === <span class="number">0</span>) &#123;</span><br><span class="line">            startTime = nowTime</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> waitTime = interval - (nowTime - startTime)</span><br><span class="line">        <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            startTime = nowTime</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断最后一次是否可以执行</span></span><br><span class="line">        <span class="keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, waitTime)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _throttle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加取消功能（取消最后一次执行）">添加取消功能（取消最后一次执行）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_throttle.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    startTime = <span class="number">0</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流返回值">节流返回值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval, &#123; leading = <span class="literal">false</span>, trailing = <span class="literal">true</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_throttle</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">                <span class="keyword">if</span> (!leading &amp;&amp; startTime === <span class="number">0</span>) &#123;</span><br><span class="line">                    startTime = nowTime</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> waitTime = interval - (nowTime - startTime)</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">                    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">resolve</span>(result)</span><br><span class="line">                    startTime = nowTime</span><br><span class="line">                    timer = <span class="literal">null</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><br><span class="line">                    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                        <span class="title function_">resolve</span>(result)</span><br><span class="line">                        startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">                        timer = <span class="literal">null</span></span><br><span class="line">                    &#125;, waitTime)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _throttle.<span class="property">cancel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        startTime = <span class="number">0</span></span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _throttle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
          <category> 手写函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 手写函数 </tag>
            
            <tag> 防抖 </tag>
            
            <tag> 节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/2025/03/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/03/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>首先我们需要先了解进程和线程的概念：</p><ul class="lvl-0"><li class="lvl-2">当我们启动一个程序时，系统会为该程序创建一个进程，并在内存中开辟一块空间用于处理该程序。</li><li class="lvl-2">线程是操作系统能够运行运算调度的最小单位，通常情况下它被包含在进程中。</li><li class="lvl-2">进程中通常会创建许多线程共同处理程序的运行。</li></ul><p>在浏览器中，每一个标签页就是一个进程，这样可以保证，一个页面的崩溃不会影响到其他页面的正常运作。</p><p>其中处理JS的只有一个线程，成为渲染主线程，由于只有一个线程处理JS代码，所以当其中存在耗时操作时，会一直等待此操作完成才能继续向下执行，造成了阻塞，所以出现了事件循环用来解决这种情况。</p><p>当我们进行耗时操作（如计时器，异步请求等，我们称之为任务）会交予其他线程进行处理，不会影响渲染主线程的继续执行，如果在JS代码执行过程中，存在任务完成了，会将其放在任务队列中，任务队列分为微队列和宏队列，（有些浏览器可能会对宏队列进行进一步的队列细分，它们同样存在不同的优先级）。</p><p>事件循环的依次迭代为：宏任务 -&gt; 微任务 -&gt; 渲染 -&gt; 循环。</p><p>最开始的JS执行是执行script中的代码，可以将其看为宏任务，其中可能会产生其他宏任务或微任务，当当前宏任务执行完毕，会将微任务队列中的任务清空，如有必要，会进行UI渲染操作，然后进入下一次循环，以此往复。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 原理 </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator-Generator</title>
      <link href="/2025/03/07/Iterator-Generator/"/>
      <url>/2025/03/07/Iterator-Generator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Iterator（迭代器）">Iterator（迭代器）</h2><details open>    <summary>        <span>查看</span>    </summary><p>迭代器：使用户在容器对象（如数组）上遍访的对象。即迭代器是帮助我们对某个数据结构进行遍历的对象。</p><p>在JS中，迭代器是一个具体的对象，我们可以手动实现，但这个对象需要符合迭代器协议（iterator protocol）</p><ul class="lvl-0"><li class="lvl-2"><p>迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式。</p></li><li class="lvl-2"><p>在JS中这个标准就是一个特定的next方法。</p></li></ul><p>next方法有如下要求：</p><ul class="lvl-0"><li class="lvl-2"><p>一个无参数或着一个参数的函数，返回一个应当拥有以下两个属性的对象：</p><ul class="lvl-2"><li class="lvl-4">done(boolean)<ul class="lvl-4"><li class="lvl-6">如果迭代器可以产生序列中的下一个值，则为false。</li><li class="lvl-6">如果迭代器已将序列迭代完毕，则为true。这种情况下，value是可选的，如果它依然存在，即为迭代结束后的默认返回值。</li></ul></li><li class="lvl-4">value<ul class="lvl-4"><li class="lvl-6">迭代器返回的任何JavaScript值，done为true时可省略。</li></ul></li></ul></li></ul><p>实现迭代器，以获取对象的键（包含Symbol）为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObjIterator</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= keys.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: keys[index++] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">222</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objIterator = <span class="title function_">createObjIterator</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;done: false, value: &#x27;name&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;done: false, value: &#x27;age&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;done: false, value: Symbol()&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;done: true&#125;</span></span><br></pre></td></tr></table></figure></details><h2 id="可迭代对象">可迭代对象</h2><details open>    <summary>        <span>查看</span>    </summary><p>可迭代对象和迭代器是两个不同的概念，前面我们可以通过迭代器对对象进行遍历操作，但需遍历对象和迭代器时分离开的，如果我们把迭代器和对象结合在一起，就叫做可迭代对象。</p><p>但将迭代器和可迭代对象结合起来成为可迭代对象，可是有一定规范的：</p><ul class="lvl-0"><li class="lvl-2"><p>这个对象要实现迭代器协议（iterator protocol）。</p></li><li class="lvl-2"><p>这个对象必须实现<code>@@iterator</code>方法，在代码层面是对象要实现<code>[Symbol.iterator]</code>属性。</p></li></ul><p>可迭代对象是可以通过for of 循环进行遍历操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">222</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: keys[index++] &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// age</span></span><br><span class="line"><span class="comment">// Symbol()</span></span><br><span class="line"><span class="comment">// Symbol(Symbol.iterator) 由于 Reflect.ownKeys()是Object.getOwnPropertyNames()和Object.getOwnPropertySymbols()的合集，所以Symbol()也会被遍历到</span></span><br></pre></td></tr></table></figure><p>可迭代对象的使用场景：</p><ul class="lvl-0"><li class="lvl-2"><p>JavaScript中语法：for …of、展开语法（spread syntax）、yield*（后面讲）、解构赋值（Destructuring_assignment）。</p></li><li class="lvl-2"><p>创建一些对象时：<code>new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable])</code>。</p></li><li class="lvl-2"><p>一些方法的调用：Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable)。</p></li></ul><p>补充：</p><p>迭代器中其实还可以做一个操作，就是监听容器对象的中断操作：</p><ul class="lvl-0"><li class="lvl-2"><p>比如遍历的过程中通过break、return、throw中断了循环操作。</p></li></ul><p>如果我们想实现这个操作，就需要在迭代器对象中加入return方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">222</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: keys[index++] &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">return</span>() &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Generator（生成器）">Generator（生成器）</h2><details open>    <summary>        <span>查看</span>    </summary><p>生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。</p><p>平时我们写的函数终止条件要么是return，要么是发生了异常，生成器中又提供了yield关键字来控制函数的执行。</p><p>生成器函数也是一个函数，但与普通的函数有一些区别：</p><ul class="lvl-0"><li class="lvl-2"><p>生成器函数需要在function后加上一个<code>*</code></p></li><li class="lvl-2"><p>生成器函数可以通过yield关键字控制函数的执行流程。</p></li><li class="lvl-2"><p>生成器函数的返回值是一个Generator对象。</p><ul class="lvl-2"><li class="lvl-4">生成器事实上是一种特殊的迭代器。</li><li class="lvl-4">Instead, they return a special type of iterator, called a Generator.</li></ul></li></ul><p>生成器实例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">y1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, y1) <span class="comment">// 1 111</span></span><br><span class="line">    <span class="keyword">const</span> y2 = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, y2) <span class="comment">// 2 222</span></span><br><span class="line">    <span class="keyword">const</span> y3 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, y3) <span class="comment">// 3 333</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>(<span class="string">&#x27;222&#x27;</span>)) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>(<span class="string">&#x27;333&#x27;</span>)) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>生成器函数中的代码并不会默认执行，但可以通过其返回的生成器调用next的方法再根据yield关键字控制代码的执行，一次next的调用运行到一个yield关键字的位置，并返回一个对象，对象为{value: yield关键字后面的值，done: false}，当next的调用返回的done为true时，表示函数执行完毕，此时返回的对象为{value: undefined, done: true}。也可以通过next方法向构造器函数中传值，通过yield关键字获取到传进来的值，但第一次next的传值调用是无法被接收到的。</p><p>对于生成器，我们可以直接调用其return和throw方法来控制函数的提前结束和抛出异常。</p><figure class="highlight js"><figcaption><span>提前结束</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">y1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, y1) <span class="comment">// 1 111</span></span><br><span class="line">    <span class="keyword">const</span> y2 = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, y2)</span><br><span class="line">    <span class="keyword">const</span> y3 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, y3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="keyword">return</span>(<span class="string">&#x27;222&#x27;</span>)) <span class="comment">// &#123;value: &#x27;222&#x27;, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>(<span class="string">&#x27;333&#x27;</span>)) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>以上代码可以看出，生成器函数的调用会在生成器的return方法调用时提前结束，即使后面还有代码没执行完。return方法还会返回一个对象，对象为{value: return方法传进来的值，done: true}，后面即使在调用next方法，结果也都是{value: undefined，done: true}了。</p><figure class="highlight js"><figcaption><span>抛出异常</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">y1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, y1) <span class="comment">// 1 111</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> y2 = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, y2)</span><br><span class="line">        <span class="keyword">const</span> y3 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, y3)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="keyword">throw</span>(<span class="string">&#x27;执行异常&#x27;</span>)) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>(<span class="string">&#x27;333&#x27;</span>)) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>以上代码可以看出，生成器函数的调用会在生成器的throw方法调用时提前结束，并抛出异常，即使后面还有代码没执行完。throw方法还会返回一个对象，对象为{value: undefined，done: true}，后面即使在调用next方法，结果也都是{value: undefined，done: true}了。</p><p>既然生成器是一种特殊的迭代器，那么我们可以用生成器替代迭代器，那上文的代码为例，用生成器重写后为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">createObjIterator</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">        <span class="keyword">yield</span> key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">222</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objIterator = <span class="title function_">createObjIterator</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: &#x27;name&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: &#x27;age&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: Symbol(), done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objIterator.<span class="title function_">next</span>()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>用生成器实现可迭代对象的<code>@@iterator</code>方法，只需要在<code>[Symbol.iterator]()&#123;&#125;</code>开头加一个<code>*</code>，那么它就是一个生成器方法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">222</span>,</span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">            <span class="keyword">yield</span> key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述我们实现迭代器或生成器内部获取元素的时候都是用的for of 循环，for of可以用于可迭代对象，如果内部循环的是一个可迭代对象的话，我们可以将操作简写以下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">222</span>,</span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">yield</span>* keys</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Generator解决异步回调地狱问题">Generator解决异步回调地狱问题</h2><details open>    <summary>        <span>查看</span>    </summary><p>场景：当我们发送一个异步请求，需要根据该请求结果发送另一个请求，另一个请求的结果时其他请求所必需的，依次类推，给出回调地狱的代码，尝试对其优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">requestData</span>(<span class="string">&#x27;111&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">requestData</span>(res1).<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">requestData</span>(res2).<span class="title function_">then</span>(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过返回Promise对其进行优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">requestData</span>(<span class="string">&#x27;111&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">requestData</span>(res1)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">requestData</span>(res2)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码看起来好多了，但阅读性其实还是比较差的，接下来我们用生成器进行优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">yield</span> <span class="title function_">requestData</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> <span class="title function_">requestData</span>(res1)</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">yield</span> <span class="title function_">requestData</span>(res2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述封装请求的生成器函数看起来挺清爽的，但是调用起来就麻烦了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="title function_">getData</span>()</span><br><span class="line"></span><br><span class="line">generator.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res1</span> =&gt;</span> &#123;</span><br><span class="line">    generator.<span class="title function_">next</span>(res1).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">        generator.<span class="title function_">next</span>(res2).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res3</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是这样又变成了上述用Promise解决时的问题，但好在生成器的每次next调用都会返回一个对象，对象中有一个属性done可以判断生成器函数中的代码是否执行完毕，所以我们可以对其进行封装优化。</p><p>封装自动执行generator函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">yield</span> <span class="title function_">requestData</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> <span class="title function_">requestData</span>(res1)</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">yield</span> <span class="title function_">requestData</span>(res2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execGenerator</span>(<span class="params">genFn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> generator = <span class="title function_">genFn</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = generator.<span class="title function_">next</span>(res)</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span></span><br><span class="line">        result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">exec</span>(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">exec</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> Iterator </tag>
            
            <tag> Generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy-Reflect使用</title>
      <link href="/2025/03/06/Proxy-Reflect%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/03/06/Proxy-Reflect%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Proxy">Proxy</h2><details open>    <summary>        <span>查看</span>    </summary><p>需要：如果存在一个对象，我们需要去监听这个对象中的属性被设置或获取的过程，应该如何操作？</p><p>在ES6之前，我们可以通过<code>Object.defineProperty()</code>的存取属性描述符来对属性的操作进行监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = obj[key]</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>的值为<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>的值发生了改变：<span class="subst">$&#123;value&#125;</span> =&gt; <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">            value = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对属性进行赋值操作时，执行其对应set访问器</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;obj1&#x27;</span>  <span class="comment">// name的值发生了改变：obj =&gt; obj1</span></span><br><span class="line"><span class="comment">// 对属性进行调用，执行其对应get访问器</span></span><br><span class="line">obj.<span class="property">name</span>  <span class="comment">// name的值为obj1</span></span><br></pre></td></tr></table></figure><p>但这样是存在缺点的：</p><ul class="lvl-0"><li class="lvl-2"><p>Object.defineProperty设计的初衷并不是去为了监听对象的所有属性的，我们在定义某些属性的时候，初衷只是为了定义普通的属性，只是因为其存在访问器这种特点，就强行用属性描述符去操作了。</p></li><li class="lvl-2"><p>Object.defineProperty只能监听属性的存取，但如果我们想监听更加丰富的操作，比如新增、删除属性等，那么Object.defineProperty是无能为力的。</p></li></ul><p>ES6中，新增了Proxy类，用于帮助我们创建一个代理对象，从而对对象操作进行监听。</p><p>Proxy语法</p><blockquote><p>const p = new Proxy(target, handler)<br>target：要创建代理的对象<br>handler: 是定义了代理的自定义行为的对象</p></blockquote><p>如果我们想要侦听某些具体的操作，那么可以在handler中添加对应的捕获器。</p><p>对于上面的案例，通过Proxy实现为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// target为目标对象，key为修改的属性名</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>的值为<span class="subst">$&#123;target[key]&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// target为目标对象，key为修改的属性名，value为待修改的值</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>的值发生了改变：<span class="subst">$&#123;target[key]&#125;</span> =&gt; <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        target[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过代理对象对属性进行赋值操作时，执行其set捕获器，并对源对象的进行对应修改，name的值发生了改变：obj =&gt; obj1</span></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;obj1&#x27;</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// obj1</span></span><br><span class="line"><span class="comment">// 通过代理对象获取其属性时，执行器get捕获器，name的值为obj1</span></span><br><span class="line">proxy.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>Proxy所有捕获器</p><img data-src="/2025/03/06/Proxy-Reflect%E4%BD%BF%E7%94%A8/Proxy%E6%8D%95%E8%8E%B7%E5%99%A8.png" class="" title="Proxy捕获器"><p>这里说一下construct捕获器和apply捕获器，这两个捕获器是应用于函数对象的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(foo, &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(argumentsList, newTarget)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...argumentsList)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(target, thisArg, argumentsList)</span><br><span class="line">        <span class="keyword">return</span> target.<span class="title function_">apply</span>(thisArg, argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="string">&#x27;111&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><blockquote><p>handler.construct(target, argumentsList, newTarget)<br>参数：<br>target：被代理的函数<br>argumentsList：创建实例时传入的参数<br>newTarget：最初被调用的构造函数，上述为proxy对象</p><p>apply(target, thisArg, argumentsList)<br>apply时调用函数的捕获器，包括普通调用，apply/call调用参数：<br>target：被代理的函数<br>thisArg：调用函数时传入的this<br>argumentsList：调用函数时传入的参数</p></blockquote></details><h2 id="Reflect">Reflect</h2><details open>    <summary>        <span>查看</span>    </summary><p>Reflet是ES6新增的一个API，它提供了许多操作对象的方法，Object的方法基本都可以通过Reflect实现，用法和Object相同，但是Reflect的方法更简洁，并且更符合语义。</p><p>比如Reflect.getPrototypeOf(target)类似于 Object.getPrototypeOf()，Reflect.defineProperty(target, propertyKey, attributes)类似于Object.defineProperty()。</p><p>那么我们可能会有一些疑惑，既然Reflect可以做的，Object都可以做，为什么还要有Reflect呢？</p><ul class="lvl-0"><li class="lvl-2"><p>由于在早期的ECMA规范中没有考虑到这种对对象本身的操作如何设计更加规范，所以将相应API都放在了Object上面。</p></li><li class="lvl-2"><p>但是Object的API设计存在一些问题，一些是静态方法（如<code>Object.keys()、Object.defineProperty()</code>），一些又是实例方法<code>obj.hasOwnProperty</code>，这样调用方法不一致的问题，增大了学习者的心理负担。</p></li><li class="lvl-2"><p>Object的API的错误处理不统一，某些方法如<code>Object.defineProperty()</code>是通过抛出异常处理错误，而某些方法是给出返回值，如<code>Object.freeze()</code>当传入一个原始值时，如传入一个数字，并不会抛出错误，而是将其转换为对应的包装类，然后将其返回。</p></li><li class="lvl-2"><p>对this绑定存在隐患，Object的实例方法依赖this绑定，若方法被错误调用，如提取后单独使用，会导致意外行为。</p></li><li class="lvl-2"><p>对于Object的实例方法易被重写。</p></li><li class="lvl-2"><p>…</p></li></ul><p>总的来说，对于Object的API并没有进行统一的规范，操作混乱，容易出错。</p><p>Reflect的出现可以说是Object的操作增强。</p><ul class="lvl-0"><li class="lvl-2"><p>统一的操作函数，Reflect将所有对象的操作静态化，解决了Object的一会静态，一会实例方法的API设计规范问题。</p></li><li class="lvl-2"><p>合理返回值设计，对于不合法的调用，Reflect会返回true/false，解决了Object的返回值不统一的问题。</p></li><li class="lvl-2"><p>填补了空白功能，如Object要获取对象的键是，需要通过<code>obj.getOwnPropertyNames()</code>和<code>obj.getOwnPropertySymbols()</code>，但Reflect提供了<code>Reflect.ownKeys</code>是上述两种方法的组合。</p></li></ul><p>Reflect的常用方法：</p><img data-src="/2025/03/06/Proxy-Reflect%E4%BD%BF%E7%94%A8/Reflect%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" class="" title="Reflect的常用方法"></details><h2 id="Proxy和Reflect结合使用">Proxy和Reflect结合使用</h2><details open>    <summary>        <span>查看</span>    </summary><p>上文我们说了Reflect和Object的区别，Reflect的出现标准化了对象的底层操作（提供一致的方法接口）和弥补了Object方法的不足（如错误处理和函数式风格）。</p><p>但Reflect还有一个应用场景，就是与Proxy结合使用（支持Proxy的陷阱（捕获器）实现）。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>以上代码get捕获器只触发了一次，即只触发了对name属性的获取，但按理来说，对此对象的所有属性的获取都应该触发get捕获器，但只触发获取name的访问器，这是由于this指向的问题，我们在get捕获器中通过操作源对象的方式获取属性值，导致this并没有指向代理对象，这破坏了代理的封装性。</p><p>在看一个代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">        target[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;222&#x27;</span></span><br></pre></td></tr></table></figure><p>以上代码set捕获器只触发了一次，和上述的get捕获器一样，都是捕获器中直接操作源对象的结果，破坏了代理的封装性。</p><p>其实Proxy的get/set捕获器中还有一个<code>receiver</code>参数，receiver指向当前代理对象，而Reflect的get/set方法也可以接受一个receiver参数，通过receiver可以保证proxy的陷阱实现的正确性。</p><p>所以可以对以上代码进行修改，将Proxy和Reflect结合使用，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;222&#x27;</span></span><br><span class="line">proxy.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>补充：</p><blockquote><p>在ES5我们实现继承时有借用构造函数思想，即改变this指向，实现对父类构造函数的调用。<br>Reflect提供了相同操作的方法：Reflect.construct(target, argumentsList, newTarget)<br>参数：<br>target： 借用构造函数的对象<br>argumentsList： 构造函数的参数<br>newTarget： 需要创建实例的构造方法/类</p></blockquote></details><h2 id="关于Proxy和Reflect结合的思考">关于Proxy和Reflect结合的思考</h2><details open>    <summary>        <span>查看</span>    </summary><p>上文我们已经了解到，Proxy的是对象的代理，通过对其自定义行为对象中添加相应的捕获器，可以监听到对象相应的的操作，Reflect实现了对对象操作的规范化，弥补了对象的不足，同时将Proxy和Reflect结合使用，可以保证Proxy的陷阱的实现正确性，保证了Proxy的代理封装性。</p><p>Proxy与被代理对象的数据是同步的，因为Proxy最终读取始终是被代理对象的属性，即使不通过Proxy对源对象进行修改。</p><p>Reflect操作源对象的get/set方法是对对象的内部方法<code>[[Get]]</code>/<code>[[Set]]</code>的显示封装，而通过<code>obj.[key]</code>则是对其的隐式封装，但对其的操作容易受this的影响而变为对其他对象的操作，而Reflect可以通过receiver保证this指向的正确性，放如Proxy中，既可以保证this永远指向receiver，从而实现对源对象的<code>[[Get]]</code>/<code>[[Set]]</code>操作都会走Proxy进而触发捕获器。</p><p>即当不存在访问器属性时，this其实与<code>[[Get]]</code>/<code>[[Set]]</code>的操作并无关系，从<code>Reflect.get(target, key, receiver)</code>中可以看出，对属性值的获取其值只需target和key就行，通过target的内部方法<code>[[Get]]</code>即可获取到属性值，而不需要this，当存在访问器时，通过receiver只是提供正确的this指向代理对象，同时也可以看出Proxy的操作一直就是对target（被代理对象）的操作，而不是对Proxy本身的操作，所以默认情况下，Proxy保持与被代理对象的数据同步，但如果Proxy在捕获器中进行了自定义操作（未对对象进行相应操作），代理对象与被代理对象就不一定数据同步了。</p></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 监听对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写apply、call、bind函数</title>
      <link href="/2025/02/28/%E6%89%8B%E5%86%99apply%E3%80%81call%E3%80%81bind%E5%87%BD%E6%95%B0/"/>
      <url>/2025/02/28/%E6%89%8B%E5%86%99apply%E3%80%81call%E3%80%81bind%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="实现apply、call函数">实现apply、call函数</h2><details open>    <summary>        <span>查看</span>    </summary><figure class="highlight js"><figcaption><span>实现apply</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">zApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args = []</span>) &#123;</span><br><span class="line">    thisArg = <span class="keyword">typeof</span> thisArg === <span class="string">&#x27;object&#x27;</span> ? thisArg : <span class="title class_">Object</span>(thisArg)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(thisArg, <span class="string">&#x27;fn&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo.<span class="title function_">zApply</span>(bar, [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>实现call</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">zCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">    thisArg = <span class="keyword">typeof</span> thisArg === <span class="string">&#x27;object&#x27;</span> ? thisArg : <span class="title class_">Object</span>(thisArg)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(thisArg, <span class="string">&#x27;fn&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo.<span class="title function_">zCall</span>(bar, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以上代码存在相同之处，可以尝试对以上操作进行封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">    thisArg = <span class="keyword">typeof</span> thisArg === <span class="string">&#x27;object&#x27;</span> ? thisArg : <span class="title class_">Object</span>(thisArg)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(thisArg, <span class="string">&#x27;fn&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">zCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">execute</span>(thisArg, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">zApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args = []</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">execute</span>(thisArg, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1, arg2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> bar1 = &#123; <span class="attr">name1</span>: <span class="number">2</span> &#125;</span><br><span class="line">foo.<span class="title function_">zApply</span>(bar, [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>])</span><br><span class="line">foo.<span class="title function_">zCall</span>(bar1, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>手写实现的弊端：</p><ul class="lvl-0"><li class="lvl-2"><p>以上是通过隐式绑定this机制实现的，但需要向调用者传入参数，这样会对外部产生影响，且容易覆盖原有对象的属性，虽然最后会将添加的属性删除，但对于thisArg所引用的对象来说，影响可能是很大的。</p></li></ul></details><h2 id="实现bind函数">实现bind函数</h2><details open>    <summary>        <span>查看</span>    </summary><figure class="highlight js"><figcaption><span>实现bind</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">zBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line"></span><br><span class="line">    thisArg = <span class="keyword">typeof</span> thisArg === <span class="string">&#x27;object&#x27;</span> ? thisArg : <span class="title class_">Object</span>(thisArg)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(thisArg, <span class="string">&#x27;fn&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> thisArg.<span class="title function_">this</span>(...args, ...args1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">bind</span>(&#123; <span class="attr">name</span>: <span class="number">1</span> &#125;, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br></pre></td></tr></table></figure><p>弊端：</p><ul class="lvl-0"><li class="lvl-2"><p>和手写实现apply/call的思路基本相同，但为调用着添加了个属性，且不能对其删除，影响很大。</p></li></ul></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
          <category> 手写函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 手写函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6知识点记录</title>
      <link href="/2025/02/28/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/02/28/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="标签模板字符串">标签模板字符串</h2><details open>    <summary>        <span>查看</span>    </summary><p>模板字符串的语法为<code>``</code>，其中用<code>$&#123;&#125;</code>符号可以传入变量，最终拼接为一个字符串，但<code>``</code>还可以用于函数的调用，此用法称为标签模板字符串（Tagged Template Literals）。</p><p>通过标签模板字符串调用的函数，会将字符串放在一个数组中，位于函数参数的第一位，如果其中用到<code>$&#123;&#125;</code>符号，会将其作为分割符，分割的字符串每一部分作为数组的一项值，而<code>$&#123;&#125;</code>中的表达式结果会作为函数参数，从第二个参数依次传入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args) <span class="comment">// [[ &#x27;this is &#x27;, &#x27; tagged &#x27;, &#x27; template &#x27;, &#x27; literals&#x27; ], 1, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span></span><br><span class="line"></span><br><span class="line">foo<span class="string">`this is <span class="subst">$&#123;<span class="number">1</span>&#125;</span> tagged <span class="subst">$&#123;bar&#125;</span> template <span class="subst">$&#123;baz&#125;</span> literals`</span></span><br></pre></td></tr></table></figure><p>使用场景：React的styled-componetns库中就用到了标签模板字符串。</p></details><h2 id="函数的默认参数">函数的默认参数</h2><details open>    <summary>        <span>查看</span>    </summary><p>ES6之后函数的参数可以设置默认值，设置默认值的参数和剩余参数不会记录到Funciton.length中。</p><p>推荐将设置默认值的参数放在普通参数后面，剩余参数前面。</p><p>因为对于某些语言，设置默认值的参数放在普通参数前会报错。如python，C++等。</p></details><h2 id="函数箭头函数的补充">函数箭头函数的补充</h2><details open>    <summary>        <span>查看</span>    </summary><p>由于箭头函数没有显式原型prototype，所以不能作为构造函数，使用new创建对象。</p><p>箭头函数也不存在this，arguments，super参数。</p></details><h2 id="Symbol的基本使用">Symbol的基本使用</h2><details open>    <summary>        <span>查看</span>    </summary><p>我们需要先思考一下Symbol的出现解决了哪些问题？</p><p>在ES6之前，对象的属性名都是字符串形式，很容易造成属性覆盖，尤其是在引入外部js文件是，我们很大可能不知道引入的对象存在的属性，一旦对其进行修改，可能会造成意想不到的bug。</p><p>而Symbol的出现，解决了这个问题。Symbol可以用来生成一个独一无二的值，并且可以作为字符串的键值。</p><p>Symbol的基本使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;s2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对于对象中的Symbol键值是不能通过Object.keys()获取的，但是可以通过Object.getOwnPropertySymbols()获取（只能获取属性为Symbol的键值），且返回的是一个可迭代对象，需要通过迭代才能获取到对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>()]: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="keyword">const</span> symbolKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> symbolKeys) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, obj[key]) <span class="comment">// Symbol() 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面通过<code>Symbol()</code>创建的都是独一无二的值，但我们可不可以创建一个重复的Symbol值？</p><p>需要用到<code>Symbol.for()</code>方法，此方法可以传入一个描述参数，只有传入相同的描述参数，才会返回同一个值。且只有同样使用Symbol.for()创建的Symbol值，且描述参数相同，返回的值才相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>()</span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s4 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s3) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3 === s4) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>并且我们可以通过<code>Symbol.keyFor()</code>方法来获取Symbol的值对应的描述参数，且只有通过<code>Symbol.for()</code>方法创建的Symbol，才能用<code>Symbol.keyFor()</code>方法获取到对应的描述参数。</p><p>如果是通过<code>Symbol()</code>创建的Symbol，则需要用创建的Symbol的description属性来获取对应的描述参数。此属性对用通过<code>Symbol.for()</code>方法创建的Symbol也可用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;333&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1), <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2), <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s3)) <span class="comment">// 111 222 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">description</span>, s2.<span class="property">description</span>, s3.<span class="property">description</span>) <span class="comment">// 111 222 333</span></span><br></pre></td></tr></table></figure></details><h2 id="Set、WeakSet、Map、WeakMap">Set、WeakSet、Map、WeakMap</h2><details open>    <summary>        <span>查看</span>    </summary><p>ES6新增了两种数据结构，分别是Set和Map，以及他们的另外形式WeakSet和WeakMap。</p><h3 id="Set">Set</h3><p>Set和数组类似，可以用于保存数据，但是其中的元素不能重复，所以Set可以用于数组去重。</p><p>Set的属性和方法：</p><ul class="lvl-0"><li class="lvl-2"><p>属性</p><ul class="lvl-2"><li class="lvl-4">size：返回Set中元素的个数。</li></ul></li><li class="lvl-2"><p>方法</p><ul class="lvl-2"><li class="lvl-4">add(value)：向Set中添加元素，返回Set本身。</li><li class="lvl-4">delete(value)：从Set中删除于value值相等的元素，返回boolean类型。</li><li class="lvl-4">has(value)：判断set中是否存在某个元素，返回boolean类型。</li><li class="lvl-4">clear()：清空Set中所有的元素，没有返回值。</li><li class="lvl-4">forEach(callback, [, thisArg])：通过forEach遍历set。</li></ul></li><li class="lvl-2"><p>Set支持使用for of的遍历。</p></li></ul><h3 id="WeakSet">WeakSet</h3><p>与Set类似的有Weakset，也是内部不能重复的数据结构。</p><p>但区别为，WeakSet中只能存放对象，如其中存储的对象为弱引用，即如果没有其他引用对其中存储的某个对象有引用，那么GC可以对该对象回收。</p><ul class="lvl-0"><li class="lvl-2"><p>方法</p><ul class="lvl-2"><li class="lvl-4">add(value)：向WeakSet中添加元素，返回WeakSet本身。</li><li class="lvl-4">delete(value)：从WeakSet中删除于value值相等的元素，返回boolean类型。</li><li class="lvl-4">has(value)：判断WeakSet中是否存在某个元素，返回boolean类型。</li></ul></li></ul><p>WeakSet不能遍历，因为对其中存储的仅仅是弱引用，不一定什么时候就被回收了，可能会获取不到。</p><h3 id="Map">Map</h3><p>Map用于存储映射关系，和对象类似，但对象的键只能为字符串或Symbol，如果设定键为对象，会将其转为字符串，导致键值变为<code>&#123;object Object】</code>的形式，但Map中的键可以设置对象类型。</p><p>Map的基本使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>], [<span class="function">() =&gt;</span> &#123; &#125;, <span class="number">22</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(3) &#123;&#x27;name&#x27; =&gt; &#x27;zhangsan&#x27;, &#x27;age&#x27; =&gt; 18, ƒ =&gt; 22&#125;</span></span><br></pre></td></tr></table></figure><p>常用方法：</p><ul class="lvl-0"><li class="lvl-2"><p>属性</p><ul class="lvl-2"><li class="lvl-4">size：返回Map中元素的个数。</li></ul></li><li class="lvl-2"><p>方法</p><ul class="lvl-2"><li class="lvl-4">set(key, value)：向Map中添加元素，返回Map本身。</li><li class="lvl-4">get(key)：获取与key值相等的元素对应的value值，返回value值。</li><li class="lvl-4">delete(key)：从Map中删除与key值相等的元素，返回boolean类型。</li><li class="lvl-4">has(key)：判断Map中是否存在某个元素，返回boolean类型。</li><li class="lvl-4">clear()：清空Map中所有的元素，没有返回值。</li><li class="lvl-4">forEach(callback, [, thisArg])：通过forEach遍历Map。</li></ul></li></ul><p>Map也是可迭代对象，支持for of的遍历。</p><h3 id="WeakMap">WeakMap</h3><p>WeakMap与Map类似，但其中存储的键值只能为对象类型，且也是弱引用。</p><p>常见方法：</p><ul class="lvl-0"><li class="lvl-2"><p>set(key, value)：向WeakMap中添加元素，返回WeakMap本身。</p></li><li class="lvl-2"><p>get(key)：获取与key值相等的元素对应的value值，返回value值。</p></li><li class="lvl-2"><p>delete(key)：从WeakMap中删除与key值相等的元素，返回boolean类型。</p></li><li class="lvl-2"><p>has(key)：判断WeakMap中是否存在某个元素，返回boolean类型。</p></li></ul><h3 id="WeakSet与WeakMap的弱引用">WeakSet与WeakMap的弱引用</h3><p>对于WeakSet和WeakMap，是ES6之后推出的数据结构，用于实现对对象的存储，但对对象的引用是弱引用。</p><p>弱引用是即使存在对对象的引用，但当被引用对象不存在强引用时，会被标记为可回收状态，随后被GC（垃圾回收器）回收。</p><p>至于对对象不存在强引用的状态，可以分为两种：</p><ul class="lvl-0"><li class="lvl-2"><p>当对象离开作用域时</p></li><li class="lvl-2"><p>但对对象的引用赋值为null时</p></li></ul><p>假设不存在闭包，当代码块中创建了对象，并用WeakSet或WeakMap存储，当代码块执行完毕，EC弹出ECS，且代码块中的对象没有被其他变量引用，此时便标记为为回收状态，存在闭包时，如果对函数返回的闭包状态进行了变量接受，此时对其时强引用，只能手动赋值为null，此时才可被回收。</p><p>WeakSet和WeakMap的引用场景：</p><ul class="lvl-0"><li class="lvl-2"><p>跟踪对象状态</p></li><li class="lvl-2"><p>添加临时对象</p></li><li class="lvl-2"><p>减少内存泄漏</p></li></ul><p>跟踪对象状态这一块，能做的操作很多，通过对其的get、set、has方法的组合使用，可以保证对象可用，类似的操作也可以用于避免DOM的事件重复绑定和缓存操作等。</p></details><h2 id="FinalizationRegistry">FinalizationRegistry</h2><details open>    <summary>        <span>查看</span>    </summary><p>FinalizationRegistry对象可以让你在对象被来及回收时请求一个回调。</p><ul class="lvl-0"><li class="lvl-2"><p>FinalizationRegistry 提供了这样的一种方法：当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）。</p></li><li class="lvl-2"><p>你可以通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([obj])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is dead`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">registry.<span class="title function_">register</span>(obj, <span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure></details><h2 id="WeakRefs">WeakRefs</h2><details open>    <summary>        <span>查看</span>    </summary><p>如果我们默认将一个对象赋值给另一个引用，那么这个对象是一个强引用。如果我们希望是一个弱引用的话，可以使用WeakRef。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(obj)</span><br><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is dead`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">registry.<span class="title function_">register</span>(obj, <span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure></details><h2 id="method-at"><a href="http://method.at">method.at</a>()</h2><details open>    <summary>        <span>查看</span>    </summary><p>ES13引入了at方法，用于获取数组和字符串中指定位置的元素或字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">at</span>(<span class="number">0</span>), str.<span class="title function_">at</span>(<span class="number">0</span>)) <span class="comment">// 1 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">at</span>(-<span class="number">1</span>), str.<span class="title function_">at</span>(-<span class="number">1</span>)) <span class="comment">// 3 3</span></span><br></pre></td></tr></table></figure></details><h2 id="Object-hasOwn-obj-propKey">Object.hasOwn(obj, propKey)</h2><details open>    <summary>        <span>查看</span>    </summary><p>ES13在Object中新增了hasOwn静态方法，用于判断一个对象中是否存在某个属性，不包括原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>, obj.<span class="property">age</span>) <span class="comment">// obj 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(obj, <span class="string">&#x27;name&#x27;</span>), <span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(obj, <span class="string">&#x27;age&#x27;</span>)) <span class="comment">// true false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>), obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;age&#x27;</span>)) <span class="comment">// true false</span></span><br></pre></td></tr></table></figure><p>Object.hasOwn和Object.prototype.hasOwnProperty的区别：</p><ul class="lvl-0"><li class="lvl-2"><p>一个是在静态方法上，一个是在原型对象上。</p></li><li class="lvl-2"><p>hasOwnProperty在原型对象上，很容易被对象内部重写，因为可能有人不知道有这个方法，从而自定义了一个，对后续造成了影响。</p></li><li class="lvl-2"><p>对于隐式原型指向null的对象，hasOwnProperty无法进行判断。</p><ul class="lvl-2"><li class="lvl-4">因为hasOwnProperty是通过原型链找到Object的原型对象调用的，一旦将对象的移除指向Objetc的原型对象时，那么hasOwnProperty就无法调用了。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(obj, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>let、const和var的区别</title>
      <link href="/2025/02/28/let%E3%80%81const%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/02/28/let%E3%80%81const%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li class="lvl-3"><p>let、const声明的变量不能重复声明，const声明的变量不能被再次赋值，而var声明的变量可以重复声明。</p></li><li class="lvl-3"><p>let、const存在暂时性死区，而var定义的变量不存在暂时性死区。</p><ul class="lvl-2"><li class="lvl-5">暂时性死区：即在let、const所处的当前作用域到变量声明的那一行，是不能使用变量的。</li><li class="lvl-5">暂时性死区与声明的位置无关，而与代码的执行顺序有关。</li></ul></li><li class="lvl-3"><p>let、const定义的变量不存在变量提升。</p><ul class="lvl-2"><li class="lvl-5">let、const定义的变量虽然不存在变量提升，但是在解析阶段其实已经在其对应的词法环境中的环境记录中创建了该变量，只是不能使用。</li></ul></li><li class="lvl-3"><p>let、const定义的变量所属的代码块存在块级作用域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 变量声明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS实现继承</title>
      <link href="/2025/02/24/JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/02/24/JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="对象的原型">对象的原型</h2><details open>    <summary>        <span>查看</span>    </summary><p>每一个函数对象内都有一个prototype属性，其值是一个对象，这个对象就是原型对象。</p><p>获取原型对象的方式有两种：</p><ul class="lvl-0"><li class="lvl-2"><p>通过对象的<code>__proto__</code>属性可以获取到，但这个是浏览器早期自己添加的，存在兼容性问题。</p></li><li class="lvl-2"><p>通过<code>Object.getPrototypeOf()</code>方法可以获取到，但其也存在老版本浏览器的兼容性问题。</p></li></ul><p>通过new操作符创建的对象，会执行如下几步操作：</p><ol><li class="lvl-3"><p>创建一个空的对象。</p></li><li class="lvl-3"><p>将this指向创建的空对象。</p></li><li class="lvl-3"><p>将构造函数的prototype属性赋值给被创建对象。</p></li><li class="lvl-3"><p>执行函数内的代码。</p></li><li class="lvl-3"><p>若返回值不是对象，则将创建的对象返回。</p></li></ol><p>所以对象内存在与其对应的构造函数的prototype的相同引用，我们称之为在对象中为隐式原型对象，在函数中称之为显式原型对象。原型对象也是一个对象，如果在原型对象中找不到，会继续向原型对象的原型对象中寻找，直到找到或null为止，此链式查找也称为[隐式]原型链查找。</p><p>JS中的对象都有一个特殊的内置属性<code>[[Prototype]]</code>，其指向父类的原型对象，但该属性是不可调用的，因为它仅仅是一个标准，通过此属性，可以查看对象的原型链关系。</p></details><h2 id="Constructor">Constructor</h2><details open>    <summary>        <span>查看</span>    </summary><p>原型对象上存在属性<code>constructor</code>，其指向当前的函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Foo</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面我们说可以通过原型链查找属性，那么方法也是可以的，通过在原型对象添加方法可以减少相同操作代码的编写，提高代码的复用性。</p><p>语法：<code>Foo.prototype.变量名 = function()&#123;&#125;</code></p><p>但当我们需要添加多个方式时，一直重复上述操作有些麻烦，所有，我们可以重写原型对象来简化操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">property</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于原型对象的constructor属性是不可枚举的，所以我们需要通过属性描述符对其进行单独操作。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Foo</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></details><h2 id="ES5实现继承">ES5实现继承</h2><details open>    <summary>        <span>查看</span>    </summary><p>前提：定义一个Person对象和Student对象。目标：实现Student对象继承Person对象。</p><h3 id="方法一：通过原型链实现继承">方法一：通过原型链实现继承</h3><p>通过Person构造方法创建一个person实例对象，改变Student构造函数对象的prototype指向person实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobbies</span> = [<span class="string">&#x27;看电影&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">studying</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;正在学习&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"></span><br><span class="line">s1.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;看小说&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">hobbies</span>, s2.<span class="property">hobbies</span>) <span class="comment">// (2) [&#x27;看电影&#x27;, &#x27;看小说&#x27;] (2) [&#x27;看电影&#x27;, &#x27;看小说&#x27;]</span></span><br></pre></td></tr></table></figure><p>弊端：</p><ul class="lvl-0"><li class="lvl-2"><p>有些属性是保存在实例对象p上的，通过直接打印实例对象s1，s2，看不到name、hobbies属性。</p></li><li class="lvl-2"><p>虽然我们可以通过原型链访问到属性，但原型对象对于通过同一个构造函数创建的对象是共享的，意味如果修改原型对象上的引用属性，对其他的实例对象都会受影响。</p></li><li class="lvl-2"><p>我们之所以要实现继承，是为了复用代码，但以上的情况，我们无法给Person传递参数，导致创建的s1，s2实例对象没有自己的属性，即无法进行定制化操作。</p></li></ul><h3 id="方法二：借用构造函数实现继承">方法二：借用构造函数实现继承</h3><p>constructor stealing：借用构造函数/经典继承/伪造对象</p><p>在Student构造函数内调用Person的构造函数，并通过call/apply改变this指向，实现继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, hobbies</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobbies</span> = hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, hobbies, age</span>) &#123; </span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, hobbies)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;张三&#x27;</span>, [<span class="string">&#x27;看电影&#x27;</span>, <span class="string">&#x27;看小说&#x27;</span>], <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李四&#x27;</span>, [<span class="string">&#x27;玩游戏&#x27;</span>], <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">s1.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;看小说&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">name</span>, s2.<span class="property">name</span>) <span class="comment">// 张三 李四</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">hobbies</span>, s2.<span class="property">hobbies</span>) <span class="comment">// (3) [&#x27;看电影&#x27;, &#x27;看小说&#x27;, &#x27;看小说&#x27;] [&#x27;玩游戏&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">age</span>, s2.<span class="property">age</span>) <span class="comment">// 18 20</span></span><br></pre></td></tr></table></figure><p>弊端：</p><ul class="lvl-0"><li class="lvl-2"><p>直接把Person的原型对象赋值给Student的原型对象，这样会导致通过Student对原型对象的修改会直接影响到Peroson的原型对象。</p></li></ul><h3 id="方法三：组合借用继承">方法三：组合借用继承</h3><p>即将方法一和方法二结合起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, hobbies</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobbies</span> = hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, hobbies, age</span>) &#123; </span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, hobbies)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = p</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;张三&#x27;</span>, [<span class="string">&#x27;看电影&#x27;</span>, <span class="string">&#x27;看小说&#x27;</span>], <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李四&#x27;</span>, [<span class="string">&#x27;玩游戏&#x27;</span>], <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">s1.<span class="property">hobbies</span>.<span class="title function_">push</span>(<span class="string">&#x27;看小说&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">name</span>, s2.<span class="property">name</span>) <span class="comment">// 张三 李四</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">hobbies</span>, s2.<span class="property">hobbies</span>) <span class="comment">// (3) [&#x27;看电影&#x27;, &#x27;看小说&#x27;, &#x27;看小说&#x27;] [&#x27;玩游戏&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">age</span>, s2.<span class="property">age</span>) <span class="comment">// 18 20</span></span><br></pre></td></tr></table></figure><p>通过这种方法来实现继承已经问题不到了，但仍有不完美的地方，比如：</p><ul class="lvl-0"><li class="lvl-2"><p>Person构造函数会被调用两次。</p><ul class="lvl-2"><li class="lvl-4">第一次是在赋值给Student.prototype的时候。</li><li class="lvl-4">第二次是借用构造函数的时候。</li></ul></li><li class="lvl-2"><p>Student实例对象上和其原型对象上会存在相同的属性，尽管值可能不同，但好在优先在对象本身上进行查找。</p></li></ul><p>以上代码我们发现，实例化p仅仅是为了将其原型对象关联到Student.prototype上，那么是不是只要是个对象，然后将其隐式原型对象指向Person的显示原型对象即可？</p><h3 id="方法四：原型式继承函数">方法四：原型式继承函数</h3><p>原型式继承是由从道格拉斯·克罗克福德（Douglas Crockford，著名的前端大师，JSON的创立者）在2006年写的一篇文章说起: Prototypal Inheritance in JavaScript(在JavaScript中使用原型式继承)。</p><p>其实就是上述提出的创建一个对象，作为继承连接的原型对象桥梁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码完全不必担心兼容性的问题，但我们也可以对其进行改造，原理是一样的，不过是调用了些API，可能会存在兼容性的问题。可以通过<code>Object.setPrototypeOf(obj, prototype)</code>和<code>Object.create(proto, propertiesObject)</code>来实现。</p><blockquote><p>Object.setPrototypeOf(obj, prototype)：将obj的原型指向prototype。参数：<br>obj: 需要修改原型的对象。<br>prototype: 需要指向的原型对象。</p></blockquote><p>通过该API可以将以上代码修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(newObj, obj)</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Object.create(proto, propertiesObject)：创建一个对象，并将此对象的原型指向proto，并通过propertiesObject对此对象进行属性描述符操作，然后返回此对象。参数：<br>proto: 需要指向的原型对象<br>propertiesObject（可选）: 需要添加的属性描述符对象。返回值：返回一个对象，返回对象的隐式原型对象指向传入的原型对象。</p></blockquote><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过该API可以将以上代码修改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所看，通过原型式继承函数的代码可以为（最具兼容性的方式）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, hobbies</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobbies</span> = hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, hobbies, age</span>) &#123; </span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, hobbies)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">object</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure><h3 id="方法五：寄生式继（Parasitic）承函数">方法五：寄生式继（Parasitic）承函数</h3><p>什么是寄生式继承？</p><ul class="lvl-0"><li class="lvl-2"><p>寄生式继承式是与原型式继承紧密相连的一种思想，同样由道格拉斯·克罗克福德提出和推广。</p></li><li class="lvl-2"><p>寄生式继承是<strong>结合原型式继承和工厂模式</strong>的一种方式</p></li><li class="lvl-2"><p>即创建一个封装继承过程的函数，该函数在内部以某种方式来增强对象，最后将这个对象返回。</p></li></ul><p>核心步骤：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newObj = <span class="title function_">object</span>(person)</span><br><span class="line">    newObj.<span class="property">studying</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, hobbies</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobbies</span> = hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, hobbies, age</span>) &#123; </span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, hobbies)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createStudent</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newObj = <span class="title function_">object</span>(person)</span><br><span class="line">    newObj.<span class="property">studying</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    reuturn newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property">property</span> = <span class="title function_">createStudent</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure><p>以上代码进一步的细分，实现一种函数实现特定功能，并在特定的函数中在原型对象上添加属性和方法。</p><h3 id="最终方案：-寄生组合继承">最终方案： 寄生组合继承</h3><p>结合前几种的思想，结合成最终继承方案。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, hobbies</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hobbies</span> = hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, hobbies, age</span>) &#123; </span><br><span class="line">    <span class="comment">// 借用构造函数</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, hobbies)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型式继承核心代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Func</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span> = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Func</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式核心代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过原型链实现</span></span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = subType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>通过以上多种实现继承的方案来看，在ES5时期，并没有一个统一的标准，可谓是百花齐放。</p><p>总结一下，ES5实现继承的方法有：</p><ol><li class="lvl-3"><p>通过原型链实现继承：通过创建父类实例作为原型对象将子类与父类进行连接。</p><p>缺陷：</p><ul class="lvl-2"><li class="lvl-6"><p>能访问到执行父类代码创建到原型对象的属性，但其在原型对象上，直接打印子类实例对象是看不到的。</p></li><li class="lvl-6"><p>由于实现继承的目的是为了复用父类中的属性和方法，在此种情况下，无法定制化子类实例对象的属性和方法。即多个子类对象访问的属性都是相同的，且一旦存在属性为引用对象，则修改其中一个子类对象属性，则其他子类对象属性也会被修改。</p></li></ul></li><li class="lvl-3"><p>借用构造函数实现继承：通过apply/call调用父类构造函数，将父类中的属性和方法添加到子类实例对象上。</p><p>缺陷：</p><ul class="lvl-2"><li class="lvl-6"><p>此种方法是直接将子类的原型对象指向父类的原型对象，一旦通过子类操作原型对象会直接对父类原型对象造成影响。</p></li></ul></li><li class="lvl-3"><p>组合借用继承：将前两种方法结合起来使用（已基本能够作为继承的方案）。</p><p>缺陷：</p><ul class="lvl-2"><li class="lvl-6"><p>会调用两次父类构造函数，导致实例对象本身和其原型对象上存在相同的属性。</p></li><li class="lvl-6"><p>且保露父类实例化在外部不太美观。</p></li></ul></li><li class="lvl-3"><p>原型式继承：由道格拉斯·克洛克福德提出，将一个普通函数的原型对象指向父类原型对象，然后将此普通函数实例化返回作为子类原型对象。且可以通过新的API对其进行改造，如<code>Object.create(proto, propertiesObject)</code>和<code>Object.setPrototypeOf(obj, prototype)</code>，但有一定的兼容性问题。</p></li><li class="lvl-3"><p>寄生式继承：由道格拉斯·克洛克福德提出，在原型式继承的基础上，将为中间原型对象添加方法的操作封装到函数中，然后返回此原型对象作为子类原型对象。</p></li><li class="lvl-3"><p>寄生组合继承：总结以上方法的优点，借用构造函数实现子类的定制化，通过原型式继承函数，实现子类原型对象函数的创建，通过寄生式继承函数，在函数内通过原型继承实现子类原型对象的绑定，并将原型对象的constructor指向子类。</p></li></ol></details><h2 id="对象方法补充">对象方法补充</h2><details open>    <summary>        <span>查看</span>    </summary><ul class="lvl-0"><li class="lvl-2"><p><code>Object.prototype.hasOwnProperty()</code>：判断对象是否是自身属性，而不是原型对象上的属性。</p></li><li class="lvl-2"><p>in/for in 操作符：判断某个属性是否在某个对象或对象的原型上。</p><ul class="lvl-2"><li class="lvl-4"><code>name in obj / for (var item in obj)</code></li></ul></li><li class="lvl-2"><p>instanceof: 用于检测构造函数的prototype是否出现在某个实例对象的原型链上。</p></li><li class="lvl-2"><p>isPrototypeOf: 用于检测某个对象是否出现在某个实例对象的原型链上。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> info = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">isPrototypeOf</span>(info)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="title function_">isPortotypeOf</span>(obj)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="手动实现instanceOf">手动实现instanceOf</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceof</span>(<span class="params">o, c</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> op = o.<span class="property">__proto__</span></span><br><span class="line">    <span class="keyword">while</span> (op !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op === c.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            op = op.<span class="property">__proto__</span>    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="原型继承关系图">原型继承关系图</h2><img data-src="/2025/02/24/JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class="" title="原型继承关系图"><h2 id="ES6实现继承">ES6实现继承</h2><details open>    <summary>        <span>查看</span>    </summary><p>ES6新增了<code>class</code>关键字，用于创建类，通过类创建实例对象。</p><p>通过class创建对象的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Student</span> = <span class="keyword">class</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>class与class通过extends实现继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>class是个语法糖，本质上和构造函数是没有区别的，特别的是class定义的类是不能向构造函数一样调用的，内部做了调用判断。</p><p>而class的继承和ES5的寄生组合继承在核心上是一致的，只不过class加了更多的边界判断，且将子类的隐式原型指向父类，以便可以通过子类调用父类的类方法。在ES5可以通过<code>Student.__proto__ = Person</code>或<code>Object.setPrototypeOf(Student, Person)</code>实现。</p></details><h2 id="额外知识点补充">额外知识点补充</h2><details open>    <summary>        <span>查看</span>    </summary><h3 id="super关键字">super关键字</h3><p>Class中可以使用super关键字，通过super可以调用父类方法（实例方法和静态方法）和父类构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age, hobbies</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        <span class="variable language_">super</span>(name, age)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hobbies</span> = hobbies</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">oFoo</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">foo</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">oEating</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">eating</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">oFoo</span>()</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, [<span class="string">&#x27;吃饭&#x27;</span>, <span class="string">&#x27;睡觉&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">s.<span class="title function_">oEating</span>()</span><br></pre></td></tr></table></figure><p><mark>注意：在子（派生）类的构造函数中使用this或返回默认对象之前，必须先通过super调用父类构造函数。</mark> 即如果在类中定义了constructor，必须在子类constructor中头行调用super，否则会报错。</p><h3 id="类的混入">类的混入</h3><p>背景：</p><p>JS的类只支持单继承，如果在开发中我们需要在一个类中添加更多相似的功能，可以通过类的混入实现。</p><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mixinRunner</span>(<span class="params">BaseClass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">        <span class="title function_">running</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixinEater</span>(<span class="params">BaseClass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">        <span class="title function_">eating</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mixinEater</span>(<span class="title function_">mixinRunner</span>(<span class="title class_">Person</span>)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line">s.<span class="title function_">eating</span>()</span><br><span class="line">s.<span class="title function_">running</span>()</span><br></pre></td></tr></table></figure><p>其实就是创建一个类继承需要扩展功能的类，如果有需求，再创建一个类继承前面创建的类，以此类推，知道所有需要扩展的功能都添加完，再交由其他类继承。</p><p>只不过上述代码对继承过程进行了封装然后将已继承的匿名类返回，一种功能封装一个函数，使代码结构更加清晰，增加了代码的可维护性，实现了代码复用，降低了耦合度，有利于模块化，便于管理和扩展等。</p><h3 id="JS中的多态">JS中的多态</h3><p>面向对象的三大特征：封装、继承、多态。</p><p>对于JS来说，由于其的灵活性，其是否存在多态？</p><p>对于多态的定义：多态指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的数据类型。</p><p>从此定义来看，可以说JS中处处存在多态。</p><p>以如下代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述函数，其参数可以是任意类型，所以可以认为其存在多态。</p><p>对于单一的符号，通过var声明的变量，可以为其进行任意类型的复制，所以也可以认为其存在多态。</p></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象增强</title>
      <link href="/2025/02/23/JS%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%BC%BA/"/>
      <url>/2025/02/23/JS%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Object-defineProperty">Object.defineProperty</h2><details open>    <summary>        <span>查看</span>    </summary><p><code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><blockquote><p>Object.defineProperty(obj, props, descriptor)<br>obj: 要定义一个属性的对象<br>props: 要定义或修改的属性的名称或Symbol<br>descriptor: 要定义或修改的属性描述符返回值： 被传递给此函数的对象</p></blockquote><p>属性描述符分为数据属性（Data Properties）描述符（Descriptor）和存取属性（Accessor访问器 Properties）描述符。</p><img data-src="/2025/02/23/JS%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%BC%BA/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" class="" title="属性描述符"><p>数据属性描述符的特性：</p><ul class="lvl-0"><li class="lvl-2"><p><code>[[Configurable]]</code>：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；</p><ul class="lvl-2"><li class="lvl-4">当我们直接在一个对象上定义某个属性时，这个属性的<code>[[Configurable]]</code>为true；</li><li class="lvl-4">当我们通过属性描述符定义一个属性时，这个属性的<code>[[Configurable]]</code>默认为false；</li></ul></li><li class="lvl-2"><p><code>[[Enumerable]]</code>：表示属性是否可以通过for-in或者Object.keys()返回该属性；</p><ul class="lvl-2"><li class="lvl-4">当我们直接在一个对象上定义某个属性时，这个属性的<code>[[Enumerable]]</code>为true；</li><li class="lvl-4">当我们通过属性描述符定义一个属性时，这个属性的<code>[[Enumerable]]</code>默认为false；</li></ul></li><li class="lvl-2"><p><code>[[Writable]]</code>：表示是否可以修改属性的值；</p><ul class="lvl-2"><li class="lvl-4">当我们直接在一个对象上定义某个属性时，这个属性的[<code>[Writable]</code>]为true；</li><li class="lvl-4">当我们通过属性描述符定义一个属性时，这个属性的<code>[[Writable]]</code>默认为false；</li></ul></li><li class="lvl-2"><p><code>[[value]]</code>：属性的value值，读取属性时会返回该值，修改属性时，会对其进行修改；</p><ul class="lvl-2"><li class="lvl-4">默认情况下这个值是undefined；</li></ul></li></ul><p>存取属性描述符的特性：</p><ul class="lvl-0"><li class="lvl-2"><p><code>[[Configurable]]</code>：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；</p><ul class="lvl-2"><li class="lvl-4">和数据属性描述符是一致的；</li><li class="lvl-4">当我们直接在一个对象上定义某个属性时，这个属性的<code>[[Configurable]]</code>为true；</li><li class="lvl-4">当我们通过属性描述符定义一个属性时，这个属性的<code>[[Configurable]]</code>默认为false；</li></ul></li><li class="lvl-2"><p><code>[[Enumerable]]</code>：表示属性是否可以通过for-in或者Object.keys()返回该属性；</p><ul class="lvl-2"><li class="lvl-4">和数据属性描述符是一致的；</li><li class="lvl-4">当我们直接在一个对象上定义某个属性时，这个属性的<code>[[Enumerable]]</code>为true；</li><li class="lvl-4">当我们通过属性描述符定义一个属性时，这个属性的<code>[[Enumerable]]</code>默认为false；</li></ul></li><li class="lvl-2"><p><code>[[get]]</code>：获取属性时会执行的函数。默认为undefined</p></li><li class="lvl-2"><p><code>[[set]]</code>：设置属性时会执行的函数。默认为undefined</p></li></ul><p>Object.defineProperties() 方法直接在一个对象上定义 多个 新的属性或修改现有属性，并且返回该对象。</p></details><h2 id="对象方法补充">对象方法补充</h2><details open>    <summary>        <span>查看</span>    </summary><ul class="lvl-0"><li class="lvl-2"><p>获取对象的属性描述符：</p><ul class="lvl-2"><li class="lvl-4">getOwnPropertyDescriptor</li><li class="lvl-4">getOwnPropertyDescriptors</li></ul></li><li class="lvl-2"><p>禁止对象扩展新属性：preventExtensions</p><ul class="lvl-2"><li class="lvl-4">给一个对象添加新的属性会失败（在严格模式下会报错）；</li></ul></li><li class="lvl-2"><p>密封对象，不允许配置和删除属性：seal</p><ul class="lvl-2"><li class="lvl-4">实际是调用preventExtensions</li><li class="lvl-4">并且将现有属性的configurable: false</li></ul></li><li class="lvl-2"><p>冻结对象，不允许修改现有属性：freeze</p><ul class="lvl-2"><li class="lvl-4">实际上是调用seal</li><li class="lvl-4">并且将现有属性的writable: false</li></ul></li></ul></details>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 对象增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数增强</title>
      <link href="/2025/02/23/JS%E5%87%BD%E6%95%B0%E5%A2%9E%E5%BC%BA/"/>
      <url>/2025/02/23/JS%E5%87%BD%E6%95%B0%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="arguments转为Array">arguments转为Array</h2><details open>    <summary>        <span>查看</span>    </summary><p>JS中函数也是个对象，它也有自己的属性和方法，常见的属性有name和length。</p><ul class="lvl-0"><li class="lvl-2"><p>name: 函数名。</p></li><li class="lvl-2"><p>length: 函数未使用参数个数（定义时的形参）。</p><ul class="lvl-2"><li class="lvl-4"><mark>注意：rest参数不参与length的计算。</mark></li></ul></li></ul><p>函数的EC（执行上下文）中关联的VO（<code>variable object</code>）其在堆内存中对应的AO（<code>activation object</code>）创建时会初始化arguments引用的类数组对象，但它只是个类数组对象，虽然可以迭代和通过索引访问参数值，但像数组中的filter等方法是不能使用的，所以，我们通常需要将其转化为数组。</p><h3 id="方法一：for-循环遍历">方法一：for 循环遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：使用数组的slice方法">方法二：使用数组的slice方法</h3><p><code>Array.prototype.slice(start, end)</code>用于截取数组，内部通过this进行截取，所以我们可以改变this的指向，从而实现arguments向Array的转换。</p><figure class="highlight js"><figcaption><span>使用原型方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>使用实例对象处理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种方式归根结底都是获取数组原型方法进行处理<code>Array.prototype.slice(start, end)</code>。</p><h3 id="方法三：使用Array-from">方法三：使用Array.from()</h3><p>ES6中新增了<code>Array.from()</code>方法，该方法可以将类数组对象转化为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="JS纯函数">JS纯函数</h2><details open>    <summary>        <span>查看</span>    </summary><p>在函数式编程中有一个非常重要的概念叫<strong>纯函数</strong>，JS符合函数式编程的范式，所以JS存在纯函数的概念。</p><h3 id="什么纯函数">什么纯函数</h3><ul class="lvl-0"><li class="lvl-2"><p>确定的输入，一定产生确定的输出。</p><ul class="lvl-2"><li class="lvl-4">在函数调用中，加入输入的参数一致，返回的结果不是能改变的。</li><li class="lvl-4">即不能调用并改变外部变量，如在全局作用域下使用闭包的特性。</li></ul></li><li class="lvl-2"><p>函数在执行过程中，不能产生副作用。</p><ul class="lvl-2"><li class="lvl-4">不能在调用的同时影响外部变量，以影响后续的使用，导致结果的不一致。</li></ul></li></ul><p>副作用：在计算机科学中，副作用表示在执行一个函数的时候，除了返回函数值外，还对调用函数产生了附加的影响，比如修改了全局变量，修改参数或者改变外部的存储。</p><p>如下，获取obj的name属性时，操作了obj，导致后续obj的使用出现了变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;大梦想家&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)  <span class="comment">// &#123;name: &#x27;大梦想家&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure><p><mark>副作用往往是产生bug的温床。</mark></p><h3 id="纯函数的案例">纯函数的案例</h3><ul class="lvl-0"><li class="lvl-2"><p>如数组的slice方法就是个纯函数，因为slice方法不会改变原数组，而是返回一个新的数组。</p></li><li class="lvl-2"><p>而数组的splice方法则会改变原数组，所以splice方法不是纯函数。</p></li></ul><h3 id="纯函数的好处">纯函数的好处</h3><ul class="lvl-0"><li class="lvl-2"><p>可以安心编写和使用，不必担心对外部的影响。</p></li><li class="lvl-2"><p>React中就要求我们无论是函数还是class声明一个组件，这个组件都必须像纯函数一样，保护它们的props不被修改。</p></li></ul></details><h2 id="函数柯里化">函数柯里化</h2><details open>    <summary>        <span>查看</span>    </summary><h3 id="什么是函数柯里化">什么是函数柯里化</h3><ul class="lvl-0"><li class="lvl-2"><p>只传递一部分参数，返回一个函数，用返回的函数去处理剩余的参数，此过程就称为柯里化（Currying）。</p></li><li class="lvl-2"><p>柯里化是一种对函数的转化，不会对函数进行调用。</p></li><li class="lvl-2"><p>柯里化将一个可调用的函数f(a, b, c)转化为可调用的f(a)(b)©。</p></li></ul><h3 id="柯里化优势">柯里化优势</h3><ul class="lvl-0"><li class="lvl-2"><p>函数的职责单一</p><ul class="lvl-2"><li class="lvl-4">在函数式编程中，我们其实往往希望一个函数处理的问题尽可能单一，而不是将一大堆的处理过程交给一个函数来处理。</li><li class="lvl-4">那么我们是否可以将每次传入的参数在单一的函数中处理，处理完后在下一个函数中再使用处理后的结果。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    x += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">        y *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>函数的参数复用</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAdder</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num + count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder5 = <span class="title function_">createAdder</span>(<span class="number">5</span>)</span><br><span class="line"><span class="title function_">adder5</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">adder5</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adder10 = <span class="title function_">createAdder</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">adder10</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">adder10</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="自动柯里化函数">自动柯里化函数</h3><p>将普通函数转换为柯里化函数。</p><p><mark>以下代码仅可在最后一次调用时改变this指向有效。</mark></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">args1, arg2, arg3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args1 + arg2 + arg3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gCurrying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">...args1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args1.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args1)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> currying.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args1, ...args2])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currying</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currying = <span class="title function_">gCurrying</span>(foo)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">currying</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></details><h2 id="组合函数">组合函数</h2><details open>    <summary>        <span>查看</span>    </summary><h3 id="组合函数的概念">组合函数的概念</h3><p>我们需要对一个数据进行操作，需要执行两个以上的函数，而且这两个函数是依次执行的。如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mul</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num ** <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">square</span>(<span class="title function_">mul</span>(<span class="number">4</span>))) <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><h3 id="实现组合函数">实现组合函数</h3><p>组合函数一般是最初的函数接受较多参数，然后将其返回值交予其他函数进行操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length = fns.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    fns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`The <span class="subst">$&#123;index&#125;</span> arguments is not a function`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = fns[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">            result = fns[index].<span class="title function_">call</span>(<span class="variable language_">this</span>, result)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 函数增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS闭包</title>
      <link href="/2025/02/22/JS%E9%97%AD%E5%8C%85/"/>
      <url>/2025/02/22/JS%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="闭包的定义">闭包的定义</h2><details open>    <summary>        <span>展开</span>    </summary><p>MDN中对于JS闭包的解释：</p><img data-src="/2025/02/22/JS%E9%97%AD%E5%8C%85/JS%E9%97%AD%E5%8C%85.png" class="" title="JS闭包"><p>词法环境即为函数定义时所在的作用域，也可以理解为VO。即一个函数，如果可以访问外部作用域的变量，那么该函数和周围环境的组合就是闭包。</p><p>从该定义来看，JS中的函数都具有闭包的特性，都可以称之为闭包。但从严格意义来讲，JS中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。</p></details><h2 id="闭包导致的内存泄露">闭包导致的内存泄露</h2><details open>    <summary>        <span>展开</span>    </summary><p>以如下代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>bar函数与变量a形成了闭包，且通过bar引用了foo函数返回bar函数，在GO中存在bar对foo函数返回bar函数对象的引用，bar函数对象的<code>[[Scopes]]</code>属性又存在对foo函数的AO的引用，根据垃圾回收机制中标记清除算法的处理，bar变量即使以后未被调用，bar函数和foo函数的AO所占据的内存也不会被回收，就造成了内存泄漏。</p><p>所以，对于闭包的内存泄漏，其实就是引用链中的对象无法被释放。</p><p>解决方法：</p><p>手动进行<code>bar = null</code>，手动释放对对象的引用。</p></details><h2 id="常见的垃圾回收机制（GC）算法">常见的垃圾回收机制（GC）算法</h2><details open>    <summary>        <span>展开</span>    </summary><p>垃圾回收机制（Garbage Collection）简称GC。</p><p>对于那些不再使用的对象，我们称之为垃圾，它需要被回收以释放更多的内存空间。</p><p>在JS中，内存管理是自动的、无形的，就是由于GC的存在帮我们自动管理内存。</p><p>常见的GC算法有：</p><ul class="lvl-0"><li class="lvl-2"><p>引用计数法</p><ul class="lvl-2"><li class="lvl-4">每当存在对象的引用时，相应对象引用计数加1，当引用计数为0时，该对象被回收。</li><li class="lvl-4">但容易产生循环引用，即两个对象的属性进行相互引用，形成环形链表，导致内存泄漏（两个引用对象的变量赋值为null，但其属性仍然存在引用，导致对象中的引用计数不为0）。</li></ul></li><li class="lvl-2"><p>标记清除法</p><ul class="lvl-2"><li class="lvl-4">核心思路为<mark>可达性</mark>。</li><li class="lvl-4">需要设置一个根对象（root object），在浏览器中为window，垃圾回收器会定时从根对象出发，找所有从根对象开始有引用的对象，对于没有引用的对象，就认为是不可用的对象，就会被垃圾回收其处理。</li></ul></li><li class="lvl-2"><p>标记整理法</p><ul class="lvl-2"><li class="lvl-4">在标记清除法类似，不同的是，在回收的同时会将保留的对象搬运到连续的内存空间中，整合空闲空间，避免碎片化。</li></ul></li><li class="lvl-2"><p>分代收集法</p></li><li class="lvl-2"><p>增量收集法</p><ul class="lvl-2"><li class="lvl-4">将回收分为几部处理，减少垃圾回收的延迟。</li></ul></li><li class="lvl-2"><p>闲时收集法</p><ul class="lvl-2"><li class="lvl-4">在CPU空闲的时候进行回收。</li></ul></li></ul></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS执行原理</title>
      <link href="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="ECMA5时期与执行原理相关的术语">ECMA5时期与执行原理相关的术语</h2><details open>    <summary>        <span>查看</span>    </summary><p>JS引擎内部有一个执行上下文栈(<code>Execution Context Stack</code>，简称ECS)，它是用于执行代码的调用栈。</p><p>其首先执行的为全局代码块，即<code>Global Execution Context(GEC)</code>全局执行上下文。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/ECS.png" class="" title="ECS"><p>在全局代码块执行前，或者说在parse转为AST过程中，会创建一个GO(Global Object)全局对象，将全局定义的变量、函数等加入到GO中，但此时仅仅为创建，而不是赋值，即此时除了函数和内置对象(String、Data、parseInt等)，GO中的变量值为undefined。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/GO.png" class="" title="GO"><p>每一个执行上下文都会关联一个VO(<code>Variable Object</code>)变量对象，其对应的this和作用域链(<code>scope chain</code>)。</p><p>每当执行一个函数时，会创建一个函数执行上下文(<code>Function Execution Context</code>，简称FEC)加入到ECS中，并在堆内存中创建一个AO(<code>Activation Object</code>)活动对象，该AO会使用arguments作为初始化，初始值为该函数传入的参数形成的伪数组对象，此时VO指向该AO，存储该执行上下文变量的初始化。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/AO.png" class="" title="AO"><p>在全局执行上下文下(即全局代码被执行时)VO就是GO(<code>Global Object</code>)全局对象</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%85%A8%E5%B1%80VO.png" class="" title="全局VO"><p>当一个EC执行完后，会从ECS中弹出，与其VO关联的AO也会通过垃圾回收器清除。</p><p>每一个EC都会对应一个专属的AO，即使是同一个函数。</p><p>当代码被解析时，函数会被创建，但不会被执行，此时函数对象中会存在<code>[[Scopes]]</code>属性，其值为一个列表对象，即为函数该的作用域链(scope chain)，即函数的作用域链在定义的时刻就被创建，与其调用位置无关，与定义位置有关，当函数被调用，其成为FEC加入ECS中时，会创建<code>scope chain</code>，并将函数对象中<code>[[Scopes]]</code>属性的值赋值给FES中的<code>scope chain</code>，当执行过程中遇到属性调用，会先在此FEC关联的VO中查找，查找不到，便会通过<code>scope chain</code>向上查找。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/scope_chain.png" class="" title="scope_chain"></details><h2 id="ECMA5之后与执行原理相关的术语">ECMA5之后与执行原理相关的术语</h2><details open>    <summary>        <span>查看</span>    </summary><p>与ECMA5之前的思路基本相同，只是对于一些词汇的描述发生了改变。</p><p>在新的ECMA代码执行描述中，引入了词法环境（Lexical Environments）的概念。</p><ul class="lvl-0"><li class="lvl-2"><p>一个词法环境是由环境记录（Environment Record，此后称ER）和一个外部词法环境（Outer Lexical Environment，此后称outer）组成。</p></li><li class="lvl-2"><p>一个词法环境经常用于关联函数声明、代码块语句、try-catch语句，当他们代码被执行时，词法环境被创建出来。</p></li></ul><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83.png" class="" title="词法环境"><p>也就是说，当一个执行上下文（EC）加入到ECS中时，会关联对应的词法环境，通常会关联<code>LexicalEnvironment</code>和<code>VariableEnvironment</code>这两个词法环境。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/EC%E5%85%B3%E8%81%94%E7%9A%84%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83.png" class="" title="EC关联的词法环境"><p>通常LexicalEnvironment和VariableEnvironment指向同一个对象，但此要看浏览器怎么实现了。</p><p>LexicalEnvironment通常用于处理ES6新提出的let，const声明的标识符。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/LexicalEnvironment.png" class="" title="LexicalEnvironment"><p>而VariableEnvirable用于处理var和function声明的标识符，与作用域提升有关。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/VariableEnvironment.png" class="" title="VariableEnvironment"><p>对于ER来说，有两种主要的环境记录值：声明式环境记录和对象环境记录。</p><ul class="lvl-0"><li class="lvl-2"><p>声明式环境记录：声明性环境记录用于定义ECMAScript语言语法元素的效果，如函数声明、变量声明和直接将标识符绑定与<br>ECMAScript语言值关联起来的Catch子句。</p></li><li class="lvl-2"><p>对象式环境记录：对象环境记录用于定义ECMAScript元素的效果，例如WithStatement，它将标识符绑定与某些对象的属性关联起来。</p></li></ul><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/ER.png" class="" title="ER"><p>而在新的代码执行描述符中，对于GEC来说，其词法环境中的环境记录指向的并不仅仅式window，而是GER（Global Environment Record）和DER（Decalared Environment Record）的组合，GER指向的便是window，而DER指向的便是存储let，const等的环境记录对象。</p><p>且在ES6中，对于let，const所处的代码块同样存在作用域（块级作用域）。</p><p>总结一下：</p><p>ECMAScript5之后由于引入了块级作用域导致js执行出现了一定的变更，其相关术语也进行了改变，以适应新增变化，以下我对其js执行过程进行阐述，js引擎内部存在ECS（Execute Context Stack执行上下文栈）用于处理js代码的执行，在执行之前，会对代码进行全局解析，为执行代码提供环境，ECS中首先入栈的为GEC（Global Execute Context全局执行上下文），这是js代码执行的开始，在代码解析阶段，GEC中会关联词法环境，词法环境包含LexicalEnvironmnet和VariableEnvironment，最初LexicalEnvironmnet和VariableEnvironment指向同一个环境，一个词法环境由环境记录（Environment Record）和外部词法环境（Outer LexicalEnvironment）组成，环境记录主要分为声明式环境记录（处理let，const，函数声明等）和对象式环境记录（用于全局对象和with函数的情形），外部词法环境理解为作用域即可，在解析全局代码时，如既有var、let、const声明和函数定义，会将var和函数放入到VariableEnvironment的环境中，将let、const声明的属性放入到LexicalEnvironment中，注意，LexicalEnvironmnet和VariableEnvironment指向同一个环境此时仍指向同一个环境，既它们都添加到同一个环境记录上，但是会进行逻辑隔离，在GEC中，var声明的变量和函数会挂载到window上，所以在GEC的词法环境的环境记录中包括声明式环境记录和对象式环境记录，对象式环境记录为全局对象，而声明式环境记录存放let、const声明的变量，此时两者不仅在在逻辑上是隔离的，在物理上也是隔离的，此时由于处于GEC中，所以outer的值便为null，继续执行代码，当遇到函数调用时，会创建一个EC加入到ECS中，此EC的词法环境同样包含LexicalEnvironmnet和VariableEnvironment，他们初始指向的环境仍然相同，解析函数内代码时，发现既存在var、let、const声明和函数定义，仍然会将var和函数放入到VariableEnvironment的环境中，将let、const声明的属性放入到LexicalEnvironment中，但此时LexicalEnvironmnet和VariableEnvironment仍指向同一个环境，且此时是FEC中，此时他们词法环境的环境记录便指向同一个对象（不同的浏览器可能也会进行物理隔离），但进行逻辑隔离，此时outer指向为GEC的词法环境，如果执行过程中发现代码块（并不会创建一个新的执行上下文，执行上下文核心包括LexicalEnvironmnet、VariableEnvironment和this绑定，块级作用域中既无VariableEnvironment也无this），代码块中仍存在var、let、const声明，由于var并不存在块级作用域，所以var声明的变量会放到VariableEnvironment中，但对于let、const，会将FEC的LexicalEnvironmnet指向一个新的环境，然后将其变量放到新的环境的环境记录中，此时LexicalEnvironmnet和VariableEnvironment指向不同的环境，而此时新的词法环境中的outer便指向之前的LexicalEnvironmnet，以便形成作用域链，当代码块中的代码执行完，便将FEC的LexicalEnvironmnet重新指向原来的环境，以此类推，直至代码执行完毕。</p></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器基本原理</title>
      <link href="/2025/02/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2025/02/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="浏览器输入URL到页面展示过程">浏览器输入URL到页面展示过程</h2><details open>   <summary>      <span>查看</span>   </summary><ol><li class="lvl-3"><p>输入URL并解析</p><ul class="lvl-2"><li class="lvl-5">检查输入内容是否为关键字(自动补全或跳转搜索引擎或进入浏览器设置页面)</li><li class="lvl-5">对URL进行合法性检查和格式化</li></ul></li><li class="lvl-3"><p>域名解析: 域名解析器(DNS: domain name system)将域名解析为IP地址, 浏览器通过IP地址访问服务器。</p></li><li class="lvl-3"><p>建立TCP连接(三次握手), 确保客户端与服务端双向通信能力。</p></li><li class="lvl-3"><p>发起HTTP/HTTPS请求。</p></li><li class="lvl-3"><p>服务器处理请求并返回响应。</p></li><li class="lvl-3"><p>浏览器解析与渲染。</p></li><li class="lvl-3"><p>加载动态资源与交互。</p></li><li class="lvl-3"><p>连接终止: TCP四次挥手。</p></li></ol></details><h2 id="浏览器渲染页面的的流程">浏览器渲染页面的的流程</h2><details open>   <summary>      <span>查看</span>   </summary><p>从服务器获取到资源后</p><ol><li class="lvl-3"><p>创建DOM树: 解析HTML标签, 创建DOM树。</p></li><li class="lvl-3"><p>创建CSSOM树: 解析CSS样式, 创建CSSOM树。</p><ol><li class="lvl-6">当解析过程中发现存在link标签引用CSS文件时, 浏览器会向服务器请求CSS文件。</li><li class="lvl-6">对外部CSS资源的下载解析会交给其他进程处理, 并不会阻塞DOM树的解析。</li></ol></li><li class="lvl-3"><p>生成渲染树: 将DOM树和CSSOM树合并, 生成渲染树(rander tree)。</p><ol><li class="lvl-6">在此过程中, 渲染树的并不会存在每个节点的尺寸和位置信息。</li><li class="lvl-6">对于渲染树, 可能存在等待CSSOM树解析完毕倒是渲染树生成的不及时的情况。针对这一点, 浏览器可能会对其进行一些优化操作。</li></ol></li><li class="lvl-3"><p>布局(layout): 计算渲染树中每个节点的几何信息, 如宽高、位置等。</p></li><li class="lvl-3"><p>绘制(paint): 生成绘制指令列表，描述元素的绘制顺序和方式。</p><ol><li class="lvl-6">绘制是逻辑操作，不直接操作像素。</li></ol></li><li class="lvl-3"><p>分块：既将页面或合成层划分成多个小块，进行独立光栅化和更新。</p><ol><li class="lvl-6">分块不是浏览器必须的，而是一种优化手段。</li><li class="lvl-6">通过分块可以实现仅更新视口可见区域或既将进入视口的块。</li><li class="lvl-6">由于可能存在多个合成层，所以可以将多个合成层划分的小块交予其他线程处理。</li><li class="lvl-6">由于非可见区域的块可以延迟处理或降级质量，节省了内存。</li></ol></li><li class="lvl-3"><p>光栅化：将渲染树中的矢量图形转为屏幕上的像素矩阵。</p><ol><li class="lvl-6">光栅化这一块是浏览器必须的。</li><li class="lvl-6">光栅化可以调用GPU加速页面的绘制。</li></ol></li><li class="lvl-3"><p>合成：将光栅化期间的像素矩阵交由合成线程进行合并。</p></li><li class="lvl-3"><p>显示: 画到屏幕上。</p></li></ol></details><h2 id="回流-reflow-和重绘-repaint">回流(reflow)和重绘(repaint)</h2><details open>   <summary>      <span>查看</span>   </summary><h3 id="回流-reflow">回流(reflow)</h3><ul class="lvl-0"><li class="lvl-2"><p>第一次确定节点的大小和位置, 称为布局。</p></li><li class="lvl-2"><p>之后对节点的大小和位置的修改, 称为回流(重排)。</p></li></ul><h4 id="回流-reflow-的触发方式">回流(reflow)的触发方式</h4><ul class="lvl-0"><li class="lvl-2"><p>DOM结构发生改变(添加或移除的节点)。</p></li><li class="lvl-2"><p>改变布局(修改元素的宽度、高度、位置、边框、margin、padding、字体大小等)</p></li><li class="lvl-2"><p>修改了窗口尺寸(resize)</p></li><li class="lvl-2"><p>查询元素的尺寸和位置信息(offsetWidth、offsetHeight、offsetLeft、offsetTopget、getComputedStyle等)</p></li></ul><h3 id="重绘-repaint">重绘(repaint)</h3><ul class="lvl-0"><li class="lvl-2"><p>第一次渲染称之为绘制(paint)。</p></li><li class="lvl-2"><p>之后重新渲染, 称为重绘。</p></li></ul><h4 id="重绘-repaint-的触发方式">重绘(repaint)的触发方式</h4><ul class="lvl-0"><li class="lvl-2"><p>修改了元素的背景色、边框颜色、字体颜色等。</p></li></ul><p><mark>回流一定会导致重绘</mark></p><p>回流是一件很耗性能的事情, 所以尽量避免。</p><p>建议:</p><ul class="lvl-0"><li class="lvl-2"><p>修改样式时尽量一次性修改。</p><ul class="lvl-2"><li class="lvl-4">比如通过cssText或添加class修改。</li></ul></li><li class="lvl-2"><p>尽量避免频繁的操作DOM。</p><ul class="lvl-2"><li class="lvl-4">比如通过DocumentFragment批量操作DOM或在父元素中将要操作的DOM操作完成,再一次性的操作。</li></ul></li><li class="lvl-2"><p>尽量避免通过getComputedStyle获取尺寸位置等信息。</p></li><li class="lvl-2"><p>对某些元素使用position的absolute或fixed。</p><ul class="lvl-2"><li class="lvl-4">其同样会造成回流, 但开销相对较小, 不会对其他元素产生影响。</li></ul></li></ul></details><h2 id="script标签的defer和async属性">script标签的defer和async属性</h2><details open>   <summary>      <span>查看</span>   </summary><h3 id="defer">defer</h3><ul class="lvl-0"><li class="lvl-2"><p>defer属性会告诉浏览器不用等待脚本下载, 而是继续解析HTML, 构建DOM Tree。</p><ul class="lvl-2"><li class="lvl-4">脚本由浏览器来进行下载, 但不会阻塞DOM Tree的构建过程。</li><li class="lvl-4">如果脚本提前下载好, 他会等待DOM Tree的构建完成, 在DOMContentLoaded事件之前执行。</li><li class="lvl-4">所以DOMContentLoaded总是会等待defer中的代码先执行完成。</li></ul></li><li class="lvl-2"><p>对于多个defer的脚本, 浏览器会按照脚本的先后顺序执行。</p></li><li class="lvl-2"><p>由于设置defer后, 并不会阻塞DOM树的构建, 并且会交与浏览器对其下载, 所以推荐将设置defer的脚本放在head中, 减少其因下载损耗的事件, 一定程度上可以提高页面的性能。</p></li></ul><p><mark>注意: defer仅适用于外部脚本, 对于script默认内容会被忽略。</mark></p><h3 id="async">async</h3><ul class="lvl-0"><li class="lvl-2"><p>async是一个让脚本完全独立的:</p><ul class="lvl-2"><li class="lvl-4">浏览器不会因async脚本而阻塞。</li><li class="lvl-4">async脚本不能保证顺序, 它是独立下载, 独立运行, 不会等待其他脚本。</li><li class="lvl-4">async不能保证在DOMContentLoaded之前或之后执行。</li></ul></li></ul><h3 id="defer和async的使用场景">defer和async的使用场景</h3><ul class="lvl-0"><li class="lvl-2"><p>defer通常用于需要文档解析后操作DOM的JS代码, 并且对多个JS文件有顺序要求.</p></li><li class="lvl-2"><p>async通常用于独立的脚本, 对其他脚本, 甚至没有DOM依赖的。</p></li></ul></details>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点记录(个人理解)</title>
      <link href="/2024/11/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
      <url>/2024/11/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="字符实体">字符实体</h2><p>字符实体即 html 中 <code>&amp;nbsp;</code> 这类的写法，以 <code>&amp;</code> 开始，以 <code>;</code> 结束。</p><p>出现原因：</p><blockquote><p>由于浏览器的识别和解析等原因，对于 <code>&lt;</code> 和 空格，换行的解析是有问题或合并操作的，但我们想要把其展示出来，就需要用到字符实体来编写了</p></blockquote><p>常见字符实体</p><img data-src="/2024/11/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93.png" class="" title="常见字符实体"><h2 id="URL-和-URI">URL 和 URI</h2><ul class="lvl-0"><li class="lvl-2"><p>URL = Uniform Resource Locator 为统一资源定位符，通常用于网络资源</p></li><li class="lvl-2"><p>URI = Uniform Resource Identifier 为统一资源标识符，可以标识逻辑和物理设备</p></li><li class="lvl-2"><p>URL 是 URI 的子集，即 URL 一定是 URI，但 URI 不一定是URL</p></li><li class="lvl-2"><p>比如当后端服务写一个接口后，前端可以通过浏览器访问该接口并得到返回值，这是URL</p></li><li class="lvl-2"><p>但服务器内部，可以得到某一图片等资源，即图片等资源会有一个标识交给服务器，服务器可以通过该标识访问到该资源，甚至是物理设备，这期间不一定有 WEB 的参与，这是URI</p></li></ul><p>URL 的完整标准格式：</p><blockquote><p><code>[协议类型]://[服务器地址]:[端口号]/[文件路径][文件名]?[查询]#[片段ID]</code><br>scheme://userinfo@host:port/path?query#fragment</p></blockquote><p>如： <code>https://zrb@www.example.com:123/forum/questions/tag=networking&amp;order=newest#top</code></p><h2 id="元素语义化的好处">元素语义化的好处</h2><ul class="lvl-0"><li class="lvl-2"><p>方便维护，方便阅读</p></li><li class="lvl-2"><p>减少开发人员沟通</p></li><li class="lvl-2"><p>无障碍阅读，如对于盲人来说，浏览器会根据语义化标签选择语言表达方式，对于strong标签会进行重读</p></li><li class="lvl-2"><p>有利于SEO</p><ul class="lvl-2"><li class="lvl-4">浏览器搜索引擎有一定的规范，其利用爬虫技术对网页（文档）进行获取</li><li class="lvl-4">浏览器会根据其规则判断是否收录该网站并对其进行索引排名，语义化标签符合其中的部分规范，其排名也会较为靠前</li><li class="lvl-4">当用户搜索信息是，浏览器就会根据其排名展示（除去广告），我们得以免费获取流量</li></ul></li></ul><h2 id="字符编码">字符编码</h2><p>对于计算机来说只能识别 0 和 1，但我们所写的内容怎样编码交给计算机，计算机又怎样解码以展示给我们，所以我们需要一定的规范将其编码为二进制（01），并使计算机能根据此规范将二进制（01）解码展示我们所写的内容。</p><p>目前基本上使用的是 UTF-8 ，依靠 unicode 字符集（万国码）。</p><h2 id="DNS解析">DNS解析</h2><p>浏览器通过域名获取资源时, 不会直接连接到服务器, 而是通过域名服务器（DNS）, DNS服务器会解析域名, 找到对应的IP地址, 并返回给浏览器, 浏览器再通过IP地址访问服务器。</p><p>域名的解析这一过程也是需要时间的, 我们可以尝试预解析域名, 以提高获取资源时的访问速度</p><p>可以通过对link标签设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch">dns-prefetch</a> 来进行优化, 如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://fonts.googleapis.com/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Number-prototype-toString-base-和-Number-prototype-toFixed-digits">Number.prototype.toString(base) 和 Number.prototype.toFixed(digits)</h2><p><code>toString(base)</code> 用于将数字转为字符串, 并且根据 base 值的不同可以将数字转为对应的进制, base 的范围为 2 到 36, 默认为 10<br><code>toFixed(digits)</code> 用于将数字转为字符串, 并且保留 digits 位小数, digits 的值为 0 到 20, 默认为 0</p><h2 id="with语句">with语句</h2><details open>    <summary>        <span>查看</span>    </summary><p>with语句会扩展一个语句的作用域链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;大梦想家&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">with</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// 大梦想家</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不建议使用with语句，因为它可能是混淆错误和兼容性问题的根源。</p></details><h2 id="eval函数">eval函数</h2><details open>    <summary>        <span>查看</span>    </summary><p>内建函数 eval 允许执行一个代码字符串。</p><ul class="lvl-0"><li class="lvl-2"><p>eval是一个特殊的函数，它可以将传入的字符串当做JavaScript代码来运行。</p></li><li class="lvl-2"><p>eval会将最后一句执行语句的结果，作为返回值。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="built_in">eval</span>(<span class="string">&quot;var message = &#x27;hello world&#x27;; 1111&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 1111</span></span><br></pre></td></tr></table></figure><p>不建议在开发中使用eval：</p><ul class="lvl-0"><li class="lvl-2"><p>eval代码的可读性非常的差（代码的可读性是高质量代码的重要原则）；</p></li><li class="lvl-2"><p>eval是一个字符串，那么有可能在执行的过程中被刻意篡改，那么可能会造成被攻击的风险；</p></li><li class="lvl-2"><p>eval的执行必须经过JavaScript解释器，不能被JavaScript引擎优化；</p></li></ul></details><h2 id="严格模式">严格模式</h2><details open>    <summary>        <span>查看</span>    </summary><p>由于JS一直保持着兼容旧代码的方向，但旧代码的问题也被继承下来了，在ECMA5标准中，JS提出了严格模式的概念，以更加严格的方式对代码进行检测和运行。</p><p>严格模式对正常的JavaScript语义进行了一些限制：</p><ul class="lvl-0"><li class="lvl-2"><p>严格模式通过 抛出错误 来消除一些原有的 静默（silent）错误。（比如对对象属性设置仅可读权限，对其进行修改操作时会抛出错误）</p></li><li class="lvl-2"><p>严格模式让JS引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）。（如 <code>a = 1</code>，未用关键进行声明）</p></li><li class="lvl-2"><p>严格模式禁用了在ECMAScript未来版本中可能会定义的一些语法。</p></li></ul><h3 id="开启严格模式">开启严格模式</h3><p>严格模式通过在文件或者函数开头使用 use strict 来开启，可以实现对文件或单个函数的严格模式设置。</p><h3 id="严格模式的限制">严格模式的限制</h3><ul class="lvl-0"><li class="lvl-2"><p>无法意外的创建全局变量。（如 <code>a = 1</code>，未用关键进行声明）</p></li><li class="lvl-2"><p>严格模式会使引起静默失败(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常。</p></li><li class="lvl-2"><p>严格模式下，不能使用 with 语句。</p></li><li class="lvl-2"><p>严格模式下，试图删除不可删除的属性会抛出错误。</p></li><li class="lvl-2"><p>严格模式下，函数参数不能存在相同名字。</p></li><li class="lvl-2"><p>严格模式下，不允许0的8进制语法。（如0221）。</p></li><li class="lvl-2"><p>严格模式下，eval中的变量不能被外部使用。</p></li><li class="lvl-2"><p>严格模式下，this绑定不会默认转为对象。</p><ul class="lvl-2"><li class="lvl-4">null和undefiend默认绑定不会指向window，而是其本身。</li><li class="lvl-4">除了null和undefiend的基本数据类型，不会指向其默认的包装对象，而是其字面量值。</li></ul></li></ul></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp和taro学习知识点记录</title>
      <link href="/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="uniapp"><a href="https://uniapp.dcloud.net.cn/quickstart.html">uniapp</a></h2><ol><li class="lvl-3"><p>代码编写规范</p> <img data-src="/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/uniapp.png" class="" title="代码编写规范"></li><li class="lvl-3"><p>App.vue文件定义全局数据和公共样式</p></li><li class="lvl-3"><p>uni.scss文件定义全局变量</p><ul class="lvl-2"><li class="lvl-5">自定义全局变量</li><li class="lvl-5">覆盖 uni-app 内置全局变量</li><li class="lvl-5">覆盖 uni-ui 样式</li></ul></li><li class="lvl-3"><p><code>onLoad()&#123;&#125;</code> 为页面的生命周期函数</p></li><li class="lvl-3"><p>获取全局数据</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">getApp</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">globalData</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>获取当前路由</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pages = <span class="title function_">getCurrentPages</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pages)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>常用内置组件</p><ul class="lvl-2"><li class="lvl-5"><code>view</code>: 视图容器,类似于传统 html 中的 div (uniapp 可以使用 div,但 div 不跨平台,需要经过转译)</li><li class="lvl-5"><code>text</code>: 文本组件,用于包裹文本内容</li><li class="lvl-5"><code>button</code>: 按钮组件,但在小程序端的主题和其他端的主题不一样(可以通过条件编译来统一风格)</li><li class="lvl-5"><code>image</code>: 图片组件,默认宽度 320px,高度 240px,支持:<ul class="lvl-4"><li class="lvl-7">相对路径</li><li class="lvl-7">绝对路径</li><li class="lvl-7">导入</li><li class="lvl-7">base64码</li></ul></li><li class="lvl-5"><code>scroll-view</code>: 滚动容器,可设置横向或纵向滚动(scroll-y/x 必须存在,且容器要有高度/宽度)</li><li class="lvl-5"><code>swiper</code>: 轮播图组件</li></ul></li><li class="lvl-3"><p>路由跳转</p><ul class="lvl-2"><li class="lvl-6">navigate<ul class="lvl-4"><li class="lvl-8">保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。</li><li class="lvl-8">url: 需要跳转的应用内非 tabBar 的页面的路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’，path为下一个页面的路径，下一个页面的onLoad函数可得到传递的参数</li></ul></li><li class="lvl-6">redirect<ul class="lvl-4"><li class="lvl-8">关闭当前页面，跳转到应用内的某个页面。</li><li class="lvl-8">url: 需要跳转的应用内非 tabBar 的页面的路径，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’</li></ul></li><li class="lvl-6">switchTab<ul class="lvl-4"><li class="lvl-8">跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</li><li class="lvl-8">url: 需要跳转的 tabBar 页面的路径（需在 pages.json 的 tabBar 字段定义的页面），路径后不能带参数</li></ul></li></ul></li><li class="lvl-3"><p>常见通信方式</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>url查询字符串和<code>EventChannel</code></p><ul class="lvl-2"><li class="lvl-4"><p>通过查询字符串方式传递的参数获取方式,如: <code>/pages/index/index?id=1&amp;name=2</code></p><ul class="lvl-4"><li class="lvl-6">在<code>onLoad</code>页面生命周期中获取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(options) <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;2&#x27;&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-4"><li class="lvl-6"><p>通过<code>props</code>获取</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;2&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li class="lvl-4"><p><code>EventChannel</code></p><ul class="lvl-4"><li class="lvl-6">Options 语法: <code>this.getOpenerEventChannel()</code></li><li class="lvl-6">Composition 语法: <code>getCurrentInstance().proxy.getOpenerEventChannel()</code></li></ul></li></ul></li><li class="lvl-2"><p>使用事件总线</p><ul class="lvl-2"><li class="lvl-4">uni.$emit(eventName,object): 触发全局的自定义事件</li><li class="lvl-4">uni.$on(eventName,callback): 监听全局的自定义事件,由 uni.$emit 触发</li><li class="lvl-4">uni.$off(eventName,callback): 移除全局的自定义事件监听器</li><li class="lvl-4">uni.$once(eventName,callback): 监听一个自定义事件，只能触发一次</li></ul></li><li class="lvl-2"><p>全局数据 <code>globalData</code></p><ul class="lvl-2"><li class="lvl-4">在<code>App.vue</code>中定义全局数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">globalData</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;big-dreamer&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>在其他页面中获取全局数据</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">getApp</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">globalData</span>); <span class="comment">// &#123;name: &#x27;big-dreamer&#x27;, age: 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>本地数据存储</p><ul class="lvl-2"><li class="lvl-4"><code>uni.setStorage(OBJECT)</code>: 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。</li><li class="lvl-4"><code>uni.setStorageSync(KEY, DATA)</code>: 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。</li><li class="lvl-4"><code>uni.getStorage(OBJECT)</code>: 从本地缓存中异步获取指定 key 对应的内容。</li><li class="lvl-4"><code>uni.getStorageSync(KEY)</code>: 从本地缓存中同步获取指定 key 对应的内容。</li><li class="lvl-4"><code>uni.removeStorage(OBJECT)</code>: 从本地缓存中异步移除指定 key。</li><li class="lvl-4"><code>uni.removeStorageSync(KEY)</code>: 从本地缓存中同步移除指定 key。</li></ul></li><li class="lvl-2"><p><code>Vuex</code> 和 <code>Pinia</code>,状态管理库</p><ul class="lvl-2"><li class="lvl-4"><code>Pinia</code> 在main.js中注册</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Pinia</span> <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">createSSRApp</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">createSSRApp</span>(<span class="title class_">App</span>)</span><br><span class="line">  app.<span class="title function_">use</span>(<span class="title class_">Pinia</span>.<span class="title function_">createPinia</span>())</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app,</span><br><span class="line">    <span class="title class_">Pinia</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>创建store</p></li><li class="lvl-4"><p>使用</p></li></ul></li></ul><h2 id="taro"><a href="https://docs.taro.zone/docs/">taro</a></h2><p>建议使用 taro 开发小程序,其对于 h5 和 APP 的多端兼容不太好</p><h3 id="开始使用-taro">开始使用 taro</h3><ol><li class="lvl-3"><p>安装 CLI</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @tarojs/cli</span><br><span class="line">或</span><br><span class="line">yarn global add @tarojs/cli</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>创建项目</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taro init myApp</span><br><span class="line">或</span><br><span class="line">npx @tarojs/cli init myApp</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>启动项目</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>启动小程序 <code>npm run dev:weapp</code></p></li><li class="lvl-2"><p>启动 H5 端 <code>npm run dev:h5</code></p></li></ul><h3 id="知识点记录">知识点记录</h3><ol><li class="lvl-3"><p>Taro + React 开发规范</p> <img data-src="/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/taro.png" class="" title="Taro + React 开发规范"></li><li class="lvl-3"><p>新建页面 <code>Taro create --name [页面名称]</code></p></li><li class="lvl-3"><p>通信方式</p><ul class="lvl-2"><li class="lvl-5"><p>url查询字符串和只支持小程序端的 <code>EventChannel</code></p><ul class="lvl-4"><li class="lvl-7">通过查询字符串方式传递的参数获取方式,如: <code>/pages/index/index?id=1&amp;name=2</code></li><li class="lvl-7">通过 <code>onLoad</code>,<code>useLoad</code> 生命周期获取路由参数</li><li class="lvl-7">通过 <code>Taro.getCurrentInstance().router.params</code> 获取</li><li class="lvl-7">EventChannel 和 uniapp 语法相似,把 uniapp 换为 Taro</li></ul></li><li class="lvl-5"><p>使用全局事件总线 <code>Taro.eventCenter</code></p><ul class="lvl-4"><li class="lvl-7"><code>Taro.eventCenter.on(eventName,function)</code>: 监听事件</li><li class="lvl-7"><code>Taro.eventCenter.trigger(eventName,object)</code>: 触发全局的自定义事件</li><li class="lvl-7"><code>Taro.eventCenter.trigger(eventName,object)</code>: 取消监听事件</li></ul></li></ul></li><li class="lvl-3"><p>跨端兼容方案</p><ul class="lvl-2"><li class="lvl-7">内置环境变量 <code>process.env.TARO_ENV</code>,通过 if 对其值进行判断</li><li class="lvl-7">统一接口的多端文件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 多端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
            <tag> taro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React常用技术栈</title>
      <link href="/2024/11/08/React%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2024/11/08/React%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="创建项目环境">创建项目环境</h2><h3 id="创建项目">创建项目</h3><h4 id="Create-React-App-CRA"><a href="https://create-react-app.bootcss.com/">Create-React-App (CRA)</a></h4><ul class="lvl-0"><li class="lvl-2"><p>使用了 Webpack、Babel、ESLint 和其他优秀的项目作为基础层</p></li><li class="lvl-2"><p>创建项目命令</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><h4 id="Vite"><a href="https://cn.vitejs.dev/">Vite</a></h4><ul class="lvl-0"><li class="lvl-2"><p>创建项目命令</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest my-app -- --template react</span><br></pre></td></tr></table></figure><h4 id="Next-js"><a href="https://www.nextjs.cn/">Next.js</a></h4><p>介绍</p><blockquote><p>Next.js 为您提供生产环境所需的所有功能以及最佳的开发体验：包括静态及服务器端融合渲染、 支持 TypeScript、智能化打包、 路由预取等功能 无需任何配置。</p><p>适用于简单的<mark>C端</mark>应用</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>创建项目命令</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest</span><br><span class="line"># or</span><br><span class="line">yarn create next-app</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建 TS 项目</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest --typescript</span><br><span class="line"># or</span><br><span class="line">yarn create next-app --typescript</span><br></pre></td></tr></table></figure><h3 id="代码规范">代码规范</h3><h4 id="ESLint"><a href="https://zh-hans.eslint.org/docs/latest/use/getting-started">ESLint</a></h4><p>介绍</p><blockquote><p>ESLint 是一个根据方案识别并报告 ECMAScript/JavaScript 代码问题的工具，其目的是使代码风格更加一致并避免错误</p></blockquote><h4 id="Prettier"><a href="https://www.prettier.cn/">Prettier</a></h4><p>介绍</p><blockquote><p>Prettier 是一款代码格式化工具，可以将项目代码格式统一化,并且美化代码</p></blockquote><h4 id="Husky"><a href="https://husky.nodejs.cn/get-started.html">Husky</a></h4><p>介绍</p><blockquote><p>Husky 是一个 Git Hooks 工具，它允许您在 Git 提交之前运行脚本，在提交或推送时自动检查你的提交消息、代码并运行测试。</p></blockquote><h4 id="commit-lint"><a href="https://commitlint.js.org/">commit-lint</a></h4><p>介绍</p><blockquote><p>commitlint 是一个 git commit 校验约束工具。</p></blockquote><h3 id="扩展配置">扩展配置</h3><h4 id="craco-js"><a href="https://craco.js.org/">craco.js</a></h4><p>介绍</p><blockquote><p>由于 CRA 的配置是被隐藏的,我们不应把它显示出来并对其进行修改,于是出现了 craco.js<br>通过 craco，开发者可以使用自定义覆盖原先配置，以满足项目的特定需求。例如：可以添加自定义 webpack 的 loader，plugin，修改 webpack 的输出路径等。</p></blockquote><h2 id="React-基础">React 基础</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn#writing-markup-with-jsx">JSX 语法</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn#components">函数组件</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn/passing-props-to-a-component">props</a></p></li><li class="lvl-2"><p><a href="https://www.tslang.cn/">typescript</a></p></li><li class="lvl-2"><p><a href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?utm_source=ext_app_menu">开发者工具(React Developer Tools)</a></p></li></ul><h2 id="Hooks">Hooks</h2><h3 id="必备">必备</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useState">useState</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useEffect">useEffect</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useRef">useRef</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component">自定义 Hook</a></p></li></ul><h3 id="了解">了解</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useMemo">useMemo</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useCallback">useCallback</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useContext">useContext</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useReducer">useReducer</a><br>…</p></li></ul><h3 id="Hooks-规则">Hooks 规则</h3><ul class="lvl-0"><li class="lvl-2"><p>必须用 useXxx 格式来命名</p></li><li class="lvl-2"><p>只能在 <mark>组件内</mark> 和 <mark>其他Hook</mark> 中调用 Hook</p></li><li class="lvl-2"><p>必须保证每次的调用顺序一致 (不能放在 if/for 中)</p></li></ul><h3 id="hooks-库">hooks 库</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://ahooks.js.org/zh-CN/">ahooks</a></p><ul class="lvl-2"><li class="lvl-4">国内</li><li class="lvl-4">推荐</li></ul></li><li class="lvl-2"><p><a href="https://www.reactuse.com/zh-Hans/category/state">react-use</a></p></li></ul><h2 id="CSS-样式">CSS 样式</h2><h3 id="普通-CSS">普通 CSS</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS 样式指南</a></p><h3 id="CSS-Module">CSS-Module</h3><ul class="lvl-0"><li class="lvl-2"><p>CRA 内置,样式文件命名未<code>xxx.module.css</code></p></li><li class="lvl-2"><p>在 tsx 中通过 <code>import xxx from './xxx.module.css</code> 方式引入</p></li><li class="lvl-2"><p>在组件中通过 <code>className=&#123;xxx.xxx&#125;</code> 引入</p></li><li class="lvl-2"><p>样式名会自动添加前缀，避免样式冲突</p></li></ul><h3 id="CSS-in-JS">CSS-in-JS</h3><blockquote><p>最初网页开发有一个原则,叫做 <a href="https://en.wikipedia.org/wiki/Separation_of_concerns#HTML,_CSS,_JavaScript">关注点分离</a>,但 React 出现后,这个原则便不再使用了,因为 React 的组件化设计已经将关注点分离了,组件的样式应该与组件本身一起放在一起,而不是通过 CSS 文件来引入。</p></blockquote><p>在思想上 CSS in JS 和 JSX 差不多，简单来说，就是在 JS 环境中写 CSS 相关的样式</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://styled-components.com/">styled-components</a></p></li><li class="lvl-2"><p><a href="https://github.com/vercel/styled-jsx">styled-jsx</a></p></li><li class="lvl-2"><p><a href="https://emotion.sh/docs/introduction">emotion</a></p></li></ul><p>优点:</p><ul class="lvl-0"><li class="lvl-2"><p>用 js 写,有逻辑有变量,非常灵活</p></li></ul><p>缺点:</p><ul class="lvl-0"><li class="lvl-2"><p>JSX 和样式代码混在一块,代码较多,增加了编译成本</p></li></ul><h3 id="classnames"><a href="https://www.npmjs.com/package/classnames">classnames</a></h3><p>介绍</p><blockquote><p>classnames用于动态添加类名</p></blockquote><h2 id="路由">路由</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://reactrouter.com/en/main">React-Router</a></p></li><li class="lvl-2"><p>路由嵌套和 <a href="https://reactrouter.com/en/main/components/outlet#outlet">Outlet</a></p></li><li class="lvl-2"><p>动态路由</p></li><li class="lvl-2"><p>页面跳转</p></li><li class="lvl-2"><p>获取参数</p></li></ul><h2 id="UI-组件库">UI 组件库</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://ant.design/components/overview-cn/">Ant Design</a>(国内)</p></li><li class="lvl-2"><p><a href="https://mui.com/material-ui/">Material-UI</a>(国外)</p></li><li class="lvl-2"><p><a href="https://www.tailwindcss.cn/">Tailwind CSS</a>(补充)</p></li></ul><h2 id="表单组件">表单组件</h2><ul class="lvl-0"><li class="lvl-2"><p>受控组件</p></li></ul><blockquote><p>受控组件是指在 React 中，表单元素的值由 React 组件的 state 管理的组件。这意味着表单元素的值是由 React 组件的状态决定的，而不是由 DOM 本身决定的。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><a href="https://ant.design/components/form-cn#form-demo-nest-messages">AntDesign-Form-rules</a></p></li><li class="lvl-2"><p><a href="https://react-hook-form.com/get-started#SchemaValidation">React-hook-form</a></p></li><li class="lvl-2"><p><a href="https://formik.nodejs.cn/docs/guides/form-submission#e9aa8ce8af81">Formik</a></p></li></ul><h2 id="Ajax-网络请求">Ajax 网络请求</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></p></li><li class="lvl-2"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">Fetch</a></p></li><li class="lvl-2"><p><a href="https://www.axios-http.cn/">Axios</a></p></li><li class="lvl-2"><p><a href="https://ahooks.js.org/zh-CN/guide/upgrade#%E5%85%A8%E6%96%B0%E7%9A%84-userequest">useRequest (ahooks)</a></p></li><li class="lvl-2"><p><a href="http://mockjs.com/">Mock.js</a></p></li><li class="lvl-2"><p><a href="https://www.postman.com/">Postman (接口调试工具)</a></p></li><li class="lvl-2"><p><a href="https://javaguide.cn/system-design/basis/RESTfulAPI.html">Restful API</a></p></li><li class="lvl-2"><p><a href="https://jwt.io/">JWT</a> 用户校验</p></li></ul><h2 id="状态管理">状态管理</h2><ul class="lvl-0"><li class="lvl-2"><p>状态提升</p></li></ul><blockquote><p>状态提升是指将多个组件中需要共享的状态提升到它们的最近共同父组件中进行管理。这样可以确保这些组件能够访问和修改相同的状态，从而实现数据的同步和共享。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useContext">useContext</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useReducer">useReducer</a></p></li><li class="lvl-2"><p><a href="https://cn.redux.js.org/">Redux</a></p></li><li class="lvl-2"><p><a href="https://cn.mobx.js.org/">Mobx</a></p></li><li class="lvl-2"><p><a href="https://immerjs.github.io/immer/zh-CN/">Immer</a></p></li></ul><blockquote><p>Immer 是一个用于简化不可变数据操作的 JavaScript 库。它允许你在不可变数据结构上进行可变操作，同时自动产生新的不可变数据结构。这使得编写不可变数据管理的代码变得更加简单和直观</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><a href="https://redux-undo.js.org/">Redux-undo</a>: Redux State Container 的简单撤消/重做功能</p></li></ul><h2 id="拖拽排序">拖拽排序</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://react-dnd-cn.js.org/">React-dnd</a></p></li><li class="lvl-2"><p><a href="https://www.npmjs.com/package/react-beautiful-dnd">React-beautiful-dnd</a></p></li><li class="lvl-2"><p><a href="https://www.itxst.com/sortablejs/neuinffi.html">Sortable.js</a></p></li><li class="lvl-2"><p><a href="https://www.npmjs.com/package/react-sortable-hoc">React-sortable-hoc</a></p></li><li class="lvl-2"><p><a href="https://dndkit.com/">dnd-kit</a>(推荐)</p></li></ul><h2 id="可视化图表">可视化图表</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.npmjs.com/package/react-chartjs-2">react-chartjs-2</a></p></li><li class="lvl-2"><p><a href="https://recharts.org/en-US/">Recharts</a></p></li><li class="lvl-2"><p><a href="https://www.npmjs.com/package/echarts-for-react">echarts-for-react</a></p></li></ul><h2 id="性能优化">性能优化</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useMemo">useMemo</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useCallback">useCallback</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/memo">React.memo</a></p></li><li class="lvl-2"><p><a href="https://create-react-app.dev/docs/analyzing-the-bundle-size/">analyzing-the-bundle-size</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/lazy">lazy 路由懒加载</a></p></li><li class="lvl-2"><p>抽离公共代码进行缓存(craco 中配置,webpackConfig.optimization.splitChunks)</p></li></ul><h2 id="测试">测试</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.jestjs.cn/">jest</a></p></li><li class="lvl-2"><p><a href="https://testing-library.com/docs/react-testing-library/intro">React-Testing-Library</a></p></li><li class="lvl-2"><p>pre-commit 自动化测试</p></li><li class="lvl-2"><p><a href="https://storybook.nodejs.cn/">storybook</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React18 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="/2024/10/24/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/10/24/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul class="lvl-0"><li class="lvl-2"><p>拷贝就是创建一个已有对象或数据结构的副本的过程，即拷贝是相对于引用类型而言的。</p></li><li class="lvl-2"><p>对于 JS 来说，浅拷贝仅复制对象的第一层属性，对于其对象属性，复制的是其存储的地址值。因此，通过浅拷贝得到的副本，修改其内部的对象属性，也会影响原对象。</p></li><li class="lvl-2"><p>深拷贝会复制对象的所有属性，包括第一层中的对象属性，即对象属性会在堆区开辟新的空间（新的地址值）,其存储值与被拷贝的内容相同，因此，通过深拷贝得到的副本，修改其内部的对象属性，不会影响原对象。</p></li></ul><span id="more"></span><h2 id="浅拷贝的实现">浅拷贝的实现</h2><h3 id="1-使用-Object-assign">1. 使用 <code>Object.assign()</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign()</a> 静态方法将一个或者多个源对象中所有<mark>可枚举的自有属性</mark>复制到目标对象，并返回修改后的目标对象。</p><p>语法</p><blockquote><p>Object.assign(target, …sources)</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>target：需要应用源对象属性的目标对象，修改后将作为返回值。</p></li><li class="lvl-2"><p>sources：一个或多个包含要应用的属性的源对象。</p></li></ul><p>如果目标对象与源对象具有相同的键（属性名），则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的同名属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;name: &#x27;1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>字符串和 Symbol 类型属性都会被复制。</p><div class="tips"><p><code>Object.assign()</code> 不会在源对象值为 null 或 undefined 时抛出错误。基本类型将被封装，只有字符串封装对象才拥有可枚举的自有属性。因此，除了字符串，其他基本类型都不会被处理。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// &#123;0: &#x27;c&#x27;, 1: &#x27;d&#x27;, 2: &#x27;e&#x27;, 3: &#x27;3&#x27;, 4: &#x27;4&#x27;, a: 1, b: 2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    <span class="string">&quot;cde34&quot;</span>,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    <span class="number">11</span>,</span><br><span class="line">    <span class="title class_">Symbol</span>(<span class="string">&#x27;11&#x27;</span>),</span><br><span class="line">    <span class="number">11n</span>));</span><br></pre></td></tr></table></figure><p>特点：</p><ul class="lvl-0"><li class="lvl-2"><p>合并具有相同属性的对象，属性会被后续参数中具有相同属性的其他对象覆盖。</p></li><li class="lvl-2"><p>可以拷贝 Symbol 类型属性。</p></li><li class="lvl-2"><p>原型链上的属性和不可枚举的属性不能被复制。</p></li><li class="lvl-2"><p>基本类型会被封装为对象。</p></li><li class="lvl-2"><p>异常会中断后续的复制。</p></li></ul><h3 id="2-使用扩展运算符">2. 使用扩展运算符 <code>...</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法 (Spread syntax)</a>, 可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开。(译者注: 字面量一般指 [1, 2, 3] 或者 {name: “mdn”} 这种简洁的构造方式)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr];</span><br><span class="line">arr2.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// (4) [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 数组合并</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr4 = [...arr2, ...arr3]; <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&quot;baz&quot;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象：&#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象：&#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ul class="lvl-0"><li class="lvl-2"><p>只能用于可迭代对象，扩展运算符只能拷贝对象自身的并且可枚举的属性。</p></li><li class="lvl-2"><p>Object.assign() 函数会触发 setters，而展开语法则不会。</p></li><li class="lvl-2"><p>不能替换或者模拟 Object.assign() 函数</p></li><li class="lvl-2"><p>在函数调用时使用展开语法，请注意不能超过 JavaScript 引擎限制的最大参数个数（调用具有太多参数的函数（即超过数万个参数）的后果是未指定的，并且在不同的引擎中会有所不同。）</p></li></ul><h3 id="3-手写实现浅拷贝">3. 手写实现浅拷贝</h3><p>在展开语法出来之前，我们想将已有数组或对象变成新数组或对象的一部分较为麻烦</p><ul class="lvl-0"><li class="lvl-2"><p>对数组，我们可以使用 Array.prototype.concat() 或 Array.prototype.slice() 方法，其实只要能够遍历该数组，然后创建一个空数组加入即可，没什么好说的。</p></li><li class="lvl-2"><p>对对象，即创建一个空对象，然后想办法遍历原对象加入即可。</p></li></ul><h2 id="深拷贝的实现">深拷贝的实现</h2><h3 id="1-JSON-stringify">1. <code>JSON.stringify()</code></h3><p>通过<code>JSON.stringify()</code>确实可以进行深拷贝，但局限于JSON的语法，JSON不支持undefined、Symbol、BigInt数据类型，所以通过JSON进行深拷贝时会出现问题：</p><ul class="lvl-0"><li class="lvl-2"><p>如果时undefined和Symbol类型，会直接忽略掉，不会出现在新对象中。</p></li><li class="lvl-2"><p>如果时BinInt类型，会直接报错。</p></li><li class="lvl-2"><p>对于循环引用会报错。</p></li></ul><h3 id="2-函数库lodash">2. 函数库lodash</h3><p>lodash的cloneDeep()方法，详细的可以看官网。<br><a href="https://www.lodashjs.com/docs/lodash.cloneDeep/">https://www.lodashjs.com/docs/lodash.cloneDeep/</a></p><h3 id="3-手写实现深拷贝">3. 手写实现深拷贝</h3><p>如果有更多定制化要求可以自己添加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">isHigh</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">hobbies</span>: [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, &#123; <span class="attr">name</span>: <span class="number">111</span> &#125;],</span><br><span class="line">    <span class="attr">book</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;JS&#x27;</span>,</span><br><span class="line">        <span class="attr">time</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">bar</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">baz</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="number">222</span>)]: <span class="number">222</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="title class_">Symbol</span>(<span class="number">11</span>),</span><br><span class="line">    <span class="attr">bar1</span>: <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]),</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">obj1</span> = obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> valueType = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">return</span> (value !== <span class="literal">null</span>) &amp;&amp; (valueType === <span class="string">&#x27;object&#x27;</span> || valueType === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Symbol</span>(target.<span class="property">description</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="title class_">Set</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> target) &#123;</span><br><span class="line">            set.<span class="title function_">add</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.<span class="title function_">get</span>(target)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    map.<span class="title function_">set</span>(target, obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        obj[key] = <span class="title function_">deepClone</span>(target[key], map)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(target)) &#123;</span><br><span class="line">        obj[<span class="title class_">Symbol</span>(key.<span class="property">description</span>)] = <span class="title function_">deepClone</span>(target[key], map)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deepClone</span>(obj))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;name: &#x27;tom&#x27;, age: 18, isHigh: false, foo: undefined, love: null, …&#125;age: 18bar: Symbol(11)bar1: Set(3) &#123;1, 2, 3&#125;book: &#123;name: &#x27;JS&#x27;, time: 20, bar: undefined, baz: null&#125;fn: () =&gt; &#123; &#125;foo: undefinedhobbies: (4) [&#x27;eat&#x27;, &#x27;sleep&#x27;, &#x27;code&#x27;, &#123;…&#125;]isHigh: falselove: nullname: &quot;tom&quot;obj1: &#123;name: &#x27;tom&#x27;, age: 18, isHigh: false, foo: undefined, love: null, …&#125;Symbol(222): 222&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面经 </category>
          
          <category> 深拷贝与浅拷贝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题-类型判断</title>
      <link href="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-typeof-与-instanceof-类型判断">1. <code>typeof</code> 与 <code>instanceof</code> 类型判断</h2><details open>   <summary>      <span>查看</span>   </summary><blockquote><p><code>typeof</code> 是否能正确判断类型？<code>instanceof</code>能否正确判断对象的原理是什么？</p></blockquote><p><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型。判断 <code>null</code> 对应的结果为 <code>object</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;1&quot;</span>); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>()); <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">10n</span>); <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image.png" class="" title="typeof 与 instanceof 类型判断"><p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 不能准确判断对象的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-1.png" class="" title="typeof 与 instanceof 类型判断"><p>所以 <code>typeof</code> 不能正确判断类型。</p><blockquote><p>如果我们想判断一个对象的正确类型，我们可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的。但对于原始数据类型，使用 <code>instanceof</code> 是无法判断的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-2.png" class="" title="typeof 与 instanceof 类型判断"><div class="warning"><p><strong>注意：</strong><br><code>instanceof</code> 可以判断对象的正确类型，但由于原型链的关系，对于其类型的父类进行判断也是返回 <code>true</code>。</p></div><h3 id="手动实现-function-isInstanceOf-child-Parent">手动实现 function isInstanceOf(child,Parent)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInstanceof</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">   <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">   <span class="keyword">let</span> <span class="title class_">ParentProto</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">   <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">   <span class="title class_">Child</span> = <span class="title class_">Child</span>.<span class="property">__proto__</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ParentProto</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Child</span>);</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="title class_">Child</span> === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="title class_">Child</span> === <span class="title class_">ParentProto</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="title class_">Child</span> = <span class="title class_">Child</span>.<span class="property">__proto__</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始测试</span></span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">child</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">father</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">child.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">father</span>()</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title function_">child</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(a, <span class="title class_">Array</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(b, <span class="title class_">Object</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(b, <span class="title class_">Array</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(a, <span class="title class_">Object</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(c, <span class="title class_">Foo</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(d, child)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(d, father)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></details><h2 id="2-、-、Object-is-的区别">2. <code>==</code> 、<code>===</code> 、<code>Object.is()</code> 的区别</h2><h3 id=""><code>==</code></h3><details open><summary>查看</summary>相等（==）运算符（宽松比较）检查其两个操作数是否相等，返回一个布尔值结果。当比较双方数据类型不同时，它会尝试转换不同类型的操作数，并进行比较<h4 id="比较规则"><code>==</code> 比较规则</h4><ol><li class="lvl-3"><p>如果操作数具有相同的类型，则按如下方式进行比较：</p><ul class="lvl-2"><li class="lvl-5">对象（Object）：仅当两个操作数引用同一个对象时返回 true。</li><li class="lvl-5">字符串（String）：仅当两个操作数具有相同的字符且顺序相同时返回 true。</li><li class="lvl-5">数字（Number）：如果两个操作数的值相同，则返回 true。+0 和 -0 被视为相同的值。如果任何一个操作数是 NaN，返回 false；所以，<mark>NaN 永远不等于 NaN</mark>。</li><li class="lvl-5">布尔值（Boolean）：仅当操作数都为 true 或都为 false 时返回 true。</li><li class="lvl-5">大整型（BigInt）：仅当两个操作数的值相同时返回 true。</li><li class="lvl-5">符号（Symbol）：仅当两个操作数引用相同的符号时返回 true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>如果其中一个操作数为 null 或 undefined，另一个操作数也必须为 null 或 undefined 以返回 true。否则返回 false。（null 和 undefined 除了与null 和 undefined 比较为 true，其他值都返回 false）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == c); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b == d); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>如果其中一个操作数是对象，另一个是原始值，则将对象转换为原始值。</p><ul class="lvl-2"><li class="lvl-6">在这一步，两个操作数都被转换为原始值（字符串、数字、布尔值、符号和大整型中的一个）。剩余的转换将分情况完成。<ul class="lvl-4"><li class="lvl-8">如果是相同的类型，使用步骤 1 进行比较。</li><li class="lvl-8">如果其中一个操作数是符号(Symbol)而另一个不是，返回 false。</li><li class="lvl-8">如果其中一个操作数是布尔值而另一个不是，则将布尔值转换为数字：<mark>true 转换为 1，false 转换为 0</mark>。然后再次对两个操作数进行宽松比较。</li><li class="lvl-8">数字与字符串：<mark>将字符串转换为数字</mark>。转换失败将导致 NaN，这将保证相等比较为 false。</li><li class="lvl-8">数字与大整型：按数值进行比较。如果数字的值为 ±∞ 或 NaN，返回 false。</li><li class="lvl-8">字符串与大整型：<mark>使用与 BigInt() 构造函数相同的算法将字符串转换为大整型数</mark>。如果转换失败，返回 false。</li></ul></li></ul></li></ol><div class="tips"><p><strong>对象转为原始值</strong><br>对象将依次调用它的 <code>[Symbol.toPrimitive]()</code>（将 default 作为 hint 值）、valueOf() 和 toString() 方法，将其转换为原始值。<mark>注意，原始值转换会在 toString() 方法之前调用 valueOf() 方法</mark>。<br><code>[Symbol.toPrimitive]()</code> 方法，如果存在，则必须返回原始值，返回对象，会导致 TypeError。<mark>对于 valueOf() 和 toString()，如果其中一个返回对象，则忽略其返回值，从而使用另一个的返回值；如果两者都不存在，或者两者都没有返回一个原始值，则抛出 TypeError</mark>。</p></div><p><strong>示例</strong></p><p>定义一个干净的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">valueOf</span>()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>实现该对象的<code>[Symbol.toPrimitive]</code>方法，使其返回一个原始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">   [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">         <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处运用了隐式转换 导致使用强制数字类型转换算法 使得能满足 hint===&#x27;number&#x27; 条件        </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+a == <span class="number">42</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 此处 new String 导致使用强制字符串类型转换算法 使得能满足 hint===&#x27;string&#x27; 条件 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">String</span>(a) == <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><div class="warning"><p><strong>注意</strong><br>当未对对象使用强制类型转换时，会返回默认值。但<code>Symbol.toPrimitive</code> 返回的 null 或 undefined 与 null 和 undefined 进行宽松比较(==)时仍为 false，hint 值是 number 时，返回的必须是数字字符串或数字，否则与数字或数字字符串进行宽松比较时仍为 false</p></div><div class="tips"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Symbol</a> 对象是唯一重写 <code>[Symbol.toPrimitive]()</code> 方法的对象。</p><p>对于 Date，如果 hint 是 “string” 或 “default”，<code>[Symbol.toPrimitive]()</code> 将会调用 toString。如果 toString 属性不存在，则调用 valueOf。如果 valueOf 也不存在，则抛出一个TypeError。</p><p>对于 Symbol，hint 参数未使用时，Symbol 的 <code>[Symbol.toPrimitive]()</code> 方法返回 Symbol 对象的原始值作为数据类型返回。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">sym === sym[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当对象不存在<code>Symbol.toPrimitive</code>时，会根据 <code>toString()</code> 和 <code>valueOf()</code> 的返回值作为原始值进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">      <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">42</span>); <span class="comment">// true</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">String</span>(a) == <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div class="tips"><p>一般来说，valueOf 的优先级高于 toString。但当其使用强制字符串类型转换时，会根据 toString 的返回值作为原始值进行比较。</p></div></details><h3 id="-2"><code>===</code></h3><details open><summary>查看</summary>严格相等（===）运算符与 == 运算符之间最显著的区别是，严格相等运算符不尝试类型转换。相反，严格相等运算符总是认为不同类型的操作数是不同的，即只要类型不同进行 `===` 操作时，结果即为 `false`。严格相等运算符本质上只执行第 1 步，然后对所有其他情况返回 `false`。<div class="warning"><p>上面的算法有一个“故意违反”：如果其中一个操作数是 document.all，则它被视为 undefined。这意味着 document.all == null 是 true，但 document.all === undefined &amp;&amp; document.all === null 是 false。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">MDN文章描述</a></p></div><h4 id="比较规则-2"><code>===</code> 比较规则</h4><ul class="lvl-0"><li class="lvl-2"><p>如果操作数的类型不同，则返回 false。</p></li><li class="lvl-2"><p>如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。</p></li><li class="lvl-2"><p>如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。</p></li><li class="lvl-2"><p>如果两个操作数有任意一个为 NaN，返回 false。</p></li><li class="lvl-2"><p>否则，比较两个操作数的值：</p><ul class="lvl-2"><li class="lvl-4"><mark>数字类型必须拥有相同的数值。+0 和 -0 会被认为是相同的值。</mark></li><li class="lvl-4">字符串类型必须拥有相同顺序的相同字符。</li><li class="lvl-4">布尔运算符必须同时为 true 或同时为 false。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> === +<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></details><h3 id="Object-is"><code>Object.is()</code></h3><details open><summary>查看</summary><p><code>Object.is()</code> 静态方法确定两个值是否为相同值。</p><h4 id="Object-is-的比较规则"><code>Object.is()</code>的比较规则</h4><p>如果出现以下几种情况，则返回 true，即比较的两个值相同</p><ul class="lvl-0"><li class="lvl-2"><p>都是 undefined</p></li><li class="lvl-2"><p>都是 null</p></li><li class="lvl-2"><p>都是 true 或者都是 false</p></li><li class="lvl-2"><p>都是长度相同、字符相同、顺序相同的字符串</p></li><li class="lvl-2"><p>都是相同的对象（意味着两个值都引用了内存中的同一对象）</p></li><li class="lvl-2"><p>都是 BigInt 且具有相同的数值</p></li><li class="lvl-2"><p>都是 symbol 且引用相同的 symbol 值</p></li><li class="lvl-2"><p>都是数字且</p><ul class="lvl-2"><li class="lvl-4">都是 +0</li><li class="lvl-4">都是 -0</li><li class="lvl-4">都是 NaN</li><li class="lvl-4">都有相同的值，非零且都不是 NaN</li></ul></li></ul><p><code>Object.is()</code> 与 == 运算符并不等价。== 运算符在测试相等性之前，会对两个操作数进行类型转换（如果它们不是相同的类型），这可能会导致一些非预期的行为，例如 “” == false 的结果是 true，但是 <code>Object.is()</code> 不会对其操作数进行类型转换。</p><p><code>Object.is()</code> 也不等价于 === 运算符。<code>Object.is()</code> 和 === 之间的<mark>唯一区别在于它们处理带符号的 0 和 NaN 值的时候</mark>。=== 运算符（和 == 运算符）将数值 -0 和 +0 视为相等，但是会将 NaN 视为彼此不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="number">0</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">Number</span>.<span class="property">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></details><h3 id="总结">总结</h3><div class="tips"><p>对于 <code>==</code>，主要特点就是类型转换，而 <code>===</code> 和 <code>Object.is()</code> 则不进行类型转换。</p><p>对于 <code>===</code>，主要特点就是严格相等，类型不同就是 <code>false</code>，与 <code>==</code> 类型相同时比较规则一致。</p><p>对于 <code>Object.is()</code>，主要特点就是严格相等，类型不同就是 <code>false</code>，与 <code>==</code> 类型相同时比较规则一致。但与 <code>===</code> 不同的是，<code>Object.is()</code> 对于 0 和 -0、NaN 的处理不同，<code>Object.is()</code> 将数值 -0 和 +0 视为彼此不相等，但是会将 NaN 视为彼此相等，<code>===</code> 将数值 -0 和 +0 视为相等，但是会将 NaN 视为彼此不相等。</p></div><h2 id="全局-isNaN-和-Number-isNaN">全局 <code>isNaN()</code> 和  <code>Number.isNaN()</code></h2><details open><summary>查看</summary><ul class="lvl-0"><li class="lvl-2"><p><code>isNaN()</code> 函数用来确定一个值是否为 NaN，若有必要，则首先将值转换为数字。</p></li><li class="lvl-2"><p><code>Number.isNaN()</code> 静态方法判断传入的值是否为 NaN，如果输入不是数字类型，则返回 false。它是全局 <code>isNaN()</code> 函数更健壮的版本。</p></li></ul><p><code>isNaN()</code> 是全局对象的一个函数属性。对于数字值，<code>isNaN()</code> 检测该值是否为 NaN 值。当 <code>isNaN()</code> 函数的参数不是数字类型时，其会首先被转换为数字，然后将其结果值与 NaN 进行比较</p><p><code>isNaN()</code> 对于非数字参数的行为可能会令人困惑！例如，空字符串被强制转换为 0，布尔值被强制转换为 0 或 1；直观上，两者均“不是数字”，仅因它们的运算结果不是 NaN，而使得 <code>isNaN()</code> 返回 false。因此，<code>isNaN()</code> 既不回答“输入是否为浮点数值 NaN”，也不回答“输入是否为数字”这两个问题。</p><p>Number.isNaN() 是检测一个值是否为数字值 NaN 的更可靠的方法。或者，也可以使用表达式 x !== x，这两种方法都不会产生全局 isNaN() 不可靠的误判。要检测一个值是否为数字，请使用 typeof x === “number”。</p><h3 id="Number-isNaN-和全局-isNaN-之间的区别">Number.isNaN() 和全局 isNaN() 之间的区别</h3><p>Number.isNaN() 不会尝试将参数转换为数字，因此非数字总是返回 false。以下都返回 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>); </span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;blabla&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;37&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;37.37&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><p>全局 isNaN() 函数会将参数强制转换为数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;blabla&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>); <span class="comment">// false，强制转换为 1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>); <span class="comment">// false，强制转换为 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37&quot;</span>); <span class="comment">// false，强制转换为 37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37.37&quot;</span>); <span class="comment">// false，强制转换为 37.37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false，强制转换为 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// false，强制转换为 0</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面经 </category>
          
          <category> 类型判断 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-学习笔记</title>
      <link href="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="双线程模型">双线程模型</h2><p>微信小程序基于 WebView 环境下使用双线程模型架构, 其实本质就相当于开了一个浏览器, 基于Webkit的JSCore渲染一个页面进行展示, 其包含 JS 逻辑和视图渲染(DOM树的创建, CSS解析, 样式计算, Layout, Paint)都会发生在同一线程, 但其执行过多的JS逻辑会阻塞渲染, 导致页面卡顿。</p><p>基于此, 小程序为了考虑性能和安全, 采用了<code>[双线程]</code>的架构。</p><p>开启两个 WebView  线程, 一个执行渲染, 一个调用 JSCore 处理js逻辑, 再通过原生(微信客户端)的桥接(bridge)计算实现两个 WebView 线程之间的通信, 以达到页面渲染更新的效果。</p><p>微信小程序后推出了<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html">Skyline</a>渲染引擎, 其类似于Flutter渲染, 更加接近原生的体验。</p><h2 id="为什么会出现-WXS">为什么会出现 WXS</h2><p>由于双线程模型, 主要关于视图渲染的线程是不能直接调用JS逻辑的, 可能是由于两个线程之间频繁通信对原生应用的开销太大, 微信小程序底层并没有设置这种直接通信的方式, 但为了能够实现开发者的需求, 于是推出了 WSX 语法, 也就是在负责渲染视图的线程中也可以调用 JSCore, 进而实现页面与JS逻辑的通信。</p><p>但尽量避免在 WSX 中编写复杂的逻辑, 因为其所在的线程还要进行视图渲染, 避免阻塞。</p><h3 id="WXS-的使用方式一">WXS 的使用方式一</h3><p>通过 <code>wxs</code> 标签的形式, wsx 标签中包裹 js 代码, 只能是 <mark>ES5</mark> 的语法, 并且需要进行导出, 导出使用<mark>CommonJs</mark>的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs <span class="variable language_">module</span>=<span class="string">&quot;format&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">formatPrice</span>(<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span> + price</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">formatPrice</span>: formatPrice &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br></pre></td></tr></table></figure><p>要在 <code>wxs</code> 标签中明确编写module属性, 为每一个<code>wxs</code>设置一个独特的标识, 通过该表示使用其中定义的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> &#123;&#123;<span class="attr">format.formatPrice</span>(&#x27;<span class="attr">12414</span>&#x27;)&#125;&#125;&lt;/<span class="attr">text</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="WXS-的使用方式二">WXS 的使用方式二</h3><p>定义以<code>.wxs</code>为后缀名的文件, 如<code>format.wxs</code></p><p>在其中编写JS代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatPrice</span>(<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;￥&quot;</span> + price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">formatPrice</span>: formatPrice &#125;;</span><br></pre></td></tr></table></figure><p>在<code>wxml</code>中通过<code>wxs</code>标签引入该文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;format&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/utils/format.wxs&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件的样式细节">组件的样式细节</h2><h3 id="组件内的样式对外部样式的影响">组件内的样式对外部样式的影响</h3><ul class="lvl-0"><li class="lvl-2"><p>组件内的class样式, 只对组件wxml内的节点生效, 对于引入组件的Page页面不生效</p></li><li class="lvl-2"><p>组件内不能使用id选择器、属性选择器、标签选择器(会对外部样式造成影响)</p></li></ul><h3 id="外部样式对组件内样式的影响">外部样式对组件内样式的影响</h3><ul class="lvl-0"><li class="lvl-2"><p>外部使用class样式, 只对外部wxml的class生效, 对组件内是不生效的</p></li><li class="lvl-2"><p>外部使用了id选择器、属性选择器不会对组件内样式产生影响</p></li><li class="lvl-2"><p>外部使用了标签选择器, 会对组件内产生影响</p></li></ul><h3 id="如何让class可以相互影响">如何让class可以相互影响</h3><ul class="lvl-0"><li class="lvl-2"><p>在Component对象中, 可以传入一个options属性, 其中options属性中有一个styleIsolation(隔离)属性</p></li><li class="lvl-2"><p>styleIsolation三个取值</p><ul class="lvl-2"><li class="lvl-4">isolated: 默认值, 表示启用样式隔离, 在自定义组件内外, 使用class指定的样式将不会互相影响</li><li class="lvl-4">apply-shared: 表示页面wxss样式将影响到自定义组件, 但自定义组件wxss中指定的样式不会影响页面</li><li class="lvl-4">shared: 表示页面wxss样式将影响到自定义组件, 自定义组件wxss中指定的样式也会影响页面和其他设置了</li></ul></li></ul><h2 id="mark-传递参数的细节">mark 传递参数的细节</h2><p>mark语法: <code>mark:[自定义名称]=&quot;xxx&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">mark:dd</span>=<span class="string">&quot;111&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">mark:name</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">mark:name1</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过mark传递参数, 会从被点击组件向上合并所有定义了mark属性的祖先组件, 得到一个合并后的mask对象, 即使事件通过catch拦截冒泡传递了。</p><h2 id="自定义组件">自定义组件</h2><h3 id="组件生命周期"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html#%E5%AE%9A%E4%B9%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95">组件生命周期</a></h3><p>在<code>Component(&#123;&#125;)</code>中的<code>lifetimes</code>中写入对应组件生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件被创建created&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">attached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件被添加到组件树中attached&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">detached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件从组件树中移除detached&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>created</code>: 组件实例被创建, 但节点树还未插入文档树</p></li><li class="lvl-2"><p><code>attached</code>: 组件实例被插入文档树后触发</p></li><li class="lvl-2"><p><code>ready</code>: 组件实例被创建, 并且节点树已经插入文档树后触发</p></li><li class="lvl-2"><p><code>moved</code>: 组件实例被移动到文档树 another-component 之前触发</p></li><li class="lvl-2"><p><code>detached</code>: 组件实例被从文档树移除后触发</p></li><li class="lvl-2"><p><code>error</code>: 组件实例发生错误时触发</p></li></ul><h3 id="组件所在页面的生命周期"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html#%E7%BB%84%E4%BB%B6%E6%89%80%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">组件所在页面的生命周期</a></h3><p>在<code>Component(&#123;&#125;)</code>中的<code>pageLifetimes</code>中写入对应生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">pageLifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;页面显示show&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;页面隐藏hide&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>load</code>: 页面加载时触发</p></li><li class="lvl-2"><p><code>show</code>: 页面显示时触发</p></li><li class="lvl-2"><p><code>hide</code>: 页面隐藏时触发</p></li><li class="lvl-2"><p>…</p></li></ul><h3 id="插槽">插槽</h3><p>微信小程序的自定义组件插槽与 Vue 的写法一致, 但微信小程序不支持默认插槽, 我们为了满足该业务需求, 我们可以通过伪类选择器<code>:empty</code>实现</p><p>wxml代码结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;default&quot;</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>wcss样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.default</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">:empty</span> + <span class="selector-class">.default</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个插槽">多个插槽</h3><p>微信小程序要想使用多个插槽, 需要在 Components 函数对象参数中的 options 配置 <code>multipleSlots: true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">multipleSlots</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="微信小程序弹窗API">微信小程序弹窗API</h2><h3 id="wx-showToast">wx.showToast</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html">官方文档</a></p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;购买成功！&quot;</span>,</span><br><span class="line">  <span class="attr">icon</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">mask</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="wx-showMoadl">wx.showMoadl</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html">官方文档</a></p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;确定购买吗&quot;</span>,</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&quot;1241414&quot;</span>,</span><br><span class="line">  <span class="attr">confirmColor</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="attr">cancelColor</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">cancel</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">confirm</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;confirm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="wx-showActionSheet">wx.showActionSheet</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showActionSheet.html">官方文档</a></p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showActionSheet</span>(&#123;</span><br><span class="line">  <span class="attr">alertText</span>: <span class="string">&quot;提示&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">itemList</span>: [<span class="string">&quot;选项1&quot;</span>, <span class="string">&quot;选项2&quot;</span>, <span class="string">&quot;选项3&quot;</span>],</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">tapIndex</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fail</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="微信小程序获取地址API">微信小程序获取地址API</h2><p>API: <code>wx.getLocation</code></p><p>使用该API的前提需要在<code>app.json</code>中进行配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;requiredPrivateInfos&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;getLocation&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;permission&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scope.userLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取位置信息&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="微信小程序获取界面上的节点信息">微信小程序获取界面上的节点信息</h2><p>场景: <code>swiper</code> 轮播图组件有默认的高度, 假如其中放置图片, 但图片的高度不适配, 改动图片的 mode 属性为 <code>aspectFill</code> 会裁剪图片, 显得不美观, 为了解决此, 尝试获取图片高度, 改变 <code>swiiper</code> 的高度, 以是图片完美展示</p><h3 id="步骤一">步骤一</h3><p>创建 <code>SelectorQuery</code>, SelectorQuery 为查询节点信息的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = wx.<span class="title function_">createSelectorQuery</span>();</span><br></pre></td></tr></table></figure><h3 id="步骤二">步骤二</h3><p>获取图片组件的信息, 用<code>NodesRef SelectorQuery.select(string selector)</code>,<br>并通过 <code>SelectorQuery NodesRef.boundingClientRect(function callback)</code> 添加节点的布局位置的查询请求。</p><p><code>NodesRef SelectorQuery.select(string selector)</code>: 在当前页面下选择第一个匹配选择器 selector 的节点。返回一个 NodesRef 对象实例，可以用于获取节点信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="title function_">select</span>(<span class="string">&quot;.banner-image&quot;</span>).<span class="title function_">boundingClientRect</span>();</span><br></pre></td></tr></table></figure><h3 id="步骤三">步骤三</h3><p><code>NodesRef SelectorQuery.exec(function callback)</code>: 执行所有的请求。请求结果按请求次序构成数组, 在callback的第一个参数中返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">height</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对该操作进行封装">对该操作进行封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">querySelect</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> query = wx.<span class="title function_">createSelectorQuery</span>();</span><br><span class="line">    query.<span class="title function_">select</span>(<span class="string">&quot;.banner-image&quot;</span>).<span class="title function_">boundingClientRect</span>();</span><br><span class="line">    query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微信小程序音源播放操作">微信小程序音源播放操作</h2><h3 id="创建-InnerAudioContext-实例">创建 <code>InnerAudioContext</code> 实例</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioContext = wx.<span class="title function_">createInnerAudioContext</span>();</span><br></pre></td></tr></table></figure><h3 id="设置-InnerAudioContext-实例的-src-和-autoplay-属性">设置 <code>InnerAudioContext</code> 实例的 src 和 autoplay 属性</h3><ul class="lvl-0"><li class="lvl-2"><p>src: 音频资源地址</p></li><li class="lvl-2"><p>autoplay: 是否自动播放</p></li></ul><p>进行以上设置后, 在页面或相应的生命周期中加载完后即可自动播放</p><p>但仅仅是用于可播放, 对于其更精细的操作可以查阅对应的<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/InnerAudioContext.html">官方文档</a></p><h2 id="图片懒加载没生效问题">图片懒加载没生效问题</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/assets/xxx.png&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;&quot;</span> <span class="attr">show-menu-by-longpress</span> <span class="attr">lazy-load</span> /&gt;</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" class="" title="图片懒加载没生效问题"><p>lazy-load的图片不是出现在屏幕上才会开始加载，而是提前3个屏幕高度就会加载。所以说三个屏幕高度以内的图片是不会懒加载的，上下三屏即为三个屏幕高度。</p><h2 id="text-组件">text 组件</h2><img data-src="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" class="" title="text 组件"><h2 id="navigator组件中的-open-type">navigator组件中的 open-type</h2><img data-src="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" class="" title="navigator中的 open-type"><p>注意：</p><blockquote><p>在进行页面跳转时，需要在路径的前面添加 / 斜线，否则跳转不成功<navigator url="/pages/list/list?id=10&num=hue" open-type="navigate">到商品列表页面</navigator></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>navigate：只能跳转到非 TabBar 页面，不能跳转到 TabBar 页面，保留上一级页面</p></li><li class="lvl-2"><p>redirect：只能跳转到非 TabBar 页面，不能跳转到 TabBar 页面，关闭上一级页面</p></li><li class="lvl-2"><p>switchTab：只能跳转到 TabBar 页面，不能跳转到非 TabBar 页面，关闭其他所有的非 TabBar 页面</p></li><li class="lvl-2"><p>reLaunch：关闭所有页面，然后打开小程序中某一个页面</p></li><li class="lvl-2"><p>navigateBack返回上一页或者返回前几页，默认只能返回上一页</p><ul class="lvl-2"><li class="lvl-4">delte：返回的层级，默认是 1，如果想返回几级，就写几</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SASS星空</title>
      <link href="/2024/10/15/SASS%E6%98%9F%E7%A9%BA/"/>
      <url>/2024/10/15/SASS%E6%98%9F%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>效果图</strong></p><img data-src="/2024/10/15/SASS%E6%98%9F%E7%A9%BA/preview.gif" class="" title="SASS星空"><p>盒子的阴影可以设置多个，所以我们可以通过阴影实现星光的效果，但纯写 css 过于抽象，我们可以利用 sass 的循环语法、函数与变量编写<br><strong>HTML结构</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里只设置三个层级,可以根据需要自己添加 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Sass 星空<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SASS代码</strong><br>提示：</p><ul class="lvl-0"><li class="lvl-2"><p>对SASS的编译不要用 VScode 的插件：easy sass，可能会出现函数识别导致编译失败的问题</p></li><li class="lvl-2"><p>可以在 node 环境下，安装 sass：<code>npm i sass</code></p></li><li class="lvl-2"><p>后执行 <code>npx sass [sass文件路径] [编译转换后的css输出文件路径] --no-source-map -w</code></p></li></ul><blockquote><p>npx sass index.scss index.css --no-source-map -w</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>npx：暂时把 sass 加入环境变量中，仅在此命令行操作有效</p></li><li class="lvl-2"><p>sass：安装 sass 自带的执行命令</p></li><li class="lvl-2"><p>–no-source-map：取消源映射，source-map里面存放着sass与css的映射信息，通过此命令可以取消该文件的生成</p></li><li class="lvl-2"><p>-w：监听sass/scss的文件内容变化，自动更新生成的css</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 背景底色</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    radial-gradient 是 CSS3 中用于创建径向渐变背景的属性。</span></span><br><span class="line"><span class="comment">    ellipse at bottom 指定了渐变形状为椭圆，并且椭圆的底部与元素的底部对齐。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(ellipse at bottom, <span class="number">#1b2735</span> <span class="number">0%</span>, <span class="number">#090a0f</span> <span class="number">100%</span>);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;lato&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">  // 渐变背景，将文本背景设置为透明，并设置背景颜色为 <span class="selector-id">#38495a</span></span><br><span class="line">  // 即将文字展示为背景颜色</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(white, <span class="number">#38495a</span>);</span><br><span class="line">  -webkit-<span class="attribute">background-clip</span>: text;</span><br><span class="line">  <span class="attribute">background-clip</span>: text;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建星光（阴影）函数</span><br><span class="line"><span class="keyword">@function</span> createShadow($n) &#123;</span><br><span class="line">  // 定义阴影变量  </span><br><span class="line">  $shadow: <span class="string">&quot;#&#123;random($limit: 100)&#125;vw #&#123;random($limit: 100)&#125;vh #fff&quot;</span>;</span><br><span class="line">  <span class="keyword">@for</span> $i from <span class="number">2</span> through $n &#123;</span><br><span class="line">    // 每次循环向 $shadow 中添加新的阴影</span><br><span class="line">    $shadow: <span class="string">&quot;#&#123;$shadow&#125;, #&#123;random($limit: 100)&#125;vw #&#123;random($limit: 100)&#125;vh #fff&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  // unquote() 函数用于将字符串转换为 CSS 属性值，即去掉字符串</span><br><span class="line">  <span class="keyword">@return</span> unquote($shadow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义星光（阴影）初始数量</span><br><span class="line">$count: <span class="number">1000</span>;</span><br><span class="line">// 定义动画初始时间</span><br><span class="line">$duration: <span class="number">400s</span>;</span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through <span class="number">3</span> &#123;</span><br><span class="line">  // 每次循环时将数量和动画时间减半，以达到不同层级的动画效果</span><br><span class="line">  $count: <span class="built_in">floor</span>(<span class="built_in">calc</span>($count / <span class="number">2</span>));</span><br><span class="line">  $duration: <span class="built_in">floor</span>(<span class="built_in">calc</span>($duration / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  // 输出调试信息</span><br><span class="line">  <span class="keyword">@debug</span> <span class="string">&quot;count #&#123;$count&#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">@debug</span> <span class="string">&quot;duration #&#123;$duration&#125;&quot;</span>;</span><br><span class="line">  // 创建层级的样式</span><br><span class="line">  <span class="selector-class">.layer</span>#&#123;$<span class="selector-tag">i</span>&#125; &#123;</span><br><span class="line">    $size: #&#123;$<span class="selector-tag">i</span>&#125;px;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: $size;</span><br><span class="line">    <span class="attribute">height</span>: $size;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f40</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="built_in">createShadow</span>($count);</span><br><span class="line">    <span class="attribute">animation</span>: moveUp $duration linear infinite;</span><br><span class="line">    // 为了动画的流畅和无缝衔接，在 &amp;<span class="selector-pseudo">::after</span> 中设置相同的参数</span><br><span class="line">    &amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">position</span>: fixed;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">100vh</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: inherit;</span><br><span class="line">      <span class="attribute">height</span>: inherit;</span><br><span class="line">      <span class="attribute">box-shadow</span>: inherit;</span><br><span class="line">      <span class="attribute">background</span>: inherit;</span><br><span class="line">      <span class="attribute">border-radius</span>: inherit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动动画</span><br><span class="line"><span class="keyword">@keyframes</span> moveUp &#123;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100vh</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 页面 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SASS </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN优化</title>
      <link href="/2024/10/13/RN%E4%BC%98%E5%8C%96/"/>
      <url>/2024/10/13/RN%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="移除不必要权限">移除不必要权限</h2><p>例如，在<code>\[项目名]\android\app\src\main\</code>下<code>AndroidManifest.xml</code>中写入如下代码</p><span id="more"></span><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 移除读取电话状态的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移除写入外部存储的权限。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移除读取外部存储的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><!-- more --><p>我们还需要在<code>AndroidManifest.xml</code>中声明了一个名为tools的XML命名空间<code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>移除不必要权限的好处（文心一言生成）</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>提升用户隐私保护</strong>：减少不必要的权限请求可以增强用户信任，因为用户越来越关注个人数据的安全与隐私。特别是读取电话状态、读写外部存储这样的敏感权限，移除后表明应用不会侵犯用户的通信记录或存储的数据。</p></li><li class="lvl-2"><p><strong>简化权限管理</strong>：对于用户而言，应用程序请求的权限越少，他们在安装和使用过程中遇到的权限提示就越少，从而提升用户体验。用户不再需要为不相关的功能授予权限。</p></li><li class="lvl-2"><p><strong>降低潜在的安全风险</strong>：每个权限都可能成为安全漏洞的入口。移除不必要的权限可以减少应用受到攻击的面，提高应用的整体安全性。</p></li><li class="lvl-2"><p><strong>合规性增强</strong>：遵循更严格的隐私法规要求，比如GDPR（欧盟通用数据保护条例）或中国的《个人信息保护法》，这些法律强调最小必要原则，即只收集和处理完成业务所必需的最少个人信息。移除多余权限有助于企业符合此类法规要求。</p></li><li class="lvl-2"><p><strong>优化应用审核过程</strong>：在Google Play Store或其他应用市场上架时，应用的权限使用是审核的一部分。减少非必要的权限可以简化审核流程，加快应用上架速度。</p></li><li class="lvl-2"><p><strong>可能提升性能</strong>：虽然直接关联不大，但理论上减少对存储或硬件资源的访问需求，可能轻微提升应用运行效率，尤其是对于资源紧张的设备。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> APP </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN问题解决</title>
      <link href="/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>2024.6.14时最新版本为 0.74.2，2024.8.1时最新版本为0.74.4，但其相关依赖不太稳定，尝试使用 0.74.2 版本操作</p><span id="more"></span><h2 id="创建项目时报错：RN-error-Error">创建项目时报错：<strong>RN error Error</strong></h2><p><strong><font style="color:#DF2A3F;">RN error Error: getaddrinfo ENOENT <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:108:26)</font></strong></p><blockquote><p><strong><font style="color:#C75C00;">raw.githubusercontent.com</font></strong> 是 GitHub 提供的一个服务，用于直接访问存储在 GitHub 仓库中的原始文件（如文本文件、脚本等），而无需下载整个仓库。在 React Native (RN) 开发环境中，这个 URL 常见于以下几种场景（文心一言生成，可了解）：</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>依赖管理工具安装</strong>: 如 Homebrew 安装脚本 <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>，Homebrew 是一个 macOS 下的包管理器，广泛用于安装 RN 开发所需的工具链和依赖，比如 Node.js、watchman、Yarn 或者其他 CLI 工具。</p></li><li class="lvl-2"><p><strong>脚本或配置文件获取</strong>: 在某些情况下，开发者可能会从 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> 直接拉取脚本或配置文件到本地，作为项目初始化的一部分或者是运行某些自动化任务的需要。</p></li><li class="lvl-2"><p><strong>快速分享和集成代码片段</strong>: 开发者可能会分享一些示例代码或者配置文件的链接，其他用户可以直接通过这些链接查看或下载内容，便于快速集成或参考。</p></li><li class="lvl-2"><p><strong>持续集成/部署脚本</strong>: 在 CI/CD 流程中，可能会使用此类链接来动态获取最新的脚本或配置，确保构建过程使用的是最新或指定版本的资源。</p></li></ul><p>其最显著的是我们在启动项目时，会自动将模拟器启动</p><p>问题分析</p><ul class="lvl-0"><li class="lvl-2"><p><font style="color:rgb(38, 38, 38);">为无法访问该域名的问题</font></p></li></ul><p>解决方案</p><ul class="lvl-0"><li class="lvl-2"><p>检查网络设置</p></li><li class="lvl-2"><p>使用代理服务</p></li><li class="lvl-2"><p>更换 DNS 服务器等方法来解决访问限制</p></li></ul><p>DNS 服务可能是 <strong>域名</strong> 与 <strong>ip</strong> 未绑定的原因</p><p>我们需要查看 <font style="color:#C75C00;background-color:rgb(249, 242, 244);">C:\Windows\System32\drivers\etc</font><code>里查看是否有</code><font style="color:rgb(199, 92, 0);">raw.githubusercontent.com</font> 与其对应的 <strong>ip</strong> 绑定，没有的话我们需要去查看 <font style="color:rgb(199, 92, 0);">raw.githubusercontent.com</font> 所对应的 <strong>ip</strong></p><ul class="lvl-0"><li class="lvl-2"><p>进入该网址 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a>，输入域名搜索<img data-src="/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/image.png" class="" title="RN问题解决"></p></li><li class="lvl-2"><p>下图所框便是其对应的 <strong>ip</strong><img data-src="/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/image-1.png" class="" title="RN问题解决"></p></li><li class="lvl-2"><p>在<font style="color:#C75C00;">C:\Windows\System32\drivers\etc</font> 里的 <font style="color:#C75C00;">hosts</font> 里最下面写入对应的配置，保存后重新创建项目</p></li></ul><blockquote><p>185.199.108.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p><p>185.199.109.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p><p>185.199.110.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p><p>185.199.111.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p></blockquote><h2 id="下载-gradle-x-x-all-zip-太慢">下载 <strong>gradle-x.x-all.zip 太慢</strong></h2><blockquote><p>Downloading <a href="https://services.gradle.org/distributions/gradle-8.6-all.zip">https://services.gradle.org/distributions/gradle-8.6-all.zip</a></p></blockquote><p><strong><font style="color:#000000;">解决方案</font></strong></p><ul class="lvl-0"><li class="lvl-2"><p>配置镜像</p></li><li class="lvl-2"><p>在 <font style="color:#C75C00;">[项目名]\android\gradle\wrapper\gradle-wrapper.properties</font> 中进行如下操作</p></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line"># 原网站下载</span><br><span class="line"># distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-8.6-all.zip</span></span><br><span class="line"># 配置阿里镜像下载</span><br><span class="line">distributionUrl=https\:<span class="comment">//mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.6-all.zip</span></span><br><span class="line"></span><br><span class="line">networkTimeout=<span class="number">10000</span></span><br><span class="line">validateDistributionUrl=<span class="keyword">true</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure><p>配置好之后仍满可以试试多次重新执行启动项目命令，当进度明显快了就可以了，第一次可能有点慢，因为要安装 <font style="color:#C75C00;">gradle-8.6-all.zip</font></p><h2 id="依赖库下载太慢">依赖库下载太慢</h2><p>解决方案</p><ul class="lvl-0"><li class="lvl-2"><p><font style="color:#C75C00;">[项目名]\android\build.gradle</font> 中 <font style="color:#C75C00;background-color:rgb(250, 250, 250);">repositories</font> <font style="color:rgb(38, 38, 38);background-color:rgb(250, 250, 250);">内有</font> <font style="color:#C75C00;background-color:rgb(250, 250, 250);">google()</font> <font style="color:rgb(38, 38, 38);background-color:rgb(250, 250, 250);">和</font> <font style="color:#C75C00;background-color:rgb(250, 250, 250);">mavenCentral()</font></p></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>google()</strong>: 这一行指定了Google的Maven仓库作为依赖项的来源。这对于下载Android SDK相关依赖、Jetpack库以及其他Google提供的库非常关键。</p></li><li class="lvl-2"><p><strong>mavenCentral()</strong>: 这一行指定了Maven中央仓库，它是Java开发中最常用的依赖库仓库，包含了大量开源库和框架。</p></li><li class="lvl-2"><p>但由于这两个仓库的服务器都在国外，我们也需要对其进行镜像处理，有两种解决方案：</p><ul class="lvl-2"><li class="lvl-4"><strong>局部配置</strong>：直接在 <font style="color:#DF2A3F;">build.gradle</font> 的 <font style="color:#DF2A3F;background-color:rgb(250, 250, 250);">repositories</font> <font style="color:rgb(38, 38, 38);background-color:rgb(250, 250, 250);">中修改</font></li><li class="lvl-4"><strong>全局配置</strong>： 在 <font style="color:#DF2A3F;">C:\Users[用户名].gradle</font> 文件夹下创建 <font style="color:#DF2A3F;">init.gradle</font> 文件，里面进行如下配置，这样我们就不需要每个项目都进行配置了</li></ul></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部配置</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/google&#x27;</span> &#125;</span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/jcenter&#x27;</span> &#125;</span><br><span class="line">    <span class="comment">// 此为阿里镜像下载源</span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://mirrors.aliyun.com/macports/distfiles/gradle/&#x27;</span> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局配置</span></span><br><span class="line"><span class="keyword">allprojects</span>&#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/central/&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> ALIYUN_JCENTER_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://repo1.maven.org/maven2&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://repo1.maven.org/maven2&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://jcenter.bintray.com/&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://jcenter.bintray.com/&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url ALIYUN_REPOSITORY_URL</span><br><span class="line">            url ALIYUN_JCENTER_URL</span><br><span class="line">            url <span class="string">&#x27;https://maven.aliyun.com/repository/google/&#x27;</span></span><br><span class="line">            url <span class="string">&#x27;https://maven.aliyun.com/repository/gradle-plugin/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">buildscript</span>&#123;</span><br><span class="line">        <span class="keyword">repositories</span> &#123;</span><br><span class="line">            <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/central/&#x27;</span></span><br><span class="line">            <span class="keyword">def</span> ALIYUN_JCENTER_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">            all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">                <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                    <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://repo1.maven.org/maven2&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://repo1.maven.org/maven2&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                        remove repo</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://jcenter.bintray.com/&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://jcenter.bintray.com/&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span></span><br><span class="line">                        remove repo</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url ALIYUN_REPOSITORY_URL</span><br><span class="line">                url ALIYUN_JCENTER_URL</span><br><span class="line">                url <span class="string">&#x27;https://maven.aliyun.com/repository/google/&#x27;</span></span><br><span class="line">                url <span class="string">&#x27;https://maven.aliyun.com/repository/gradle-plugin/&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="调试断开后设备上打开报错">调试断开后设备上打开报错</h2><p>当我们启动程序并连上设备后，我们可以看到页面资源，但当我们断开后再打开就会报错 <font style="color:#DF2A3F;"><strong>Unable to load script…</strong></font>，是因为我们的 <strong>JS代码和静态资源</strong> 并没有集成到Android项目中进行构建和发布</p><p>解决方案</p><ul class="lvl-0"><li class="lvl-2"><p>在 <font style="color:#DF2A3F;">[项目名]\android\app\src\main\</font> 目录下创建 <font style="color:#DF2A3F;">assets</font> 文件夹，并在下面创建 <font style="color:#DF2A3F;">index.android.bundle</font> 文件</p></li><li class="lvl-2"><p>然后在控制台<strong>项目根目录</strong>运行命令 <font style="color:#DF2A3F;">npx react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res</font></p></li><li class="lvl-2"><p>当我们再次运行时，即使断开我们也可以看到我们的资源</p></li></ul><h2 id="error-Error-connect-ETIMEDOUT-185-199-108-133-443">error Error: connect ETIMEDOUT 185.199.108.133:443</h2><p>过段时间重新尝试安装</p><h2 id="error-unknown-command-‘run-android’">error: unknown command ‘run-android’</h2><p>依赖包删除重新 <code>npm i</code> 或 <code>yarn</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> APP </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建RN项目</title>
      <link href="/2024/10/13/%E5%88%9B%E5%BB%BARN%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/10/13/%E5%88%9B%E5%BB%BARN%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Android-开发环境">Android 开发环境</h2><ul class="lvl-0"><li class="lvl-2">配置 Android 环境，请跟着<a href="https://reactnative.cn/docs/0.74/getting-started">文档</a>(0.74版本)进行</li></ul><span id="more"></span><h2 id="创建新项目">创建新项目</h2><ul class="lvl-0"><li class="lvl-2"><p>如果你之前全局安装过旧的react-native-cli命令行工具，请使用<code>npm uninstall -g react-native-cli</code>卸载掉它以避免一些冲突：<code>npm uninstall -g react-native-cli @react-native-community/cli</code></p></li><li class="lvl-2"><p>输入以下命令创建新项目<code>npx react-native@latest init [项目名]</code></p></li></ul><h2 id="创建项目指定版本号：-可选参数-指定版本或项目模板">创建项目指定版本号：[可选参数] 指定版本或项目模板</h2><ul class="lvl-0"><li class="lvl-2"><p>你可以使用–version参数（注意是两个杠）创建指定版本的项目。注意版本号必须精确到两个小数点：<code>npx react-native@X.XX.X init AwesomeProject --version X.XX.X</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> APP </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite 环境变量配置文件</title>
      <link href="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前提文档链接</p><p>Vite 环境变量和模式文档：<a href="https://vitejs.cn/vite3-cn/guide/env-and-mode.html#env-files">https://vitejs.cn/vite3-cn/guide/env-and-mode.html#env-files</a></p><hr><span id="more"></span><h2 id="开发环境与配置文件">开发环境与配置文件</h2><p>在项目开发中，我们往往需要在不同环境下使用不同的配置，比如开发环境、测试环境、生产环境等。</p><p>在项目开发中，常见的环境有</p><ul class="lvl-0"><li class="lvl-2"><p><code>dev</code> – 开发环境，外部用户无法访问，开发人员使用，版本变动大。</p></li><li class="lvl-2"><p><code>prod</code> – 生产环境，面向外部用户的环境，正式环境。</p></li><li class="lvl-2"><p><code>test</code> – 测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定。</p></li><li class="lvl-2"><p><code>sit (System Integration Test)</code> – 集成环境，系统集成测试，开发人员自己测试流程是否走通。</p></li><li class="lvl-2"><p><code>uat (User Acceptance Test environment)</code> – 用户验收测试环境，主要面向要交付的人员进行验证测试。</p></li><li class="lvl-2"><p><code>pre</code> – 灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样。</p></li><li class="lvl-2"><p><code>fat (Feature Acceptance Test environment)</code> – 功能验收测试环境，用于软件测试者测试使用。在以 <a href="https://vitejs.cn/">Vite</a> 作为构建工具开发项目时，环境变量配置文件名为 <code>.env</code>，文件名后缀为 <code>.env.[mode]</code>，其中 <code>mode</code> 为环境名称，如 <code>dev</code>、<code>prod</code>、<code>test</code> 等。</p></li></ul><p>根据 <code>mode</code> 的不同，可以配置不同的环境变量，例如</p><blockquote><p>.env.development<br>.env.production<br>.env.test</p></blockquote><p>默认情况下，Vite 会自动读取 <code>.env</code> 文件（通用配置），并根据 <code>NODE_ENV</code> 的值来确定当前环境。</p><p>但对于一份指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）。且相同的配置项，指定模式的文件会覆盖通用配置。</p><p>虽说环境有多种，但真正的开发模式只有两种</p><ul class="lvl-0"><li class="lvl-2"><p><code>development</code>：开发模式下</p></li><li class="lvl-2"><p><code>production</code>：生产模式下</p></li></ul><p>我们可以在不同的开发模式下配置多种环境，基于这种情况下，又习惯性的把 <code>开发环境</code> 和 <code>生产环境</code> 作为主环境，而在主环境下配置各种子环境，显示的把开发模式指定出来，便于开发人员理解，基于此，有些项目的环境目录会出现以下情况</p><blockquote><p>.env.development<br>.env.development.sit<br>.env.production<br>.env.production.uat</p></blockquote><h2 id="环境变量">环境变量</h2><p>在 Vite 中，环境变量的命名规则默认为 <code>VITE_</code> 开头，例如 <code>VITE_API_URL</code>。</p><p>官方解释</p><blockquote><p>为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码。例如下面这些环境变量：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; VITE_SOME_KEY=123</span><br><span class="line">&gt; DB_PASSWORD=foobar</span><br></pre></td></tr></table></figure><blockquote><p>只有 VITE_SOME_KEY 会被暴露为 import.meta.env.VITE_SOME_KEY 提供给客户端源码，而 DB_PASSWORD 则不会。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(import.meta.env.VITE_SOME_KEY) // 123</span><br><span class="line">&gt; console.log(import.meta.env.DB_PASSWORD) // undefined</span><br></pre></td></tr></table></figure><p>如果修改默认前缀，请参阅 <a href="https://vitejs.cn/vite3-cn/config/shared-options.html#envprefix">envprefix</a>。</p><h3 id="环境变量的使用">环境变量的使用</h3><p>在项目中，有些公共部分是需要我们抽离出来，作为环境变量进行配置，例如：<code>API_BASE_URL</code>，<code>ROUTE_BASE_URL</code>等等。</p><p>我们可以在 <code>.env.[mode]</code> 配置文件中填写</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VITE_APP_API_URL=http://x.x.x.x:xx</span><br><span class="line">VITE_ROUTE_BASE_URL=/xxx</span><br></pre></td></tr></table></figure><p>在项目中，我们可以通过 <code>import.meta.env.[变量名]</code> 来获取这些环境变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_APP_API_URL</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_ROUTE_BASE_URL</span>)</span><br></pre></td></tr></table></figure><h3 id="指定开发环境">指定开发环境</h3><p>我们可以通过获取这些环境变量以达到不同环境下使用不同变量的功能，但我们如何确定当前环境或者当前模式呢？</p><h4 id="指定开发环境的模式">指定开发环境的模式</h4><p>开发环境的模式需要在配置文件中配置 <code>NODE_ENV</code> 变量，Vite 会自动读取该变量，并根据该变量的值来确定当前开发模式，默认为 <code>development</code>。</p><p><code>NODE_ENV</code> 有两个值：</p><ul class="lvl-0"><li class="lvl-2"><p><code>development</code>：开发模式</p></li><li class="lvl-2"><p><code>production</code>：生产模式</p></li></ul><p>在有些时候，我们不需要进行显示的配置，Vite 内部会自动根据当前环境来确定开发模式。例如：</p><blockquote><p>默认情况下，开发服务器 (dev 命令) 运行在 development (开发) 模式，而 build 命令（打包命令）则运行在 production (生产) 模式。</p><p>这意味着当执行 vite build 时，它会自动加载 .env.production 中可能存在的环境变量。 ————<a href="https://vitejs.cn/vite3-cn/guide/env-and-mode.html#env-files">官方解释</a></p></blockquote><h4 id="指定环境类型">指定环境类型</h4><p>在上文我们提到了 <code>.env.[mode]</code> ，我们只需要改写 <code>mode</code> 值便可实现环境的创建，在真实情况下，<code>mode</code> 可以是任意值，但为了避免混淆，我们可以遵循以上的软规定。</p><p>通过改变 mode 的值便可创建一个环境，但除了 <code>.env.development</code> 和 .<code>env.production</code> 可以被 Vite 自动识别在 dev命令 和 build 命令情况下读取变量外，其他的 mode 配置只会根据 <code>NODE_ENV</code> 的值来识别其对应的配置文件。</p><p>我们还需要在启动命令中进行模式指定，在项目根目录的 <code>package.json</code> 中的执行脚本 <code>script</code> 中添加一条命令，如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dev-test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --mode test&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>通过指定 <code>--mode</code> 参数，Vite 就会根据当前启动命令指定的模式来加载对应的 Vite 项目中 <code>.env.[mode]</code> mode 指定的配置文件。</p><h4 id="示例">示例</h4><p>在 <code>.env.development</code> 中配置</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-2.png" class="" title="vite 环境变量配置文件"><p>我在封装的请求模块中引用 <code>VITE_APP_API_URL</code> 变量</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-1.png" class="" title="vite 环境变量配置文件"><p>通过 <code>npm run dev</code> 启动项目，在网络请求中的 <code>baseURL</code> 显示为 <code>http://10.111.11.11:8080</code></p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-3.png" class="" title="vite 环境变量配置文件"><p>我们更换环境</p><p>在 <code>.env.test</code> 中配置</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-4.png" class="" title="vite 环境变量配置文件"><p>在 <code>package.json</code> 中添加一条命令</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-5.png" class="" title="vite 环境变量配置文件"><p>运行 <code>npm run dev-test</code>，在网络请求中的 <code>baseURL</code> 显示为 <code>http://10.122.22.22:8001</code></p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-6.png" class="" title="vite 环境变量配置文件"><h4 id="注意事项">注意事项</h4><p>当前 <code>Vite</code> 版本执行打包命令时，如果在 <code>.env,production</code> 中指定了 <code>NODE_ENV:production</code>，会报错，只需把该配置删除即可，打包时还是会读取 <code>.env,production</code> 的配置。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
