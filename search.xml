<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS闭包</title>
      <link href="/2025/02/22/JS%E9%97%AD%E5%8C%85/"/>
      <url>/2025/02/22/JS%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="闭包的定义">闭包的定义</h2><details>    <summary>        <span>展开</span>    </summary><p>MDN中对于JS闭包的解释：</p><img data-src="/2025/02/22/JS%E9%97%AD%E5%8C%85/JS%E9%97%AD%E5%8C%85.png" class="" title="JS闭包"><p>词法环境即为函数定义时所在的作用域，也可以理解为VO。即一个函数，如果可以访问外部作用域的变量，那么该函数和周围环境的组合就是闭包。</p><p>从该定义来看，JS中的函数都具有闭包的特性，都可以称之为闭包。但从严格意义来讲，JS中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。</p></details><h2 id="闭包导致的内存泄露">闭包导致的内存泄露</h2><details>    <summary>        <span>展开</span>    </summary><p>以如下代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>bar函数与变量a形成了闭包，且通过bar引用了foo函数返回bar函数，在GO中存在bar对foo函数返回bar函数对象的引用，bar函数对象的<code>[[Scopes]]</code>属性又存在对foo函数的AO的引用，根据垃圾回收机制中标记清除算法的处理，bar变量即使以后未被调用，bar函数和foo函数的AO所占据的内存也不会被回收，就造成了内存泄漏。</p><p>所以，对于闭包的内存泄漏，其实就是引用链中的对象无法被释放。</p><p>解决方法：</p><p>手动进行<code>bar = null</code>，手动释放对对象的引用。</p></details><h2 id="常见的垃圾回收机制（GC）算法">常见的垃圾回收机制（GC）算法</h2><details>    <summary>        <span>展开</span>    </summary><p>垃圾回收机制（Garbage Collection）简称GC。</p><p>对于那些不再使用的对象，我们称之为垃圾，它需要被回收以释放更多的内存空间。</p><p>在JS中，内存管理是自动的、无形的，就是由于GC的存在帮我们自动管理内存。</p><p>常见的GC算法有：</p><ul class="lvl-0"><li class="lvl-2"><p>引用计数法</p><ul class="lvl-2"><li class="lvl-4">每当存在对象的引用时，相应对象引用计数加1，当引用计数为0时，该对象被回收。</li><li class="lvl-4">但容易产生循环引用，即两个对象的属性进行相互引用，形成环形链表，导致内存泄漏（两个引用对象的变量赋值为null，但其属性仍然存在引用，导致对象中的引用计数不为0）。</li></ul></li><li class="lvl-2"><p>标记清除法</p><ul class="lvl-2"><li class="lvl-4">核心思路为<mark>可达性</mark>。</li><li class="lvl-4">需要设置一个根对象（root object），在浏览器中为window，垃圾回收器会定时从根对象出发，找所有从根对象开始有引用的对象，对于没有引用的对象，就认为是不可用的对象，就会被垃圾回收其处理。</li></ul></li><li class="lvl-2"><p>标记整理法</p><ul class="lvl-2"><li class="lvl-4">在标记清除法类似，不同的是，在回收的同时会将保留的对象搬运到连续的内存空间中，整合空闲空间，避免碎片化。</li></ul></li><li class="lvl-2"><p>分代收集法</p></li><li class="lvl-2"><p>增量收集法</p><ul class="lvl-2"><li class="lvl-4">将回收分为几部处理，减少垃圾回收的延迟。</li></ul></li><li class="lvl-2"><p>闲时收集法</p><ul class="lvl-2"><li class="lvl-4">在CPU空闲的时候进行回收。</li></ul></li></ul></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS执行原理</title>
      <link href="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><details>    <summary>        <span>查看</span>    </summary><p>JS引擎内部有一个执行上下文栈(<code>Execution Context Stack</code>，简称ECS)，它是用于执行代码的调用栈。</p><p>其首先执行的为全局代码块，即<code>Global Execution Context(GEC)</code>全局执行上下文。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/ECS.png" class="" title="ECS"><p>在全局代码块执行前，或者说在parse转为AST过程中，会创建一个GO(Global Object)全局对象，将全局定义的变量、函数等加入到GO中，但此时仅仅为初始化，而不是赋值，即此时除了函数和内置对象(String、Data、parseInt等)，GO中的变量值为undefined。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/GO.png" class="" title="GO"><p>每一个执行上下文都会关联一个VO(<code>Variable Object</code>)变量对象，其对应的this和作用域链(<code>scope chain</code>)。</p><p>每当执行一个函数时，会创建一个函数执行上下文(<code>Function Execution Context</code>，简称FEC)加入到ECS中，并在堆内存中创建一个AO(<code>Activation Object</code>)活动对象，该AO会使用arguments作为初始化，初始值为该函数传入的参数形成的伪数组对象，此时VO指向该AO，存储该执行上下文变量的初始化。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/AO.png" class="" title="AO"><p>在全局执行上下文下(即全局代码被执行时)VO就是GO(<code>Global Object</code>)全局对象</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/%E5%85%A8%E5%B1%80VO.png" class="" title="全局VO"><p>当一个EC执行完后，会从ECS中弹出，与其VO关联的AO也会通过垃圾回收器清除。</p><p>每一个EC都会对应一个专属的AO，即使是同一个函数。</p><p>当代码被解析时，函数会被创建，但不会被执行，此时函数对象中会存在<code>[[Scopes]]</code>属性，其值为一个列表对象，即为函数该的作用域链(scope chain)，即函数的作用域链在定义的时刻就被创建，与其调用位置无关，与定义位置有关，当函数被调用，其成为FEC加入ECS中时，会创建<code>scope chain</code>，并将函数对象中<code>[[Scopes]]</code>属性的值赋值给FES中的<code>scope chain</code>，当执行过程中遇到属性调用，会先在此FEC关联的VO中查找，查找不到，便会通过<code>scope chain</code>向上查找。</p><img data-src="/2025/02/21/JS%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/scope_chain.png" class="" title="scope_chain"></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器基本原理</title>
      <link href="/2025/02/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2025/02/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="浏览器输入URL到页面展示过程">浏览器输入URL到页面展示过程</h2><details>   <summary>      <span>查看</span>   </summary><ol><li class="lvl-3"><p>输入URL并解析</p><ul class="lvl-2"><li class="lvl-5">检查输入内容是否为关键字(自动补全或跳转搜索引擎或进入浏览器设置页面)</li><li class="lvl-5">对URL进行合法性检查和格式化</li></ul></li><li class="lvl-3"><p>域名解析: 域名解析器(DNS: domain name system)将域名解析为IP地址, 浏览器通过IP地址访问服务器。</p></li><li class="lvl-3"><p>建立TCP连接(三次握手), 确保客户端与服务端双向通信能力。</p></li><li class="lvl-3"><p>发起HTTP/HTTPS请求。</p></li><li class="lvl-3"><p>服务器处理请求并返回响应。</p></li><li class="lvl-3"><p>浏览器解析与渲染。</p></li><li class="lvl-3"><p>加载动态资源与交互。</p></li><li class="lvl-3"><p>连接终止: TCP四次挥手。</p></li></ol></details><h2 id="浏览器渲染页面的的流程">浏览器渲染页面的的流程</h2><details>   <summary>      <span>查看</span>   </summary><p>从服务器获取到资源后</p><ol><li class="lvl-3"><p>创建DOM树: 解析HTML标签, 创建DOM树。</p></li><li class="lvl-3"><p>创建CSSOM树: 解析CSS样式, 创建CSSOM树。</p><ol><li class="lvl-6">当解析过程中发现存在link标签引用CSS文件时, 浏览器会向服务器请求CSS文件。</li><li class="lvl-6">对外部CSS资源的下载解析会交给其他进程处理, 并不会阻塞DOM树的解析。</li></ol></li><li class="lvl-3"><p>生成渲染树: 将DOM树和CSSOM树合并, 生成渲染树(rander tree)。</p><ol><li class="lvl-6">在此过程中, 渲染树的并不会存在每个节点的尺寸和位置信息。</li><li class="lvl-6">对于渲染树, 可能存在等待CSSOM树解析完毕倒是渲染树生成的不及时的情况。针对这一点, 浏览器可能会对其进行一些优化操作。</li></ol></li><li class="lvl-3"><p>布局(layout): 计算渲染树中每个节点的几何信息, 如宽高、位置等。</p></li><li class="lvl-3"><p>绘制(paint): 将每个节点绘制到屏幕上, 将进行布局操作后的渲染树的结果转为屏幕上实际的像素点</p><ol><li class="lvl-6">绘制过程是将元素的可见部分进行绘制, 如背景色、边框、文本、图片等。</li></ol></li><li class="lvl-3"><p>渲染页面: 将渲染树渲染到页面上。</p></li></ol></details><h2 id="回流-reflow-和重绘-repaint">回流(reflow)和重绘(repaint)</h2><details>   <summary>      <span>查看</span>   </summary><h3 id="回流-reflow">回流(reflow)</h3><ul class="lvl-0"><li class="lvl-2"><p>第一次确定节点的大小和位置, 称为布局。</p></li><li class="lvl-2"><p>之后对节点的大小和位置的修改, 称为回流(重排)。</p></li></ul><h4 id="回流-reflow-的触发方式">回流(reflow)的触发方式</h4><ul class="lvl-0"><li class="lvl-2"><p>DOM结构发生改变(添加或移除的节点)。</p></li><li class="lvl-2"><p>改变布局(修改元素的宽度、高度、位置、边框、margin、padding、字体大小等)</p></li><li class="lvl-2"><p>修改了窗口尺寸(resize)</p></li><li class="lvl-2"><p>查询元素的尺寸和位置信息(offsetWidth、offsetHeight、offsetLeft、offsetTopget、getComputedStyle等)</p></li></ul><h3 id="重绘-repaint">重绘(repaint)</h3><ul class="lvl-0"><li class="lvl-2"><p>第一次渲染称之为绘制(paint)。</p></li><li class="lvl-2"><p>之后重新渲染, 称为重绘。</p></li></ul><h4 id="重绘-repaint-的触发方式">重绘(repaint)的触发方式</h4><ul class="lvl-0"><li class="lvl-2"><p>修改了元素的背景色、边框颜色、字体颜色等。</p></li></ul><p><mark>回流一定会导致重绘</mark></p><p>回流是一件很耗性能的事情, 所以尽量避免。</p><p>建议:</p><ul class="lvl-0"><li class="lvl-2"><p>修改样式时尽量一次性修改。</p><ul class="lvl-2"><li class="lvl-4">比如通过cssText或添加class修改。</li></ul></li><li class="lvl-2"><p>尽量避免频繁的操作DOM。</p><ul class="lvl-2"><li class="lvl-4">比如通过DocumentFragment批量操作DOM或在父元素中将要操作的DOM操作完成,再一次性的操作。</li></ul></li><li class="lvl-2"><p>尽量避免通过getComputedStyle获取尺寸位置等信息。</p></li><li class="lvl-2"><p>对某些元素使用position的absolute或fixed。</p><ul class="lvl-2"><li class="lvl-4">其同样会造成回流, 但开销相对较小, 不会对其他元素产生影响。</li></ul></li></ul></details><h2 id="script标签的defer和async属性">script标签的defer和async属性</h2><details>   <summary>      <span>查看</span>   </summary><h3 id="defer">defer</h3><ul class="lvl-0"><li class="lvl-2"><p>defer属性会告诉浏览器不用等待脚本下载, 而是继续解析HTML, 构建DOM Tree。</p><ul class="lvl-2"><li class="lvl-4">脚本由浏览器来进行下载, 但不会阻塞DOM Tree的构建过程。</li><li class="lvl-4">如果脚本提前下载好, 他会等待DOM Tree的构建完成, 在DOMContentLoaded事件之前执行。</li><li class="lvl-4">所以DOMContentLoaded总是会等待defer中的代码先执行完成。</li></ul></li><li class="lvl-2"><p>对于多个defer的脚本, 浏览器会按照脚本的先后顺序执行。</p></li><li class="lvl-2"><p>由于设置defer后, 并不会阻塞DOM树的构建, 并且会交与浏览器对其下载, 所以推荐将设置defer的脚本放在head中, 减少其因下载损耗的事件, 一定程度上可以提高页面的性能。</p></li></ul><p><mark>注意: defer仅适用于外部脚本, 对于script默认内容会被忽略。</mark></p><h3 id="async">async</h3><ul class="lvl-0"><li class="lvl-2"><p>async是一个让脚本完全独立的:</p><ul class="lvl-2"><li class="lvl-4">浏览器不会因async脚本而阻塞。</li><li class="lvl-4">async脚本不能保证顺序, 它是独立下载, 独立运行, 不会等待其他脚本。</li><li class="lvl-4">async不能保证在DOMContentLoaded之前或之后执行。</li></ul></li></ul><h3 id="defer和async的使用场景">defer和async的使用场景</h3><ul class="lvl-0"><li class="lvl-2"><p>defer通常用于需要文档解析后操作DOM的JS代码, 并且对多个JS文件有顺序要求.</p></li><li class="lvl-2"><p>async通常用于独立的脚本, 对其他脚本, 甚至没有DOM依赖的。</p></li></ul></details>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点记录(个人理解)</title>
      <link href="/2024/11/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
      <url>/2024/11/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-字符实体">1. 字符实体</h2><p>字符实体即 html 中 <code>&amp;nbsp;</code> 这类的写法，以 <code>&amp;</code> 开始，以 <code>;</code> 结束。</p><p>出现原因：</p><blockquote><p>由于浏览器的识别和解析等原因，对于 <code>&lt;</code> 和 空格，换行的解析是有问题或合并操作的，但我们想要把其展示出来，就需要用到字符实体来编写了</p></blockquote><p>常见字符实体</p><img data-src="/2024/11/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93.png" class="" title="常见字符实体"><h2 id="2-URL-和-URI">2. URL 和 URI</h2><ul class="lvl-0"><li class="lvl-2"><p>URL = Uniform Resource Locator 为统一资源定位符，通常用于网络资源</p></li><li class="lvl-2"><p>URI = Uniform Resource Identifier 为统一资源标识符，可以标识逻辑和物理设备</p></li><li class="lvl-2"><p>URL 是 URI 的子集，即 URL 一定是 URI，但 URI 不一定是URL</p></li><li class="lvl-2"><p>比如当后端服务写一个接口后，前端可以通过浏览器访问该接口并得到返回值，这是URL</p></li><li class="lvl-2"><p>但服务器内部，可以得到某一图片等资源，即图片等资源会有一个标识交给服务器，服务器可以通过该标识访问到该资源，甚至是物理设备，这期间不一定有 WEB 的参与，这是URI</p></li></ul><p>URL 的完整标准格式：</p><blockquote><p><code>[协议类型]://[服务器地址]:[端口号]/[文件路径][文件名]?[查询]#[片段ID]</code><br>scheme://userinfo@host:port/path?query#fragment</p></blockquote><p>如： <code>https://zrb@www.example.com:123/forum/questions/tag=networking&amp;order=newest#top</code></p><h2 id="3-元素语义化的好处">3. 元素语义化的好处</h2><ul class="lvl-0"><li class="lvl-2"><p>方便维护，方便阅读</p></li><li class="lvl-2"><p>减少开发人员沟通</p></li><li class="lvl-2"><p>无障碍阅读，如对于盲人来说，浏览器会根据语义化标签选择语言表达方式，对于strong标签会进行重读</p></li><li class="lvl-2"><p>有利于SEO</p><ul class="lvl-2"><li class="lvl-4">浏览器搜索引擎有一定的规范，其利用爬虫技术对网页（文档）进行获取</li><li class="lvl-4">浏览器会根据其规则判断是否收录该网站并对其进行索引排名，语义化标签符合其中的部分规范，其排名也会较为靠前</li><li class="lvl-4">当用户搜索信息是，浏览器就会根据其排名展示（除去广告），我们得以免费获取流量</li></ul></li></ul><h2 id="4-字符编码">4. 字符编码</h2><p>对于计算机来说只能识别 0 和 1，但我们所写的内容怎样编码交给计算机，计算机又怎样解码以展示给我们，所以我们需要一定的规范将其编码为二进制（01），并使计算机能根据此规范将二进制（01）解码展示我们所写的内容。</p><p>目前基本上使用的是 UTF-8 ，依靠 unicode 字符集（万国码）。</p><h2 id="5-DNS解析">5. DNS解析</h2><p>浏览器通过域名获取资源时, 不会直接连接到服务器, 而是通过域名服务器（DNS）, DNS服务器会解析域名, 找到对应的IP地址, 并返回给浏览器, 浏览器再通过IP地址访问服务器。</p><p>域名的解析这一过程也是需要时间的, 我们可以尝试预解析域名, 以提高获取资源时的访问速度</p><p>可以通过对link标签设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch">dns-prefetch</a> 来进行优化, 如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://fonts.googleapis.com/&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-Number-prototype-toString-base-和-Number-prototype-toFixed-digits">6. Number.prototype.toString(base) 和 Number.prototype.toFixed(digits)</h2><p><code>toString(base)</code> 用于将数字转为字符串, 并且根据 base 值的不同可以将数字转为对应的进制, base 的范围为 2 到 36, 默认为 10<br><code>toFixed(digits)</code> 用于将数字转为字符串, 并且保留 digits 位小数, digits 的值为 0 到 20, 默认为 0</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp和taro学习知识点记录</title>
      <link href="/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="uniapp"><a href="https://uniapp.dcloud.net.cn/quickstart.html">uniapp</a></h2><ol><li class="lvl-3"><p>代码编写规范</p> <img data-src="/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/uniapp.png" class="" title="代码编写规范"></li><li class="lvl-3"><p>App.vue文件定义全局数据和公共样式</p></li><li class="lvl-3"><p>uni.scss文件定义全局变量</p><ul class="lvl-2"><li class="lvl-5">自定义全局变量</li><li class="lvl-5">覆盖 uni-app 内置全局变量</li><li class="lvl-5">覆盖 uni-ui 样式</li></ul></li><li class="lvl-3"><p><code>onLoad()&#123;&#125;</code> 为页面的生命周期函数</p></li><li class="lvl-3"><p>获取全局数据</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">getApp</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">globalData</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>获取当前路由</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pages = <span class="title function_">getCurrentPages</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pages)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>常用内置组件</p><ul class="lvl-2"><li class="lvl-5"><code>view</code>: 视图容器,类似于传统 html 中的 div (uniapp 可以使用 div,但 div 不跨平台,需要经过转译)</li><li class="lvl-5"><code>text</code>: 文本组件,用于包裹文本内容</li><li class="lvl-5"><code>button</code>: 按钮组件,但在小程序端的主题和其他端的主题不一样(可以通过条件编译来统一风格)</li><li class="lvl-5"><code>image</code>: 图片组件,默认宽度 320px,高度 240px,支持:<ul class="lvl-4"><li class="lvl-7">相对路径</li><li class="lvl-7">绝对路径</li><li class="lvl-7">导入</li><li class="lvl-7">base64码</li></ul></li><li class="lvl-5"><code>scroll-view</code>: 滚动容器,可设置横向或纵向滚动(scroll-y/x 必须存在,且容器要有高度/宽度)</li><li class="lvl-5"><code>swiper</code>: 轮播图组件</li></ul></li><li class="lvl-3"><p>路由跳转</p><ul class="lvl-2"><li class="lvl-6">navigate<ul class="lvl-4"><li class="lvl-8">保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。</li><li class="lvl-8">url: 需要跳转的应用内非 tabBar 的页面的路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’，path为下一个页面的路径，下一个页面的onLoad函数可得到传递的参数</li></ul></li><li class="lvl-6">redirect<ul class="lvl-4"><li class="lvl-8">关闭当前页面，跳转到应用内的某个页面。</li><li class="lvl-8">url: 需要跳转的应用内非 tabBar 的页面的路径，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 ‘path?key=value&amp;key2=value2’</li></ul></li><li class="lvl-6">switchTab<ul class="lvl-4"><li class="lvl-8">跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</li><li class="lvl-8">url: 需要跳转的 tabBar 页面的路径（需在 pages.json 的 tabBar 字段定义的页面），路径后不能带参数</li></ul></li></ul></li><li class="lvl-3"><p>常见通信方式</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>url查询字符串和<code>EventChannel</code></p><ul class="lvl-2"><li class="lvl-4"><p>通过查询字符串方式传递的参数获取方式,如: <code>/pages/index/index?id=1&amp;name=2</code></p><ul class="lvl-4"><li class="lvl-6">在<code>onLoad</code>页面生命周期中获取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(options) <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;2&#x27;&#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-4"><li class="lvl-6"><p>通过<code>props</code>获取</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">// &#123;id: &#x27;1&#x27;, name: &#x27;2&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li class="lvl-4"><p><code>EventChannel</code></p><ul class="lvl-4"><li class="lvl-6">Options 语法: <code>this.getOpenerEventChannel()</code></li><li class="lvl-6">Composition 语法: <code>getCurrentInstance().proxy.getOpenerEventChannel()</code></li></ul></li></ul></li><li class="lvl-2"><p>使用事件总线</p><ul class="lvl-2"><li class="lvl-4">uni.$emit(eventName,object): 触发全局的自定义事件</li><li class="lvl-4">uni.$on(eventName,callback): 监听全局的自定义事件,由 uni.$emit 触发</li><li class="lvl-4">uni.$off(eventName,callback): 移除全局的自定义事件监听器</li><li class="lvl-4">uni.$once(eventName,callback): 监听一个自定义事件，只能触发一次</li></ul></li><li class="lvl-2"><p>全局数据 <code>globalData</code></p><ul class="lvl-2"><li class="lvl-4">在<code>App.vue</code>中定义全局数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">globalData</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;big-dreamer&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>在其他页面中获取全局数据</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">getApp</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">globalData</span>); <span class="comment">// &#123;name: &#x27;big-dreamer&#x27;, age: 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>本地数据存储</p><ul class="lvl-2"><li class="lvl-4"><code>uni.setStorage(OBJECT)</code>: 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。</li><li class="lvl-4"><code>uni.setStorageSync(KEY, DATA)</code>: 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。</li><li class="lvl-4"><code>uni.getStorage(OBJECT)</code>: 从本地缓存中异步获取指定 key 对应的内容。</li><li class="lvl-4"><code>uni.getStorageSync(KEY)</code>: 从本地缓存中同步获取指定 key 对应的内容。</li><li class="lvl-4"><code>uni.removeStorage(OBJECT)</code>: 从本地缓存中异步移除指定 key。</li><li class="lvl-4"><code>uni.removeStorageSync(KEY)</code>: 从本地缓存中同步移除指定 key。</li></ul></li><li class="lvl-2"><p><code>Vuex</code> 和 <code>Pinia</code>,状态管理库</p><ul class="lvl-2"><li class="lvl-4"><code>Pinia</code> 在main.js中注册</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Pinia</span> <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">createSSRApp</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">createSSRApp</span>(<span class="title class_">App</span>)</span><br><span class="line">  app.<span class="title function_">use</span>(<span class="title class_">Pinia</span>.<span class="title function_">createPinia</span>())</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app,</span><br><span class="line">    <span class="title class_">Pinia</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>创建store</p></li><li class="lvl-4"><p>使用</p></li></ul></li></ul><h2 id="taro"><a href="https://docs.taro.zone/docs/">taro</a></h2><p>建议使用 taro 开发小程序,其对于 h5 和 APP 的多端兼容不太好</p><h3 id="开始使用-taro">开始使用 taro</h3><ol><li class="lvl-3"><p>安装 CLI</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @tarojs/cli</span><br><span class="line">或</span><br><span class="line">yarn global add @tarojs/cli</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>创建项目</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taro init myApp</span><br><span class="line">或</span><br><span class="line">npx @tarojs/cli init myApp</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>启动项目</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>启动小程序 <code>npm run dev:weapp</code></p></li><li class="lvl-2"><p>启动 H5 端 <code>npm run dev:h5</code></p></li></ul><h3 id="知识点记录">知识点记录</h3><ol><li class="lvl-3"><p>Taro + React 开发规范</p> <img data-src="/2024/11/13/uniapp%E5%92%8Ctaro%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/taro.png" class="" title="Taro + React 开发规范"></li><li class="lvl-3"><p>新建页面 <code>Taro create --name [页面名称]</code></p></li><li class="lvl-3"><p>通信方式</p><ul class="lvl-2"><li class="lvl-5"><p>url查询字符串和只支持小程序端的 <code>EventChannel</code></p><ul class="lvl-4"><li class="lvl-7">通过查询字符串方式传递的参数获取方式,如: <code>/pages/index/index?id=1&amp;name=2</code></li><li class="lvl-7">通过 <code>onLoad</code>,<code>useLoad</code> 生命周期获取路由参数</li><li class="lvl-7">通过 <code>Taro.getCurrentInstance().router.params</code> 获取</li><li class="lvl-7">EventChannel 和 uniapp 语法相似,把 uniapp 换为 Taro</li></ul></li><li class="lvl-5"><p>使用全局事件总线 <code>Taro.eventCenter</code></p><ul class="lvl-4"><li class="lvl-7"><code>Taro.eventCenter.on(eventName,function)</code>: 监听事件</li><li class="lvl-7"><code>Taro.eventCenter.trigger(eventName,object)</code>: 触发全局的自定义事件</li><li class="lvl-7"><code>Taro.eventCenter.trigger(eventName,object)</code>: 取消监听事件</li></ul></li></ul></li><li class="lvl-3"><p>跨端兼容方案</p><ul class="lvl-2"><li class="lvl-7">内置环境变量 <code>process.env.TARO_ENV</code>,通过 if 对其值进行判断</li><li class="lvl-7">统一接口的多端文件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 多端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
            <tag> taro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React常用技术栈</title>
      <link href="/2024/11/08/React%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2024/11/08/React%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="创建项目环境">创建项目环境</h2><h3 id="创建项目">创建项目</h3><h4 id="Create-React-App-CRA"><a href="https://create-react-app.bootcss.com/">Create-React-App (CRA)</a></h4><ul class="lvl-0"><li class="lvl-2"><p>使用了 Webpack、Babel、ESLint 和其他优秀的项目作为基础层</p></li><li class="lvl-2"><p>创建项目命令</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><h4 id="Vite"><a href="https://cn.vitejs.dev/">Vite</a></h4><ul class="lvl-0"><li class="lvl-2"><p>创建项目命令</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest my-app -- --template react</span><br></pre></td></tr></table></figure><h4 id="Next-js"><a href="https://www.nextjs.cn/">Next.js</a></h4><p>介绍</p><blockquote><p>Next.js 为您提供生产环境所需的所有功能以及最佳的开发体验：包括静态及服务器端融合渲染、 支持 TypeScript、智能化打包、 路由预取等功能 无需任何配置。</p><p>适用于简单的<mark>C端</mark>应用</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>创建项目命令</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest</span><br><span class="line"># or</span><br><span class="line">yarn create next-app</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>创建 TS 项目</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest --typescript</span><br><span class="line"># or</span><br><span class="line">yarn create next-app --typescript</span><br></pre></td></tr></table></figure><h3 id="代码规范">代码规范</h3><h4 id="ESLint"><a href="https://zh-hans.eslint.org/docs/latest/use/getting-started">ESLint</a></h4><p>介绍</p><blockquote><p>ESLint 是一个根据方案识别并报告 ECMAScript/JavaScript 代码问题的工具，其目的是使代码风格更加一致并避免错误</p></blockquote><h4 id="Prettier"><a href="https://www.prettier.cn/">Prettier</a></h4><p>介绍</p><blockquote><p>Prettier 是一款代码格式化工具，可以将项目代码格式统一化,并且美化代码</p></blockquote><h4 id="Husky"><a href="https://husky.nodejs.cn/get-started.html">Husky</a></h4><p>介绍</p><blockquote><p>Husky 是一个 Git Hooks 工具，它允许您在 Git 提交之前运行脚本，在提交或推送时自动检查你的提交消息、代码并运行测试。</p></blockquote><h4 id="commit-lint"><a href="https://commitlint.js.org/">commit-lint</a></h4><p>介绍</p><blockquote><p>commitlint 是一个 git commit 校验约束工具。</p></blockquote><h3 id="扩展配置">扩展配置</h3><h4 id="craco-js"><a href="https://craco.js.org/">craco.js</a></h4><p>介绍</p><blockquote><p>由于 CRA 的配置是被隐藏的,我们不应把它显示出来并对其进行修改,于是出现了 craco.js<br>通过 craco，开发者可以使用自定义覆盖原先配置，以满足项目的特定需求。例如：可以添加自定义 webpack 的 loader，plugin，修改 webpack 的输出路径等。</p></blockquote><h2 id="React-基础">React 基础</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn#writing-markup-with-jsx">JSX 语法</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn#components">函数组件</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn/passing-props-to-a-component">props</a></p></li><li class="lvl-2"><p><a href="https://www.tslang.cn/">typescript</a></p></li><li class="lvl-2"><p><a href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?utm_source=ext_app_menu">开发者工具(React Developer Tools)</a></p></li></ul><h2 id="Hooks">Hooks</h2><h3 id="必备">必备</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useState">useState</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useEffect">useEffect</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useRef">useRef</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component">自定义 Hook</a></p></li></ul><h3 id="了解">了解</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useMemo">useMemo</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useCallback">useCallback</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useContext">useContext</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useReducer">useReducer</a><br>…</p></li></ul><h3 id="Hooks-规则">Hooks 规则</h3><ul class="lvl-0"><li class="lvl-2"><p>必须用 useXxx 格式来命名</p></li><li class="lvl-2"><p>只能在 <mark>组件内</mark> 和 <mark>其他Hook</mark> 中调用 Hook</p></li><li class="lvl-2"><p>必须保证每次的调用顺序一致 (不能放在 if/for 中)</p></li></ul><h3 id="hooks-库">hooks 库</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://ahooks.js.org/zh-CN/">ahooks</a></p><ul class="lvl-2"><li class="lvl-4">国内</li><li class="lvl-4">推荐</li></ul></li><li class="lvl-2"><p><a href="https://www.reactuse.com/zh-Hans/category/state">react-use</a></p></li></ul><h2 id="CSS-样式">CSS 样式</h2><h3 id="普通-CSS">普通 CSS</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS 样式指南</a></p><h3 id="CSS-Module">CSS-Module</h3><ul class="lvl-0"><li class="lvl-2"><p>CRA 内置,样式文件命名未<code>xxx.module.css</code></p></li><li class="lvl-2"><p>在 tsx 中通过 <code>import xxx from './xxx.module.css</code> 方式引入</p></li><li class="lvl-2"><p>在组件中通过 <code>className=&#123;xxx.xxx&#125;</code> 引入</p></li><li class="lvl-2"><p>样式名会自动添加前缀，避免样式冲突</p></li></ul><h3 id="CSS-in-JS">CSS-in-JS</h3><blockquote><p>最初网页开发有一个原则,叫做 <a href="https://en.wikipedia.org/wiki/Separation_of_concerns#HTML,_CSS,_JavaScript">关注点分离</a>,但 React 出现后,这个原则便不再使用了,因为 React 的组件化设计已经将关注点分离了,组件的样式应该与组件本身一起放在一起,而不是通过 CSS 文件来引入。</p></blockquote><p>在思想上 CSS in JS 和 JSX 差不多，简单来说，就是在 JS 环境中写 CSS 相关的样式</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://styled-components.com/">styled-components</a></p></li><li class="lvl-2"><p><a href="https://github.com/vercel/styled-jsx">styled-jsx</a></p></li><li class="lvl-2"><p><a href="https://emotion.sh/docs/introduction">emotion</a></p></li></ul><p>优点:</p><ul class="lvl-0"><li class="lvl-2"><p>用 js 写,有逻辑有变量,非常灵活</p></li></ul><p>缺点:</p><ul class="lvl-0"><li class="lvl-2"><p>JSX 和样式代码混在一块,代码较多,增加了编译成本</p></li></ul><h3 id="classnames"><a href="https://www.npmjs.com/package/classnames">classnames</a></h3><p>介绍</p><blockquote><p>classnames用于动态添加类名</p></blockquote><h2 id="路由">路由</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://reactrouter.com/en/main">React-Router</a></p></li><li class="lvl-2"><p>路由嵌套和 <a href="https://reactrouter.com/en/main/components/outlet#outlet">Outlet</a></p></li><li class="lvl-2"><p>动态路由</p></li><li class="lvl-2"><p>页面跳转</p></li><li class="lvl-2"><p>获取参数</p></li></ul><h2 id="UI-组件库">UI 组件库</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://ant.design/components/overview-cn/">Ant Design</a>(国内)</p></li><li class="lvl-2"><p><a href="https://mui.com/material-ui/">Material-UI</a>(国外)</p></li><li class="lvl-2"><p><a href="https://www.tailwindcss.cn/">Tailwind CSS</a>(补充)</p></li></ul><h2 id="表单组件">表单组件</h2><ul class="lvl-0"><li class="lvl-2"><p>受控组件</p></li></ul><blockquote><p>受控组件是指在 React 中，表单元素的值由 React 组件的 state 管理的组件。这意味着表单元素的值是由 React 组件的状态决定的，而不是由 DOM 本身决定的。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><a href="https://ant.design/components/form-cn#form-demo-nest-messages">AntDesign-Form-rules</a></p></li><li class="lvl-2"><p><a href="https://react-hook-form.com/get-started#SchemaValidation">React-hook-form</a></p></li><li class="lvl-2"><p><a href="https://formik.nodejs.cn/docs/guides/form-submission#e9aa8ce8af81">Formik</a></p></li></ul><h2 id="Ajax-网络请求">Ajax 网络请求</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></p></li><li class="lvl-2"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">Fetch</a></p></li><li class="lvl-2"><p><a href="https://www.axios-http.cn/">Axios</a></p></li><li class="lvl-2"><p><a href="https://ahooks.js.org/zh-CN/guide/upgrade#%E5%85%A8%E6%96%B0%E7%9A%84-userequest">useRequest (ahooks)</a></p></li><li class="lvl-2"><p><a href="http://mockjs.com/">Mock.js</a></p></li><li class="lvl-2"><p><a href="https://www.postman.com/">Postman (接口调试工具)</a></p></li><li class="lvl-2"><p><a href="https://javaguide.cn/system-design/basis/RESTfulAPI.html">Restful API</a></p></li><li class="lvl-2"><p><a href="https://jwt.io/">JWT</a> 用户校验</p></li></ul><h2 id="状态管理">状态管理</h2><ul class="lvl-0"><li class="lvl-2"><p>状态提升</p></li></ul><blockquote><p>状态提升是指将多个组件中需要共享的状态提升到它们的最近共同父组件中进行管理。这样可以确保这些组件能够访问和修改相同的状态，从而实现数据的同步和共享。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useContext">useContext</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useReducer">useReducer</a></p></li><li class="lvl-2"><p><a href="https://cn.redux.js.org/">Redux</a></p></li><li class="lvl-2"><p><a href="https://cn.mobx.js.org/">Mobx</a></p></li><li class="lvl-2"><p><a href="https://immerjs.github.io/immer/zh-CN/">Immer</a></p></li></ul><blockquote><p>Immer 是一个用于简化不可变数据操作的 JavaScript 库。它允许你在不可变数据结构上进行可变操作，同时自动产生新的不可变数据结构。这使得编写不可变数据管理的代码变得更加简单和直观</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><a href="https://redux-undo.js.org/">Redux-undo</a>: Redux State Container 的简单撤消/重做功能</p></li></ul><h2 id="拖拽排序">拖拽排序</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://react-dnd-cn.js.org/">React-dnd</a></p></li><li class="lvl-2"><p><a href="https://www.npmjs.com/package/react-beautiful-dnd">React-beautiful-dnd</a></p></li><li class="lvl-2"><p><a href="https://www.itxst.com/sortablejs/neuinffi.html">Sortable.js</a></p></li><li class="lvl-2"><p><a href="https://www.npmjs.com/package/react-sortable-hoc">React-sortable-hoc</a></p></li><li class="lvl-2"><p><a href="https://dndkit.com/">dnd-kit</a>(推荐)</p></li></ul><h2 id="可视化图表">可视化图表</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.npmjs.com/package/react-chartjs-2">react-chartjs-2</a></p></li><li class="lvl-2"><p><a href="https://recharts.org/en-US/">Recharts</a></p></li><li class="lvl-2"><p><a href="https://www.npmjs.com/package/echarts-for-react">echarts-for-react</a></p></li></ul><h2 id="性能优化">性能优化</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useMemo">useMemo</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/useCallback">useCallback</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/memo">React.memo</a></p></li><li class="lvl-2"><p><a href="https://create-react-app.dev/docs/analyzing-the-bundle-size/">analyzing-the-bundle-size</a></p></li><li class="lvl-2"><p><a href="https://zh-hans.react.dev/reference/react/lazy">lazy 路由懒加载</a></p></li><li class="lvl-2"><p>抽离公共代码进行缓存(craco 中配置,webpackConfig.optimization.splitChunks)</p></li></ul><h2 id="测试">测试</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.jestjs.cn/">jest</a></p></li><li class="lvl-2"><p><a href="https://testing-library.com/docs/react-testing-library/intro">React-Testing-Library</a></p></li><li class="lvl-2"><p>pre-commit 自动化测试</p></li><li class="lvl-2"><p><a href="https://storybook.nodejs.cn/">storybook</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React18 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="/2024/10/24/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2024/10/24/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul class="lvl-0"><li class="lvl-2"><p>拷贝就是创建一个已有对象或数据结构的副本的过程，即拷贝是相对于引用类型而言的。</p></li><li class="lvl-2"><p>对于 JS 来说，浅拷贝仅复制对象的第一层属性，对于其对象属性，复制的是其存储的地址值。因此，通过浅拷贝得到的副本，修改其内部的对象属性，也会影响原对象。</p></li><li class="lvl-2"><p>深拷贝会复制对象的所有属性，包括第一层中的对象属性，即对象属性会在堆区开辟新的空间（新的地址值）,其存储值与被拷贝的内容相同，因此，通过深拷贝得到的副本，修改其内部的对象属性，不会影响原对象。</p></li></ul><span id="more"></span><h2 id="浅拷贝的实现">浅拷贝的实现</h2><h3 id="1-使用-Object-assign">1. 使用 <code>Object.assign()</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign()</a> 静态方法将一个或者多个源对象中所有<mark>可枚举的自有属性</mark>复制到目标对象，并返回修改后的目标对象。</p><p>语法</p><blockquote><p>Object.assign(target, …sources)</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>target：需要应用源对象属性的目标对象，修改后将作为返回值。</p></li><li class="lvl-2"><p>sources：一个或多个包含要应用的属性的源对象。</p></li></ul><p>如果目标对象与源对象具有相同的键（属性名），则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的同名属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;name: &#x27;1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>字符串和 Symbol 类型属性都会被复制。</p><div class="tips"><p><code>Object.assign()</code> 不会在源对象值为 null 或 undefined 时抛出错误。基本类型将被封装，只有字符串封装对象才拥有可枚举的自有属性。因此，除了字符串，其他基本类型都不会被处理。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// &#123;0: &#x27;c&#x27;, 1: &#x27;d&#x27;, 2: &#x27;e&#x27;, 3: &#x27;3&#x27;, 4: &#x27;4&#x27;, a: 1, b: 2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    <span class="string">&quot;cde34&quot;</span>,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    <span class="number">11</span>,</span><br><span class="line">    <span class="title class_">Symbol</span>(<span class="string">&#x27;11&#x27;</span>),</span><br><span class="line">    <span class="number">11n</span>));</span><br></pre></td></tr></table></figure><p>特点：</p><ul class="lvl-0"><li class="lvl-2"><p>合并具有相同属性的对象，属性会被后续参数中具有相同属性的其他对象覆盖。</p></li><li class="lvl-2"><p>可以拷贝 Symbol 类型属性。</p></li><li class="lvl-2"><p>原型链上的属性和不可枚举的属性不能被复制。</p></li><li class="lvl-2"><p>基本类型会被封装为对象。</p></li><li class="lvl-2"><p>异常会中断后续的复制。</p></li></ul><h3 id="2-使用扩展运算符">2. 使用扩展运算符 <code>...</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法 (Spread syntax)</a>, 可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开。(译者注: 字面量一般指 [1, 2, 3] 或者 {name: “mdn”} 这种简洁的构造方式)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr];</span><br><span class="line">arr2.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// (4) [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 数组合并</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr4 = [...arr2, ...arr3]; <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&quot;baz&quot;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象：&#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象：&#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ul class="lvl-0"><li class="lvl-2"><p>只能用于可迭代对象，扩展运算符只能拷贝对象自身的并且可枚举的属性。</p></li><li class="lvl-2"><p>Object.assign() 函数会触发 setters，而展开语法则不会。</p></li><li class="lvl-2"><p>不能替换或者模拟 Object.assign() 函数</p></li><li class="lvl-2"><p>在函数调用时使用展开语法，请注意不能超过 JavaScript 引擎限制的最大参数个数（调用具有太多参数的函数（即超过数万个参数）的后果是未指定的，并且在不同的引擎中会有所不同。）</p></li></ul><h3 id="3-手写实现浅拷贝">3. 手写实现浅拷贝</h3><p>在展开语法出来之前，我们想将已有数组或对象变成新数组或对象的一部分较为麻烦</p><ul class="lvl-0"><li class="lvl-2"><p>对数组，我们可以使用 Array.prototype.concat() 或 Array.prototype.slice() 方法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>对对象</p></li></ul><h2 id="深拷贝的实现">深拷贝的实现</h2><h3 id="1-JSON-stringify">1. <code>JSON.stringify()</code></h3><h3 id="2-函数库lodash">2. 函数库lodash</h3><h3 id="3-手写实现深拷贝">3. 手写实现深拷贝</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面经 </category>
          
          <category> 深拷贝与浅拷贝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题-类型判断</title>
      <link href="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-typeof-与-instanceof-类型判断">1. <code>typeof</code> 与 <code>instanceof</code> 类型判断</h2><details>   <summary>      <span>查看</span>   </summary><blockquote><p><code>typeof</code> 是否能正确判断类型？<code>instanceof</code>能否正确判断对象的原理是什么？</p></blockquote><p><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型。判断 <code>null</code> 对应的结果为 <code>object</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;1&quot;</span>); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>()); <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">10n</span>); <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image.png" class="" title="typeof 与 instanceof 类型判断"><p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 不能准确判断对象的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-1.png" class="" title="typeof 与 instanceof 类型判断"><p>所以 <code>typeof</code> 不能正确判断类型。</p><blockquote><p>如果我们想判断一个对象的正确类型，我们可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的。但对于原始数据类型，使用 <code>instanceof</code> 是无法判断的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-2.png" class="" title="typeof 与 instanceof 类型判断"><div class="warning"><p><strong>注意：</strong><br><code>instanceof</code> 可以判断对象的正确类型，但由于原型链的关系，对于其类型的父类进行判断也是返回 <code>true</code>。</p></div><h3 id="手动实现-function-isInstanceOf-child-Parent">手动实现 function isInstanceOf(child,Parent)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInstanceof</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">   <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">   <span class="keyword">let</span> <span class="title class_">ParentProto</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">   <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">   <span class="title class_">Child</span> = <span class="title class_">Child</span>.<span class="property">__proto__</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ParentProto</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Child</span>);</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="title class_">Child</span> === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="title class_">Child</span> === <span class="title class_">ParentProto</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="title class_">Child</span> = <span class="title class_">Child</span>.<span class="property">__proto__</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始测试</span></span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">child</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">father</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">child.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">father</span>()</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title function_">child</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(a, <span class="title class_">Array</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(b, <span class="title class_">Object</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(b, <span class="title class_">Array</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(a, <span class="title class_">Object</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(c, <span class="title class_">Foo</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(d, child)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isInstanceof</span>(d, father)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></details><h2 id="2-、-、Object-is-的区别">2. <code>==</code> 、<code>===</code> 、<code>Object.is()</code> 的区别</h2><h3 id=""><code>==</code></h3><details><summary>查看</summary>相等（==）运算符（宽松比较）检查其两个操作数是否相等，返回一个布尔值结果。当比较双方数据类型不同时，它会尝试转换不同类型的操作数，并进行比较<h4 id="比较规则"><code>==</code> 比较规则</h4><ol><li class="lvl-3"><p>如果操作数具有相同的类型，则按如下方式进行比较：</p><ul class="lvl-2"><li class="lvl-5">对象（Object）：仅当两个操作数引用同一个对象时返回 true。</li><li class="lvl-5">字符串（String）：仅当两个操作数具有相同的字符且顺序相同时返回 true。</li><li class="lvl-5">数字（Number）：如果两个操作数的值相同，则返回 true。+0 和 -0 被视为相同的值。如果任何一个操作数是 NaN，返回 false；所以，<mark>NaN 永远不等于 NaN</mark>。</li><li class="lvl-5">布尔值（Boolean）：仅当操作数都为 true 或都为 false 时返回 true。</li><li class="lvl-5">大整型（BigInt）：仅当两个操作数的值相同时返回 true。</li><li class="lvl-5">符号（Symbol）：仅当两个操作数引用相同的符号时返回 true。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>如果其中一个操作数为 null 或 undefined，另一个操作数也必须为 null 或 undefined 以返回 true。否则返回 false。（null 和 undefined 除了与null 和 undefined 比较为 true，其他值都返回 false）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> d = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == c); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b == d); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>如果其中一个操作数是对象，另一个是原始值，则将对象转换为原始值。</p><ul class="lvl-2"><li class="lvl-6">在这一步，两个操作数都被转换为原始值（字符串、数字、布尔值、符号和大整型中的一个）。剩余的转换将分情况完成。<ul class="lvl-4"><li class="lvl-8">如果是相同的类型，使用步骤 1 进行比较。</li><li class="lvl-8">如果其中一个操作数是符号(Symbol)而另一个不是，返回 false。</li><li class="lvl-8">如果其中一个操作数是布尔值而另一个不是，则将布尔值转换为数字：<mark>true 转换为 1，false 转换为 0</mark>。然后再次对两个操作数进行宽松比较。</li><li class="lvl-8">数字与字符串：<mark>将字符串转换为数字</mark>。转换失败将导致 NaN，这将保证相等比较为 false。</li><li class="lvl-8">数字与大整型：按数值进行比较。如果数字的值为 ±∞ 或 NaN，返回 false。</li><li class="lvl-8">字符串与大整型：<mark>使用与 BigInt() 构造函数相同的算法将字符串转换为大整型数</mark>。如果转换失败，返回 false。</li></ul></li></ul></li></ol><div class="tips"><p><strong>对象转为原始值</strong><br>对象将依次调用它的 <code>[Symbol.toPrimitive]()</code>（将 default 作为 hint 值）、valueOf() 和 toString() 方法，将其转换为原始值。<mark>注意，原始值转换会在 toString() 方法之前调用 valueOf() 方法</mark>。<br><code>[Symbol.toPrimitive]()</code> 方法，如果存在，则必须返回原始值，返回对象，会导致 TypeError。<mark>对于 valueOf() 和 toString()，如果其中一个返回对象，则忽略其返回值，从而使用另一个的返回值；如果两者都不存在，或者两者都没有返回一个原始值，则抛出 TypeError</mark>。</p></div><p><strong>示例</strong></p><p>定义一个干净的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">valueOf</span>()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>实现该对象的<code>[Symbol.toPrimitive]</code>方法，使其返回一个原始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">   [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">         <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处运用了隐式转换 导致使用强制数字类型转换算法 使得能满足 hint===&#x27;number&#x27; 条件        </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+a == <span class="number">42</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 此处 new String 导致使用强制字符串类型转换算法 使得能满足 hint===&#x27;string&#x27; 条件 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">String</span>(a) == <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><div class="warning"><p><strong>注意</strong><br>当未对对象使用强制类型转换时，会返回默认值。但<code>Symbol.toPrimitive</code> 返回的 null 或 undefined 与 null 和 undefined 进行宽松比较(==)时仍为 false，hint 值是 number 时，返回的必须是数字字符串或数字，否则与数字或数字字符串进行宽松比较时仍为 false</p></div><div class="tips"><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date">Symbol</a> 对象是唯一重写 <code>[Symbol.toPrimitive]()</code> 方法的对象。</p><p>对于 Date，如果 hint 是 “string” 或 “default”，<code>[Symbol.toPrimitive]()</code> 将会调用 toString。如果 toString 属性不存在，则调用 valueOf。如果 valueOf 也不存在，则抛出一个TypeError。</p><p>对于 Symbol，hint 参数未使用时，Symbol 的 <code>[Symbol.toPrimitive]()</code> 方法返回 Symbol 对象的原始值作为数据类型返回。</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">sym === sym[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当对象不存在<code>Symbol.toPrimitive</code>时，会根据 <code>toString()</code> 和 <code>valueOf()</code> 的返回值作为原始值进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">      <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">42</span>); <span class="comment">// true</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// false</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">String</span>(a) == <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div class="tips"><p>一般来说，valueOf 的优先级高于 toString。但当其使用强制字符串类型转换时，会根据 toString 的返回值作为原始值进行比较。</p></div></details><h3 id="-2"><code>===</code></h3><details><summary>查看</summary>严格相等（===）运算符与 == 运算符之间最显著的区别是，严格相等运算符不尝试类型转换。相反，严格相等运算符总是认为不同类型的操作数是不同的，即只要类型不同进行 `===` 操作时，结果即为 `false`。严格相等运算符本质上只执行第 1 步，然后对所有其他情况返回 `false`。<div class="warning"><p>上面的算法有一个“故意违反”：如果其中一个操作数是 document.all，则它被视为 undefined。这意味着 document.all == null 是 true，但 document.all === undefined &amp;&amp; document.all === null 是 false。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">MDN文章描述</a></p></div><h4 id="比较规则-2"><code>===</code> 比较规则</h4><ul class="lvl-0"><li class="lvl-2"><p>如果操作数的类型不同，则返回 false。</p></li><li class="lvl-2"><p>如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。</p></li><li class="lvl-2"><p>如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。</p></li><li class="lvl-2"><p>如果两个操作数有任意一个为 NaN，返回 false。</p></li><li class="lvl-2"><p>否则，比较两个操作数的值：</p><ul class="lvl-2"><li class="lvl-4"><mark>数字类型必须拥有相同的数值。+0 和 -0 会被认为是相同的值。</mark></li><li class="lvl-4">字符串类型必须拥有相同顺序的相同字符。</li><li class="lvl-4">布尔运算符必须同时为 true 或同时为 false。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> === +<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></details><h3 id="Object-is"><code>Object.is()</code></h3><details><summary>查看</summary><p><code>Object.is()</code> 静态方法确定两个值是否为相同值。</p><h4 id="Object-is-的比较规则"><code>Object.is()</code>的比较规则</h4><p>如果出现以下几种情况，则返回 true，即比较的两个值相同</p><ul class="lvl-0"><li class="lvl-2"><p>都是 undefined</p></li><li class="lvl-2"><p>都是 null</p></li><li class="lvl-2"><p>都是 true 或者都是 false</p></li><li class="lvl-2"><p>都是长度相同、字符相同、顺序相同的字符串</p></li><li class="lvl-2"><p>都是相同的对象（意味着两个值都引用了内存中的同一对象）</p></li><li class="lvl-2"><p>都是 BigInt 且具有相同的数值</p></li><li class="lvl-2"><p>都是 symbol 且引用相同的 symbol 值</p></li><li class="lvl-2"><p>都是数字且</p><ul class="lvl-2"><li class="lvl-4">都是 +0</li><li class="lvl-4">都是 -0</li><li class="lvl-4">都是 NaN</li><li class="lvl-4">都有相同的值，非零且都不是 NaN</li></ul></li></ul><p><code>Object.is()</code> 与 == 运算符并不等价。== 运算符在测试相等性之前，会对两个操作数进行类型转换（如果它们不是相同的类型），这可能会导致一些非预期的行为，例如 “” == false 的结果是 true，但是 <code>Object.is()</code> 不会对其操作数进行类型转换。</p><p><code>Object.is()</code> 也不等价于 === 运算符。<code>Object.is()</code> 和 === 之间的<mark>唯一区别在于它们处理带符号的 0 和 NaN 值的时候</mark>。=== 运算符（和 == 运算符）将数值 -0 和 +0 视为相等，但是会将 NaN 视为彼此不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="number">0</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">Number</span>.<span class="property">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></details><h3 id="总结">总结</h3><div class="tips"><p>对于 <code>==</code>，主要特点就是类型转换，而 <code>===</code> 和 <code>Object.is()</code> 则不进行类型转换。</p><p>对于 <code>===</code>，主要特点就是严格相等，类型不同就是 <code>false</code>，与 <code>==</code> 类型相同时比较规则一致。</p><p>对于 <code>Object.is()</code>，主要特点就是严格相等，类型不同就是 <code>false</code>，与 <code>==</code> 类型相同时比较规则一致。但与 <code>===</code> 不同的是，<code>Object.is()</code> 对于 0 和 -0、NaN 的处理不同，<code>Object.is()</code> 将数值 -0 和 +0 视为彼此不相等，但是会将 NaN 视为彼此相等，<code>===</code> 将数值 -0 和 +0 视为相等，但是会将 NaN 视为彼此不相等。</p></div><h2 id="全局-isNaN-和-Number-isNaN">全局 <code>isNaN()</code> 和  <code>Number.isNaN()</code></h2><details><summary>查看</summary><ul class="lvl-0"><li class="lvl-2"><p><code>isNaN()</code> 函数用来确定一个值是否为 NaN，若有必要，则首先将值转换为数字。</p></li><li class="lvl-2"><p><code>Number.isNaN()</code> 静态方法判断传入的值是否为 NaN，如果输入不是数字类型，则返回 false。它是全局 <code>isNaN()</code> 函数更健壮的版本。</p></li></ul><p><code>isNaN()</code> 是全局对象的一个函数属性。对于数字值，<code>isNaN()</code> 检测该值是否为 NaN 值。当 <code>isNaN()</code> 函数的参数不是数字类型时，其会首先被转换为数字，然后将其结果值与 NaN 进行比较</p><p><code>isNaN()</code> 对于非数字参数的行为可能会令人困惑！例如，空字符串被强制转换为 0，布尔值被强制转换为 0 或 1；直观上，两者均“不是数字”，仅因它们的运算结果不是 NaN，而使得 <code>isNaN()</code> 返回 false。因此，<code>isNaN()</code> 既不回答“输入是否为浮点数值 NaN”，也不回答“输入是否为数字”这两个问题。</p><p>Number.isNaN() 是检测一个值是否为数字值 NaN 的更可靠的方法。或者，也可以使用表达式 x !== x，这两种方法都不会产生全局 isNaN() 不可靠的误判。要检测一个值是否为数字，请使用 typeof x === “number”。</p><h3 id="Number-isNaN-和全局-isNaN-之间的区别">Number.isNaN() 和全局 isNaN() 之间的区别</h3><p>Number.isNaN() 不会尝试将参数转换为数字，因此非数字总是返回 false。以下都返回 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>); </span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;blabla&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;37&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;37.37&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><p>全局 isNaN() 函数会将参数强制转换为数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;blabla&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>); <span class="comment">// false，强制转换为 1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>); <span class="comment">// false，强制转换为 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37&quot;</span>); <span class="comment">// false，强制转换为 37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37.37&quot;</span>); <span class="comment">// false，强制转换为 37.37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false，强制转换为 0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// false，强制转换为 0</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面经 </category>
          
          <category> 类型判断 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-学习笔记</title>
      <link href="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="双线程模型">双线程模型</h2><p>微信小程序基于 WebView 环境下使用双线程模型架构, 其实本质就相当于开了一个浏览器, 基于Webkit的JSCore渲染一个页面进行展示, 其包含 JS 逻辑和视图渲染(DOM树的创建, CSS解析, 样式计算, Layout, Paint)都会发生在同一线程, 但其执行过多的JS逻辑会阻塞渲染, 导致页面卡顿。</p><p>基于此, 小程序为了考虑性能和安全, 采用了<code>[双线程]</code>的架构。</p><p>开启两个 WebView  线程, 一个执行渲染, 一个调用 JSCore 处理js逻辑, 再通过原生(微信客户端)的桥接(bridge)计算实现两个 WebView 线程之间的通信, 以达到页面渲染更新的效果。</p><p>微信小程序后推出了<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html">Skyline</a>渲染引擎, 其类似于Flutter渲染, 更加接近原生的体验。</p><h2 id="为什么会出现-WXS">为什么会出现 WXS</h2><p>由于双线程模型, 主要关于视图渲染的线程是不能直接调用JS逻辑的, 可能是由于两个线程之间频繁通信对原生应用的开销太大, 微信小程序底层并没有设置这种直接通信的方式, 但为了能够实现开发者的需求, 于是推出了 WSX 语法, 也就是在负责渲染视图的线程中也可以调用 JSCore, 进而实现页面与JS逻辑的通信。</p><p>但尽量避免在 WSX 中编写复杂的逻辑, 因为其所在的线程还要进行视图渲染, 避免阻塞。</p><h3 id="WXS-的使用方式一">WXS 的使用方式一</h3><p>通过 <code>wxs</code> 标签的形式, wsx 标签中包裹 js 代码, 只能是 <mark>ES5</mark> 的语法, 并且需要进行导出, 导出使用<mark>CommonJs</mark>的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs <span class="variable language_">module</span>=<span class="string">&quot;format&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">formatPrice</span>(<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span> + price</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">formatPrice</span>: formatPrice &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br></pre></td></tr></table></figure><p>要在 <code>wxs</code> 标签中明确编写module属性, 为每一个<code>wxs</code>设置一个独特的标识, 通过该表示使用其中定义的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> &#123;&#123;<span class="attr">format.formatPrice</span>(&#x27;<span class="attr">12414</span>&#x27;)&#125;&#125;&lt;/<span class="attr">text</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="WXS-的使用方式二">WXS 的使用方式二</h3><p>定义以<code>.wxs</code>为后缀名的文件, 如<code>format.wxs</code></p><p>在其中编写JS代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatPrice</span>(<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;￥&quot;</span> + price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">formatPrice</span>: formatPrice &#125;;</span><br></pre></td></tr></table></figure><p>在<code>wxml</code>中通过<code>wxs</code>标签引入该文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;format&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/utils/format.wxs&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件的样式细节">组件的样式细节</h2><h3 id="组件内的样式对外部样式的影响">组件内的样式对外部样式的影响</h3><ul class="lvl-0"><li class="lvl-2"><p>组件内的class样式, 只对组件wxml内的节点生效, 对于引入组件的Page页面不生效</p></li><li class="lvl-2"><p>组件内不能使用id选择器、属性选择器、标签选择器(会对外部样式造成影响)</p></li></ul><h3 id="外部样式对组件内样式的影响">外部样式对组件内样式的影响</h3><ul class="lvl-0"><li class="lvl-2"><p>外部使用class样式, 只对外部wxml的class生效, 对组件内是不生效的</p></li><li class="lvl-2"><p>外部使用了id选择器、属性选择器不会对组件内样式产生影响</p></li><li class="lvl-2"><p>外部使用了标签选择器, 会对组件内产生影响</p></li></ul><h3 id="如何让class可以相互影响">如何让class可以相互影响</h3><ul class="lvl-0"><li class="lvl-2"><p>在Component对象中, 可以传入一个options属性, 其中options属性中有一个styleIsolation(隔离)属性</p></li><li class="lvl-2"><p>styleIsolation三个取值</p><ul class="lvl-2"><li class="lvl-4">isolated: 默认值, 表示启用样式隔离, 在自定义组件内外, 使用class指定的样式将不会互相影响</li><li class="lvl-4">apply-shared: 表示页面wxss样式将影响到自定义组件, 但自定义组件wxss中指定的样式不会影响页面</li><li class="lvl-4">shared: 表示页面wxss样式将影响到自定义组件, 自定义组件wxss中指定的样式也会影响页面和其他设置了</li></ul></li></ul><h2 id="mark-传递参数的细节">mark 传递参数的细节</h2><p>mark语法: <code>mark:[自定义名称]=&quot;xxx&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">mark:dd</span>=<span class="string">&quot;111&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">mark:name</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">mark:name1</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过mark传递参数, 会从被点击组件向上合并所有定义了mark属性的祖先组件, 得到一个合并后的mask对象, 即使事件通过catch拦截冒泡传递了。</p><h2 id="自定义组件">自定义组件</h2><h3 id="组件生命周期"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html#%E5%AE%9A%E4%B9%89%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95">组件生命周期</a></h3><p>在<code>Component(&#123;&#125;)</code>中的<code>lifetimes</code>中写入对应组件生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件被创建created&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">attached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件被添加到组件树中attached&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">detached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件从组件树中移除detached&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>created</code>: 组件实例被创建, 但节点树还未插入文档树</p></li><li class="lvl-2"><p><code>attached</code>: 组件实例被插入文档树后触发</p></li><li class="lvl-2"><p><code>ready</code>: 组件实例被创建, 并且节点树已经插入文档树后触发</p></li><li class="lvl-2"><p><code>moved</code>: 组件实例被移动到文档树 another-component 之前触发</p></li><li class="lvl-2"><p><code>detached</code>: 组件实例被从文档树移除后触发</p></li><li class="lvl-2"><p><code>error</code>: 组件实例发生错误时触发</p></li></ul><h3 id="组件所在页面的生命周期"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html#%E7%BB%84%E4%BB%B6%E6%89%80%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">组件所在页面的生命周期</a></h3><p>在<code>Component(&#123;&#125;)</code>中的<code>pageLifetimes</code>中写入对应生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">pageLifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;页面显示show&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;页面隐藏hide&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>load</code>: 页面加载时触发</p></li><li class="lvl-2"><p><code>show</code>: 页面显示时触发</p></li><li class="lvl-2"><p><code>hide</code>: 页面隐藏时触发</p></li><li class="lvl-2"><p>…</p></li></ul><h3 id="插槽">插槽</h3><p>微信小程序的自定义组件插槽与 Vue 的写法一致, 但微信小程序不支持默认插槽, 我们为了满足该业务需求, 我们可以通过伪类选择器<code>:empty</code>实现</p><p>wxml代码结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;default&quot;</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>wcss样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.default</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">:empty</span> + <span class="selector-class">.default</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个插槽">多个插槽</h3><p>微信小程序要想使用多个插槽, 需要在 Components 函数对象参数中的 options 配置 <code>multipleSlots: true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">multipleSlots</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="微信小程序弹窗API">微信小程序弹窗API</h2><h3 id="wx-showToast">wx.showToast</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html">官方文档</a></p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;购买成功！&quot;</span>,</span><br><span class="line">  <span class="attr">icon</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">mask</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="wx-showMoadl">wx.showMoadl</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html">官方文档</a></p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;确定购买吗&quot;</span>,</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&quot;1241414&quot;</span>,</span><br><span class="line">  <span class="attr">confirmColor</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="attr">cancelColor</span>: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">cancel</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">confirm</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;confirm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="wx-showActionSheet">wx.showActionSheet</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showActionSheet.html">官方文档</a></p><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showActionSheet</span>(&#123;</span><br><span class="line">  <span class="attr">alertText</span>: <span class="string">&quot;提示&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">itemList</span>: [<span class="string">&quot;选项1&quot;</span>, <span class="string">&quot;选项2&quot;</span>, <span class="string">&quot;选项3&quot;</span>],</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">tapIndex</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fail</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="微信小程序获取地址API">微信小程序获取地址API</h2><p>API: <code>wx.getLocation</code></p><p>使用该API的前提需要在<code>app.json</code>中进行配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;requiredPrivateInfos&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;getLocation&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;permission&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scope.userLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取位置信息&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="微信小程序获取界面上的节点信息">微信小程序获取界面上的节点信息</h2><p>场景: <code>swiper</code> 轮播图组件有默认的高度, 假如其中放置图片, 但图片的高度不适配, 改动图片的 mode 属性为 <code>aspectFill</code> 会裁剪图片, 显得不美观, 为了解决此, 尝试获取图片高度, 改变 <code>swiiper</code> 的高度, 以是图片完美展示</p><h3 id="步骤一">步骤一</h3><p>创建 <code>SelectorQuery</code>, SelectorQuery 为查询节点信息的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = wx.<span class="title function_">createSelectorQuery</span>();</span><br></pre></td></tr></table></figure><h3 id="步骤二">步骤二</h3><p>获取图片组件的信息, 用<code>NodesRef SelectorQuery.select(string selector)</code>,<br>并通过 <code>SelectorQuery NodesRef.boundingClientRect(function callback)</code> 添加节点的布局位置的查询请求。</p><p><code>NodesRef SelectorQuery.select(string selector)</code>: 在当前页面下选择第一个匹配选择器 selector 的节点。返回一个 NodesRef 对象实例，可以用于获取节点信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="title function_">select</span>(<span class="string">&quot;.banner-image&quot;</span>).<span class="title function_">boundingClientRect</span>();</span><br></pre></td></tr></table></figure><h3 id="步骤三">步骤三</h3><p><code>NodesRef SelectorQuery.exec(function callback)</code>: 执行所有的请求。请求结果按请求次序构成数组, 在callback的第一个参数中返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">height</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对该操作进行封装">对该操作进行封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">querySelect</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> query = wx.<span class="title function_">createSelectorQuery</span>();</span><br><span class="line">    query.<span class="title function_">select</span>(<span class="string">&quot;.banner-image&quot;</span>).<span class="title function_">boundingClientRect</span>();</span><br><span class="line">    query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微信小程序音源播放操作">微信小程序音源播放操作</h2><h3 id="创建-InnerAudioContext-实例">创建 <code>InnerAudioContext</code> 实例</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioContext = wx.<span class="title function_">createInnerAudioContext</span>();</span><br></pre></td></tr></table></figure><h3 id="设置-InnerAudioContext-实例的-src-和-autoplay-属性">设置 <code>InnerAudioContext</code> 实例的 src 和 autoplay 属性</h3><ul class="lvl-0"><li class="lvl-2"><p>src: 音频资源地址</p></li><li class="lvl-2"><p>autoplay: 是否自动播放</p></li></ul><p>进行以上设置后, 在页面或相应的生命周期中加载完后即可自动播放</p><p>但仅仅是用于可播放, 对于其更精细的操作可以查阅对应的<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/InnerAudioContext.html">官方文档</a></p><h2 id="图片懒加载没生效问题">图片懒加载没生效问题</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/assets/xxx.png&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;&quot;</span> <span class="attr">show-menu-by-longpress</span> <span class="attr">lazy-load</span> /&gt;</span></span><br></pre></td></tr></table></figure><img data-src="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" class="" title="图片懒加载没生效问题"><p>lazy-load的图片不是出现在屏幕上才会开始加载，而是提前3个屏幕高度就会加载。所以说三个屏幕高度以内的图片是不会懒加载的，上下三屏即为三个屏幕高度。</p><h2 id="text-组件">text 组件</h2><img data-src="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" class="" title="text 组件"><h2 id="navigator组件中的-open-type">navigator组件中的 open-type</h2><img data-src="/2024/10/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" class="" title="navigator中的 open-type"><p>注意：</p><blockquote><p>在进行页面跳转时，需要在路径的前面添加 / 斜线，否则跳转不成功<navigator url="/pages/list/list?id=10&num=hue" open-type="navigate">到商品列表页面</navigator></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>navigate：只能跳转到非 TabBar 页面，不能跳转到 TabBar 页面，保留上一级页面</p></li><li class="lvl-2"><p>redirect：只能跳转到非 TabBar 页面，不能跳转到 TabBar 页面，关闭上一级页面</p></li><li class="lvl-2"><p>switchTab：只能跳转到 TabBar 页面，不能跳转到非 TabBar 页面，关闭其他所有的非 TabBar 页面</p></li><li class="lvl-2"><p>reLaunch：关闭所有页面，然后打开小程序中某一个页面</p></li><li class="lvl-2"><p>navigateBack返回上一页或者返回前几页，默认只能返回上一页</p><ul class="lvl-2"><li class="lvl-4">delte：返回的层级，默认是 1，如果想返回几级，就写几</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SASS星空</title>
      <link href="/2024/10/15/SASS%E6%98%9F%E7%A9%BA/"/>
      <url>/2024/10/15/SASS%E6%98%9F%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>效果图</strong></p><img data-src="/2024/10/15/SASS%E6%98%9F%E7%A9%BA/preview.gif" class="" title="SASS星空"><p>盒子的阴影可以设置多个，所以我们可以通过阴影实现星光的效果，但纯写 css 过于抽象，我们可以利用 sass 的循环语法、函数与变量编写<br><strong>HTML结构</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里只设置三个层级,可以根据需要自己添加 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Sass 星空<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SASS代码</strong><br>提示：</p><ul class="lvl-0"><li class="lvl-2"><p>对SASS的编译不要用 VScode 的插件：easy sass，可能会出现函数识别导致编译失败的问题</p></li><li class="lvl-2"><p>可以在 node 环境下，安装 sass：<code>npm i sass</code></p></li><li class="lvl-2"><p>后执行 <code>npx sass [sass文件路径] [编译转换后的css输出文件路径] --no-source-map -w</code></p></li></ul><blockquote><p>npx sass index.scss index.css --no-source-map -w</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>npx：暂时把 sass 加入环境变量中，仅在此命令行操作有效</p></li><li class="lvl-2"><p>sass：安装 sass 自带的执行命令</p></li><li class="lvl-2"><p>–no-source-map：取消源映射，source-map里面存放着sass与css的映射信息，通过此命令可以取消该文件的生成</p></li><li class="lvl-2"><p>-w：监听sass/scss的文件内容变化，自动更新生成的css</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 背景底色</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    radial-gradient 是 CSS3 中用于创建径向渐变背景的属性。</span></span><br><span class="line"><span class="comment">    ellipse at bottom 指定了渐变形状为椭圆，并且椭圆的底部与元素的底部对齐。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(ellipse at bottom, <span class="number">#1b2735</span> <span class="number">0%</span>, <span class="number">#090a0f</span> <span class="number">100%</span>);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;lato&quot;</span>, sans-serif;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">  // 渐变背景，将文本背景设置为透明，并设置背景颜色为 <span class="selector-id">#38495a</span></span><br><span class="line">  // 即将文字展示为背景颜色</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(white, <span class="number">#38495a</span>);</span><br><span class="line">  -webkit-<span class="attribute">background-clip</span>: text;</span><br><span class="line">  <span class="attribute">background-clip</span>: text;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建星光（阴影）函数</span><br><span class="line"><span class="keyword">@function</span> createShadow($n) &#123;</span><br><span class="line">  // 定义阴影变量  </span><br><span class="line">  $shadow: <span class="string">&quot;#&#123;random($limit: 100)&#125;vw #&#123;random($limit: 100)&#125;vh #fff&quot;</span>;</span><br><span class="line">  <span class="keyword">@for</span> $i from <span class="number">2</span> through $n &#123;</span><br><span class="line">    // 每次循环向 $shadow 中添加新的阴影</span><br><span class="line">    $shadow: <span class="string">&quot;#&#123;$shadow&#125;, #&#123;random($limit: 100)&#125;vw #&#123;random($limit: 100)&#125;vh #fff&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  // unquote() 函数用于将字符串转换为 CSS 属性值，即去掉字符串</span><br><span class="line">  <span class="keyword">@return</span> unquote($shadow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义星光（阴影）初始数量</span><br><span class="line">$count: <span class="number">1000</span>;</span><br><span class="line">// 定义动画初始时间</span><br><span class="line">$duration: <span class="number">400s</span>;</span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through <span class="number">3</span> &#123;</span><br><span class="line">  // 每次循环时将数量和动画时间减半，以达到不同层级的动画效果</span><br><span class="line">  $count: <span class="built_in">floor</span>(<span class="built_in">calc</span>($count / <span class="number">2</span>));</span><br><span class="line">  $duration: <span class="built_in">floor</span>(<span class="built_in">calc</span>($duration / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  // 输出调试信息</span><br><span class="line">  <span class="keyword">@debug</span> <span class="string">&quot;count #&#123;$count&#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">@debug</span> <span class="string">&quot;duration #&#123;$duration&#125;&quot;</span>;</span><br><span class="line">  // 创建层级的样式</span><br><span class="line">  <span class="selector-class">.layer</span>#&#123;$<span class="selector-tag">i</span>&#125; &#123;</span><br><span class="line">    $size: #&#123;$<span class="selector-tag">i</span>&#125;px;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: $size;</span><br><span class="line">    <span class="attribute">height</span>: $size;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f40</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="built_in">createShadow</span>($count);</span><br><span class="line">    <span class="attribute">animation</span>: moveUp $duration linear infinite;</span><br><span class="line">    // 为了动画的流畅和无缝衔接，在 &amp;<span class="selector-pseudo">::after</span> 中设置相同的参数</span><br><span class="line">    &amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">position</span>: fixed;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">100vh</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: inherit;</span><br><span class="line">      <span class="attribute">height</span>: inherit;</span><br><span class="line">      <span class="attribute">box-shadow</span>: inherit;</span><br><span class="line">      <span class="attribute">background</span>: inherit;</span><br><span class="line">      <span class="attribute">border-radius</span>: inherit;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动动画</span><br><span class="line"><span class="keyword">@keyframes</span> moveUp &#123;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100vh</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 页面 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SASS </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN优化</title>
      <link href="/2024/10/13/RN%E4%BC%98%E5%8C%96/"/>
      <url>/2024/10/13/RN%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="移除不必要权限">移除不必要权限</h2><p>例如，在<code>\[项目名]\android\app\src\main\</code>下<code>AndroidManifest.xml</code>中写入如下代码</p><span id="more"></span><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 移除读取电话状态的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移除写入外部存储的权限。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移除读取外部存储的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><!-- more --><p>我们还需要在<code>AndroidManifest.xml</code>中声明了一个名为tools的XML命名空间<code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>移除不必要权限的好处（文心一言生成）</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>提升用户隐私保护</strong>：减少不必要的权限请求可以增强用户信任，因为用户越来越关注个人数据的安全与隐私。特别是读取电话状态、读写外部存储这样的敏感权限，移除后表明应用不会侵犯用户的通信记录或存储的数据。</p></li><li class="lvl-2"><p><strong>简化权限管理</strong>：对于用户而言，应用程序请求的权限越少，他们在安装和使用过程中遇到的权限提示就越少，从而提升用户体验。用户不再需要为不相关的功能授予权限。</p></li><li class="lvl-2"><p><strong>降低潜在的安全风险</strong>：每个权限都可能成为安全漏洞的入口。移除不必要的权限可以减少应用受到攻击的面，提高应用的整体安全性。</p></li><li class="lvl-2"><p><strong>合规性增强</strong>：遵循更严格的隐私法规要求，比如GDPR（欧盟通用数据保护条例）或中国的《个人信息保护法》，这些法律强调最小必要原则，即只收集和处理完成业务所必需的最少个人信息。移除多余权限有助于企业符合此类法规要求。</p></li><li class="lvl-2"><p><strong>优化应用审核过程</strong>：在Google Play Store或其他应用市场上架时，应用的权限使用是审核的一部分。减少非必要的权限可以简化审核流程，加快应用上架速度。</p></li><li class="lvl-2"><p><strong>可能提升性能</strong>：虽然直接关联不大，但理论上减少对存储或硬件资源的访问需求，可能轻微提升应用运行效率，尤其是对于资源紧张的设备。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> APP </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN问题解决</title>
      <link href="/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>2024.6.14时最新版本为 0.74.2，2024.8.1时最新版本为0.74.4，但其相关依赖不太稳定，尝试使用 0.74.2 版本操作</p><span id="more"></span><h2 id="创建项目时报错：RN-error-Error">创建项目时报错：<strong>RN error Error</strong></h2><p><strong><font style="color:#DF2A3F;">RN error Error: getaddrinfo ENOENT <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:108:26)</font></strong></p><blockquote><p><strong><font style="color:#C75C00;">raw.githubusercontent.com</font></strong> 是 GitHub 提供的一个服务，用于直接访问存储在 GitHub 仓库中的原始文件（如文本文件、脚本等），而无需下载整个仓库。在 React Native (RN) 开发环境中，这个 URL 常见于以下几种场景（文心一言生成，可了解）：</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>依赖管理工具安装</strong>: 如 Homebrew 安装脚本 <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>，Homebrew 是一个 macOS 下的包管理器，广泛用于安装 RN 开发所需的工具链和依赖，比如 Node.js、watchman、Yarn 或者其他 CLI 工具。</p></li><li class="lvl-2"><p><strong>脚本或配置文件获取</strong>: 在某些情况下，开发者可能会从 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> 直接拉取脚本或配置文件到本地，作为项目初始化的一部分或者是运行某些自动化任务的需要。</p></li><li class="lvl-2"><p><strong>快速分享和集成代码片段</strong>: 开发者可能会分享一些示例代码或者配置文件的链接，其他用户可以直接通过这些链接查看或下载内容，便于快速集成或参考。</p></li><li class="lvl-2"><p><strong>持续集成/部署脚本</strong>: 在 CI/CD 流程中，可能会使用此类链接来动态获取最新的脚本或配置，确保构建过程使用的是最新或指定版本的资源。</p></li></ul><p>其最显著的是我们在启动项目时，会自动将模拟器启动</p><p>问题分析</p><ul class="lvl-0"><li class="lvl-2"><p><font style="color:rgb(38, 38, 38);">为无法访问该域名的问题</font></p></li></ul><p>解决方案</p><ul class="lvl-0"><li class="lvl-2"><p>检查网络设置</p></li><li class="lvl-2"><p>使用代理服务</p></li><li class="lvl-2"><p>更换 DNS 服务器等方法来解决访问限制</p></li></ul><p>DNS 服务可能是 <strong>域名</strong> 与 <strong>ip</strong> 未绑定的原因</p><p>我们需要查看 <font style="color:#C75C00;background-color:rgb(249, 242, 244);">C:\Windows\System32\drivers\etc</font><code>里查看是否有</code><font style="color:rgb(199, 92, 0);">raw.githubusercontent.com</font> 与其对应的 <strong>ip</strong> 绑定，没有的话我们需要去查看 <font style="color:rgb(199, 92, 0);">raw.githubusercontent.com</font> 所对应的 <strong>ip</strong></p><ul class="lvl-0"><li class="lvl-2"><p>进入该网址 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a>，输入域名搜索<img data-src="/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/image.png" class="" title="RN问题解决"></p></li><li class="lvl-2"><p>下图所框便是其对应的 <strong>ip</strong><img data-src="/2024/10/13/RN%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/image-1.png" class="" title="RN问题解决"></p></li><li class="lvl-2"><p>在<font style="color:#C75C00;">C:\Windows\System32\drivers\etc</font> 里的 <font style="color:#C75C00;">hosts</font> 里最下面写入对应的配置，保存后重新创建项目</p></li></ul><blockquote><p>185.199.108.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p><p>185.199.109.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p><p>185.199.110.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p><p>185.199.111.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></p></blockquote><h2 id="下载-gradle-x-x-all-zip-太慢">下载 <strong>gradle-x.x-all.zip 太慢</strong></h2><blockquote><p>Downloading <a href="https://services.gradle.org/distributions/gradle-8.6-all.zip">https://services.gradle.org/distributions/gradle-8.6-all.zip</a></p></blockquote><p><strong><font style="color:#000000;">解决方案</font></strong></p><ul class="lvl-0"><li class="lvl-2"><p>配置镜像</p></li><li class="lvl-2"><p>在 <font style="color:#C75C00;">[项目名]\android\gradle\wrapper\gradle-wrapper.properties</font> 中进行如下操作</p></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line"># 原网站下载</span><br><span class="line"># distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-8.6-all.zip</span></span><br><span class="line"># 配置阿里镜像下载</span><br><span class="line">distributionUrl=https\:<span class="comment">//mirrors.aliyun.com/macports/distfiles/gradle/gradle-8.6-all.zip</span></span><br><span class="line"></span><br><span class="line">networkTimeout=<span class="number">10000</span></span><br><span class="line">validateDistributionUrl=<span class="keyword">true</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure><p>配置好之后仍满可以试试多次重新执行启动项目命令，当进度明显快了就可以了，第一次可能有点慢，因为要安装 <font style="color:#C75C00;">gradle-8.6-all.zip</font></p><h2 id="依赖库下载太慢">依赖库下载太慢</h2><p>解决方案</p><ul class="lvl-0"><li class="lvl-2"><p><font style="color:#C75C00;">[项目名]\android\build.gradle</font> 中 <font style="color:#C75C00;background-color:rgb(250, 250, 250);">repositories</font> <font style="color:rgb(38, 38, 38);background-color:rgb(250, 250, 250);">内有</font> <font style="color:#C75C00;background-color:rgb(250, 250, 250);">google()</font> <font style="color:rgb(38, 38, 38);background-color:rgb(250, 250, 250);">和</font> <font style="color:#C75C00;background-color:rgb(250, 250, 250);">mavenCentral()</font></p></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>google()</strong>: 这一行指定了Google的Maven仓库作为依赖项的来源。这对于下载Android SDK相关依赖、Jetpack库以及其他Google提供的库非常关键。</p></li><li class="lvl-2"><p><strong>mavenCentral()</strong>: 这一行指定了Maven中央仓库，它是Java开发中最常用的依赖库仓库，包含了大量开源库和框架。</p></li><li class="lvl-2"><p>但由于这两个仓库的服务器都在国外，我们也需要对其进行镜像处理，有两种解决方案：</p><ul class="lvl-2"><li class="lvl-4"><strong>局部配置</strong>：直接在 <font style="color:#DF2A3F;">build.gradle</font> 的 <font style="color:#DF2A3F;background-color:rgb(250, 250, 250);">repositories</font> <font style="color:rgb(38, 38, 38);background-color:rgb(250, 250, 250);">中修改</font></li><li class="lvl-4"><strong>全局配置</strong>： 在 <font style="color:#DF2A3F;">C:\Users[用户名].gradle</font> 文件夹下创建 <font style="color:#DF2A3F;">init.gradle</font> 文件，里面进行如下配置，这样我们就不需要每个项目都进行配置了</li></ul></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部配置</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/google&#x27;</span> &#125;</span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/jcenter&#x27;</span> &#125;</span><br><span class="line">    <span class="comment">// 此为阿里镜像下载源</span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://mirrors.aliyun.com/macports/distfiles/gradle/&#x27;</span> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局配置</span></span><br><span class="line"><span class="keyword">allprojects</span>&#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/central/&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> ALIYUN_JCENTER_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://repo1.maven.org/maven2&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://repo1.maven.org/maven2&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://jcenter.bintray.com/&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://jcenter.bintray.com/&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url ALIYUN_REPOSITORY_URL</span><br><span class="line">            url ALIYUN_JCENTER_URL</span><br><span class="line">            url <span class="string">&#x27;https://maven.aliyun.com/repository/google/&#x27;</span></span><br><span class="line">            url <span class="string">&#x27;https://maven.aliyun.com/repository/gradle-plugin/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">buildscript</span>&#123;</span><br><span class="line">        <span class="keyword">repositories</span> &#123;</span><br><span class="line">            <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/central/&#x27;</span></span><br><span class="line">            <span class="keyword">def</span> ALIYUN_JCENTER_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">            all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">                <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                    <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://repo1.maven.org/maven2&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://repo1.maven.org/maven2&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                        remove repo</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://jcenter.bintray.com/&#x27;</span>) || url.startsWith(<span class="string">&#x27;http://jcenter.bintray.com/&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span></span><br><span class="line">                        remove repo</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url ALIYUN_REPOSITORY_URL</span><br><span class="line">                url ALIYUN_JCENTER_URL</span><br><span class="line">                url <span class="string">&#x27;https://maven.aliyun.com/repository/google/&#x27;</span></span><br><span class="line">                url <span class="string">&#x27;https://maven.aliyun.com/repository/gradle-plugin/&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="调试断开后设备上打开报错">调试断开后设备上打开报错</h2><p>当我们启动程序并连上设备后，我们可以看到页面资源，但当我们断开后再打开就会报错 <font style="color:#DF2A3F;"><strong>Unable to load script…</strong></font>，是因为我们的 <strong>JS代码和静态资源</strong> 并没有集成到Android项目中进行构建和发布</p><p>解决方案</p><ul class="lvl-0"><li class="lvl-2"><p>在 <font style="color:#DF2A3F;">[项目名]\android\app\src\main\</font> 目录下创建 <font style="color:#DF2A3F;">assets</font> 文件夹，并在下面创建 <font style="color:#DF2A3F;">index.android.bundle</font> 文件</p></li><li class="lvl-2"><p>然后在控制台<strong>项目根目录</strong>运行命令 <font style="color:#DF2A3F;">npx react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res</font></p></li><li class="lvl-2"><p>当我们再次运行时，即使断开我们也可以看到我们的资源</p></li></ul><h2 id="error-Error-connect-ETIMEDOUT-185-199-108-133-443">error Error: connect ETIMEDOUT 185.199.108.133:443</h2><p>过段时间重新尝试安装</p><h2 id="error-unknown-command-‘run-android’">error: unknown command ‘run-android’</h2><p>依赖包删除重新 <code>npm i</code> 或 <code>yarn</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> APP </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建RN项目</title>
      <link href="/2024/10/13/%E5%88%9B%E5%BB%BARN%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/10/13/%E5%88%9B%E5%BB%BARN%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Android-开发环境">Android 开发环境</h2><ul class="lvl-0"><li class="lvl-2">配置 Android 环境，请跟着<a href="https://reactnative.cn/docs/0.74/getting-started">文档</a>(0.74版本)进行</li></ul><span id="more"></span><h2 id="创建新项目">创建新项目</h2><ul class="lvl-0"><li class="lvl-2"><p>如果你之前全局安装过旧的react-native-cli命令行工具，请使用<code>npm uninstall -g react-native-cli</code>卸载掉它以避免一些冲突：<code>npm uninstall -g react-native-cli @react-native-community/cli</code></p></li><li class="lvl-2"><p>输入以下命令创建新项目<code>npx react-native@latest init [项目名]</code></p></li></ul><h2 id="创建项目指定版本号：-可选参数-指定版本或项目模板">创建项目指定版本号：[可选参数] 指定版本或项目模板</h2><ul class="lvl-0"><li class="lvl-2"><p>你可以使用–version参数（注意是两个杠）创建指定版本的项目。注意版本号必须精确到两个小数点：<code>npx react-native@X.XX.X init AwesomeProject --version X.XX.X</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> APP </category>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite 环境变量配置文件</title>
      <link href="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前提文档链接</p><p>Vite 环境变量和模式文档：<a href="https://vitejs.cn/vite3-cn/guide/env-and-mode.html#env-files">https://vitejs.cn/vite3-cn/guide/env-and-mode.html#env-files</a></p><hr><span id="more"></span><h2 id="开发环境与配置文件">开发环境与配置文件</h2><p>在项目开发中，我们往往需要在不同环境下使用不同的配置，比如开发环境、测试环境、生产环境等。</p><p>在项目开发中，常见的环境有</p><ul class="lvl-0"><li class="lvl-2"><p><code>dev</code> – 开发环境，外部用户无法访问，开发人员使用，版本变动大。</p></li><li class="lvl-2"><p><code>prod</code> – 生产环境，面向外部用户的环境，正式环境。</p></li><li class="lvl-2"><p><code>test</code> – 测试环境，外部用户无法访问，专门给测试人员使用的，版本相对稳定。</p></li><li class="lvl-2"><p><code>sit (System Integration Test)</code> – 集成环境，系统集成测试，开发人员自己测试流程是否走通。</p></li><li class="lvl-2"><p><code>uat (User Acceptance Test environment)</code> – 用户验收测试环境，主要面向要交付的人员进行验证测试。</p></li><li class="lvl-2"><p><code>pre</code> – 灰度环境，外部用户可以访问，但是服务器配置相对低，其它和生产一样。</p></li><li class="lvl-2"><p><code>fat (Feature Acceptance Test environment)</code> – 功能验收测试环境，用于软件测试者测试使用。在以 <a href="https://vitejs.cn/">Vite</a> 作为构建工具开发项目时，环境变量配置文件名为 <code>.env</code>，文件名后缀为 <code>.env.[mode]</code>，其中 <code>mode</code> 为环境名称，如 <code>dev</code>、<code>prod</code>、<code>test</code> 等。</p></li></ul><p>根据 <code>mode</code> 的不同，可以配置不同的环境变量，例如</p><blockquote><p>.env.development<br>.env.production<br>.env.test</p></blockquote><p>默认情况下，Vite 会自动读取 <code>.env</code> 文件（通用配置），并根据 <code>NODE_ENV</code> 的值来确定当前环境。</p><p>但对于一份指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）。且相同的配置项，指定模式的文件会覆盖通用配置。</p><p>虽说环境有多种，但真正的开发模式只有两种</p><ul class="lvl-0"><li class="lvl-2"><p><code>development</code>：开发模式下</p></li><li class="lvl-2"><p><code>production</code>：生产模式下</p></li></ul><p>我们可以在不同的开发模式下配置多种环境，基于这种情况下，又习惯性的把 <code>开发环境</code> 和 <code>生产环境</code> 作为主环境，而在主环境下配置各种子环境，显示的把开发模式指定出来，便于开发人员理解，基于此，有些项目的环境目录会出现以下情况</p><blockquote><p>.env.development<br>.env.development.sit<br>.env.production<br>.env.production.uat</p></blockquote><h2 id="环境变量">环境变量</h2><p>在 Vite 中，环境变量的命名规则默认为 <code>VITE_</code> 开头，例如 <code>VITE_API_URL</code>。</p><p>官方解释</p><blockquote><p>为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码。例如下面这些环境变量：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; VITE_SOME_KEY=123</span><br><span class="line">&gt; DB_PASSWORD=foobar</span><br></pre></td></tr></table></figure><blockquote><p>只有 VITE_SOME_KEY 会被暴露为 import.meta.env.VITE_SOME_KEY 提供给客户端源码，而 DB_PASSWORD 则不会。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; console.log(import.meta.env.VITE_SOME_KEY) // 123</span><br><span class="line">&gt; console.log(import.meta.env.DB_PASSWORD) // undefined</span><br></pre></td></tr></table></figure><p>如果修改默认前缀，请参阅 <a href="https://vitejs.cn/vite3-cn/config/shared-options.html#envprefix">envprefix</a>。</p><h3 id="环境变量的使用">环境变量的使用</h3><p>在项目中，有些公共部分是需要我们抽离出来，作为环境变量进行配置，例如：<code>API_BASE_URL</code>，<code>ROUTE_BASE_URL</code>等等。</p><p>我们可以在 <code>.env.[mode]</code> 配置文件中填写</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VITE_APP_API_URL=http://x.x.x.x:xx</span><br><span class="line">VITE_ROUTE_BASE_URL=/xxx</span><br></pre></td></tr></table></figure><p>在项目中，我们可以通过 <code>import.meta.env.[变量名]</code> 来获取这些环境变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_APP_API_URL</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_ROUTE_BASE_URL</span>)</span><br></pre></td></tr></table></figure><h3 id="指定开发环境">指定开发环境</h3><p>我们可以通过获取这些环境变量以达到不同环境下使用不同变量的功能，但我们如何确定当前环境或者当前模式呢？</p><h4 id="指定开发环境的模式">指定开发环境的模式</h4><p>开发环境的模式需要在配置文件中配置 <code>NODE_ENV</code> 变量，Vite 会自动读取该变量，并根据该变量的值来确定当前开发模式，默认为 <code>development</code>。</p><p><code>NODE_ENV</code> 有两个值：</p><ul class="lvl-0"><li class="lvl-2"><p><code>development</code>：开发模式</p></li><li class="lvl-2"><p><code>production</code>：生产模式</p></li></ul><p>在有些时候，我们不需要进行显示的配置，Vite 内部会自动根据当前环境来确定开发模式。例如：</p><blockquote><p>默认情况下，开发服务器 (dev 命令) 运行在 development (开发) 模式，而 build 命令（打包命令）则运行在 production (生产) 模式。</p><p>这意味着当执行 vite build 时，它会自动加载 .env.production 中可能存在的环境变量。 ————<a href="https://vitejs.cn/vite3-cn/guide/env-and-mode.html#env-files">官方解释</a></p></blockquote><h4 id="指定环境类型">指定环境类型</h4><p>在上文我们提到了 <code>.env.[mode]</code> ，我们只需要改写 <code>mode</code> 值便可实现环境的创建，在真实情况下，<code>mode</code> 可以是任意值，但为了避免混淆，我们可以遵循以上的软规定。</p><p>通过改变 mode 的值便可创建一个环境，但除了 <code>.env.development</code> 和 .<code>env.production</code> 可以被 Vite 自动识别在 dev命令 和 build 命令情况下读取变量外，其他的 mode 配置只会根据 <code>NODE_ENV</code> 的值来识别其对应的配置文件。</p><p>我们还需要在启动命令中进行模式指定，在项目根目录的 <code>package.json</code> 中的执行脚本 <code>script</code> 中添加一条命令，如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dev-test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --mode test&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>通过指定 <code>--mode</code> 参数，Vite 就会根据当前启动命令指定的模式来加载对应的 Vite 项目中 <code>.env.[mode]</code> mode 指定的配置文件。</p><h4 id="示例">示例</h4><p>在 <code>.env.development</code> 中配置</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-2.png" class="" title="vite 环境变量配置文件"><p>我在封装的请求模块中引用 <code>VITE_APP_API_URL</code> 变量</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-1.png" class="" title="vite 环境变量配置文件"><p>通过 <code>npm run dev</code> 启动项目，在网络请求中的 <code>baseURL</code> 显示为 <code>http://10.111.11.11:8080</code></p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-3.png" class="" title="vite 环境变量配置文件"><p>我们更换环境</p><p>在 <code>.env.test</code> 中配置</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-4.png" class="" title="vite 环境变量配置文件"><p>在 <code>package.json</code> 中添加一条命令</p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-5.png" class="" title="vite 环境变量配置文件"><p>运行 <code>npm run dev-test</code>，在网络请求中的 <code>baseURL</code> 显示为 <code>http://10.122.22.22:8001</code></p><img data-src="/2024/10/11/vite%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-6.png" class="" title="vite 环境变量配置文件"><h4 id="注意事项">注意事项</h4><p>当前 <code>Vite</code> 版本执行打包命令时，如果在 <code>.env,production</code> 中指定了 <code>NODE_ENV:production</code>，会报错，只需把该配置删除即可，打包时还是会读取 <code>.env,production</code> 的配置。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
